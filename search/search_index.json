{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#gumpy","title":"gumpy","text":"<p>Genetics with Numpy</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>git clone https://github.com/oxfordmmm/gumpy\ncd gumpy\npip install .\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>https://oxfordmmm.github.io/gumpy/</p>"},{"location":"#testing","title":"Testing","text":"<p>A suite of tests can be run from a terminal:</p> <pre><code>python -m pytest --cov=gumpy -vv\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#parse-a-genbank-file","title":"Parse a genbank file","text":"<p>Genome objects can be created by passing a filename of a genbank file</p> <pre><code>from gumpy import Genome\n\ng = Genome(\"filename.gbk\")\n</code></pre>"},{"location":"#parse-a-vcf-file","title":"Parse a VCF file","text":"<p>VCFFile objects can be created by passing a filename of a vcf file</p> <pre><code>from gumpy import VCFFile\n\nvcf = VCFFile(\"filename.vcf\")\n</code></pre>"},{"location":"#apply-a-vcf-file-to-a-reference-genome","title":"Apply a VCF file to a reference genome","text":"<p>The mutations defined in a vcf file can be applied to a reference genome to produce a new Genome object containing the changes detailed in the vcf.</p> <p>If a contig is set within the vcf, the length of the contig should match the length of the genome. Otherwise, if the vcf details changes within the genome range, they will be made.</p> <pre><code>from gumpy import Genome, VCFFile\n\nreference_genome = Genome(\"reference.gbk\")\nvcf = VCFFile(\"filename.vcf\")\n\nresultant_genome = reference_genome + vcf\n</code></pre>"},{"location":"#genome-level-comparisons","title":"Genome level comparisons","text":"<p>There are two different methods for comparing changes. One can quickly check for changes which are caused by a given VCF file. The other can check for changes between two genome. The latter is therefore suited best for comparisons in which either both genomes are mutated, or the VCF file(s) are not available. The former is best suited for cases where changes caused by a VCF want to be determined, but finding gene-level differences will require rebuilding the Gene objects, which can be time consuming.</p>"},{"location":"#compare-genomes","title":"Compare genomes","text":"<p>Two genomes of the same length can be easily compared, including equality and changes between the two. Best suited to cases where two mutated genomes are to be compared.</p> <pre><code>from gumpy import Genome, GenomeDifference\n\ng1 = Genome(\"filename1.gbk\")\ng2 = Genome(\"filename2.gbk\")\n\ndiff = g2 - g1 #Genome.difference returns a GenomeDifference object\nprint(diff.snp_distance) #SNP distance between the two genomes\nprint(diff.variants) #Array of variants (SNPs/INDELs) of the differences between g2 and g1\n</code></pre>"},{"location":"#gene-level-comparisons","title":"Gene level comparisons","text":"<p>When a Genome object is instanciated, it is populated with Gene objects for each gene detailed in the genbank file. These genes can also be compared. Gene differences can be found through direct comparison of Gene objects, or systematically through the <code>gene_differences()</code> method of <code>GenomeDifference</code>.</p> <pre><code>from gumpy import Genome, Gene\n\ng1 = Genome(\"filename1.gbk\")\ng2 = Genome(\"filename2.gbk\")\n\n#Get the Gene objects for the gene \"gene1_name\" from both Genomes\ng1_gene1 = g1.build_gene[\"gene1_name\"]\ng2_gene1 = g2.build_gene[\"gene1_name\"]\n\ng1_gene1 == g2_gene1 #Equality check of the two genes\ndiff= g1_gene1 - g2_gene1 #Returns a GeneDifference object\ndiff.mutations #List of mutations in GARC describing the variation between the two genes\n</code></pre>"},{"location":"#save-and-load-genome-objects","title":"Save and load Genome objects","text":"<p>Due to how long it takes to create a Genome object, it may be beneficial to save the object to disk. The reccomendation is to utilise the <code>pickle</code> module to do so, but due to the security implications of this, do so at your own risk! An example is below:</p> <pre><code>import pickle\n\nimport gumpy\n\n#Load genome\ng = gumpy.Genome(\"filename.gbk\")\n\n#Save genome\npickle.dump(g, open(\"filename.pkl\", \"wb\"))\n\n#Load genome\ng2 = pickle.load(open(\"filename.pkl\", \"rb\"))\n\ng == g2 #True\n</code></pre>"},{"location":"readme/","title":"Home","text":""},{"location":"readme/#gumpy","title":"gumpy","text":"<p>Genetics with Numpy</p>"},{"location":"readme/#installation","title":"Installation","text":"<pre><code>git clone https://github.com/oxfordmmm/gumpy\ncd gumpy\npip install .\n</code></pre>"},{"location":"readme/#documentation","title":"Documentation","text":"<p>https://oxfordmmm.github.io/gumpy/</p>"},{"location":"readme/#testing","title":"Testing","text":"<p>A suite of tests can be run from a terminal:</p> <pre><code>python -m pytest --cov=gumpy -vv\n</code></pre>"},{"location":"readme/#usage","title":"Usage","text":""},{"location":"readme/#parse-a-genbank-file","title":"Parse a genbank file","text":"<p>Genome objects can be created by passing a filename of a genbank file</p> <pre><code>from gumpy import Genome\n\ng = Genome(\"filename.gbk\")\n</code></pre>"},{"location":"readme/#parse-a-vcf-file","title":"Parse a VCF file","text":"<p>VCFFile objects can be created by passing a filename of a vcf file</p> <pre><code>from gumpy import VCFFile\n\nvcf = VCFFile(\"filename.vcf\")\n</code></pre>"},{"location":"readme/#apply-a-vcf-file-to-a-reference-genome","title":"Apply a VCF file to a reference genome","text":"<p>The mutations defined in a vcf file can be applied to a reference genome to produce a new Genome object containing the changes detailed in the vcf.</p> <p>If a contig is set within the vcf, the length of the contig should match the length of the genome. Otherwise, if the vcf details changes within the genome range, they will be made.</p> <pre><code>from gumpy import Genome, VCFFile\n\nreference_genome = Genome(\"reference.gbk\")\nvcf = VCFFile(\"filename.vcf\")\n\nresultant_genome = reference_genome + vcf\n</code></pre>"},{"location":"readme/#genome-level-comparisons","title":"Genome level comparisons","text":"<p>There are two different methods for comparing changes. One can quickly check for changes which are caused by a given VCF file. The other can check for changes between two genome. The latter is therefore suited best for comparisons in which either both genomes are mutated, or the VCF file(s) are not available. The former is best suited for cases where changes caused by a VCF want to be determined, but finding gene-level differences will require rebuilding the Gene objects, which can be time consuming.</p>"},{"location":"readme/#compare-genomes","title":"Compare genomes","text":"<p>Two genomes of the same length can be easily compared, including equality and changes between the two. Best suited to cases where two mutated genomes are to be compared.</p> <pre><code>from gumpy import Genome, GenomeDifference\n\ng1 = Genome(\"filename1.gbk\")\ng2 = Genome(\"filename2.gbk\")\n\ndiff = g2 - g1 #Genome.difference returns a GenomeDifference object\nprint(diff.snp_distance) #SNP distance between the two genomes\nprint(diff.variants) #Array of variants (SNPs/INDELs) of the differences between g2 and g1\n</code></pre>"},{"location":"readme/#gene-level-comparisons","title":"Gene level comparisons","text":"<p>When a Genome object is instanciated, it is populated with Gene objects for each gene detailed in the genbank file. These genes can also be compared. Gene differences can be found through direct comparison of Gene objects, or systematically through the <code>gene_differences()</code> method of <code>GenomeDifference</code>.</p> <pre><code>from gumpy import Genome, Gene\n\ng1 = Genome(\"filename1.gbk\")\ng2 = Genome(\"filename2.gbk\")\n\n#Get the Gene objects for the gene \"gene1_name\" from both Genomes\ng1_gene1 = g1.build_gene[\"gene1_name\"]\ng2_gene1 = g2.build_gene[\"gene1_name\"]\n\ng1_gene1 == g2_gene1 #Equality check of the two genes\ndiff= g1_gene1 - g2_gene1 #Returns a GeneDifference object\ndiff.mutations #List of mutations in GARC describing the variation between the two genes\n</code></pre>"},{"location":"readme/#save-and-load-genome-objects","title":"Save and load Genome objects","text":"<p>Due to how long it takes to create a Genome object, it may be beneficial to save the object to disk. The reccomendation is to utilise the <code>pickle</code> module to do so, but due to the security implications of this, do so at your own risk! An example is below:</p> <pre><code>import pickle\n\nimport gumpy\n\n#Load genome\ng = gumpy.Genome(\"filename.gbk\")\n\n#Save genome\npickle.dump(g, open(\"filename.pkl\", \"wb\"))\n\n#Load genome\ng2 = pickle.load(open(\"filename.pkl\", \"rb\"))\n\ng == g2 #True\n</code></pre>"},{"location":"reference/","title":"gumpy","text":"<p>Genetics with numpy. Utilises numpy arrays internally for improved speed when parsing genomes and  assigning promoters.</p> Provides features including <ul> <li>Parsing genbank files to produce Genome (and Gene) objects;</li> <li>Handle assignment of promoter regions to genes within a genome;</li> <li>Parsing VCF files to produce VCFFile (and VCFRecord) objects;</li> <li>Applying a VCF file to a reference genome to produce a new genome;</li> <li>Finding in-depth differences between two genomes such as indels;</li> <li>Finding in-depth differences caused by a VCF such as SNPs, het and null calls;</li> <li>Finding in-depth differences between two genes such as SNPs, indels and      mutations in GARC;</li> <li>Handle intricacies of genomes such as reverse complement genes and -1 PRF.</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>gumpy</li> <li>difference</li> <li>gene</li> <li>genome</li> <li>variantfile</li> </ul>"},{"location":"reference/difference/","title":"difference","text":"<p>Used to find differences between Genomes and Genes, as well as the impact a VCF has on  a genome.</p> Abstract classes <ul> <li>Difference - Abstract class providing the ability to change data views</li> </ul> <p>Functions:</p> Name Description <code>convert_nucleotides_codons</code> <p>Converts an array of  nucleotides to an array of codons.</p> <code>setup_codon_aa_dict</code> <p>Returns a dictionary mapping codon-&gt;amino_acid</p>"},{"location":"reference/difference/#difference.Difference","title":"<code>Difference</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class used to provide the ability to switch between views. Inherited by GenomeDifference and GeneDifference.</p> <p>This should not be instantiated.</p> Source code in <code>gumpy/difference.py</code> <pre><code>class Difference(ABC):\n    \"\"\"\n    Abstract class used to provide the ability to switch between views.\n    Inherited by GenomeDifference and GeneDifference.\n\n    This should not be instantiated.\n    \"\"\"\n\n    # Give some default values to appease the linter\n    _nucleotides_full = numpy.array([])\n    codes_protein = None\n    _indels_full = numpy.array([])\n\n    def update_view(self, method: str):\n        \"\"\"Update the viewing method. Can either be `diff` or `full`:\n\n        * `diff`: Where applicable, variables return arrays of values from object1\n                where they are not equal to object 2\n        * `full`: Where applicable, variables return arrays of tuples showing\n                (object1_val, object2_val) where values are not equal between objects.\n\n        Args:\n            method (str): Name of the viewing method. Must be within `['diff', 'full']`\n        \"\"\"\n        assert isinstance(method, str), (\n            \"Invalid method \" + str(method) + \" of type \" + str(type(method))\n        )\n        assert method in [\"diff\", \"full\"], \"Invalid method: \" + method\n\n        if method == \"full\":\n            self.nucleotides = self._nucleotides_full\n\n        if method == \"diff\":\n            # Convert the full arrays into diff arrays\n            self.nucleotides = self.__full_to_diff(self._nucleotides_full)\n        self._view_method = method\n\n    def __full_to_diff(self, array: numpy.ndarray) -&gt; numpy.ndarray:\n        \"\"\"Convert an array from a full view to a diff view\n\n        Args:\n            array (numpy.ndarray): Array of tuples of values\n        Returns:\n            numpy.ndarray: Array of values from object1\n        \"\"\"\n        if len(array) &gt; 0:\n            return numpy.array([item2 for (item1, item2) in array], dtype=object)\n        else:\n            return numpy.array([])\n</code></pre>"},{"location":"reference/difference/#difference.Difference.__full_to_diff","title":"<code>__full_to_diff(array)</code>","text":"<p>Convert an array from a full view to a diff view</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>Array of tuples of values</p> required <p>Returns:     numpy.ndarray: Array of values from object1</p> Source code in <code>gumpy/difference.py</code> <pre><code>def __full_to_diff(self, array: numpy.ndarray) -&gt; numpy.ndarray:\n    \"\"\"Convert an array from a full view to a diff view\n\n    Args:\n        array (numpy.ndarray): Array of tuples of values\n    Returns:\n        numpy.ndarray: Array of values from object1\n    \"\"\"\n    if len(array) &gt; 0:\n        return numpy.array([item2 for (item1, item2) in array], dtype=object)\n    else:\n        return numpy.array([])\n</code></pre>"},{"location":"reference/difference/#difference.Difference.update_view","title":"<code>update_view(method)</code>","text":"<p>Update the viewing method. Can either be <code>diff</code> or <code>full</code>:</p> <ul> <li><code>diff</code>: Where applicable, variables return arrays of values from object1         where they are not equal to object 2</li> <li><code>full</code>: Where applicable, variables return arrays of tuples showing         (object1_val, object2_val) where values are not equal between objects.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>Name of the viewing method. Must be within <code>['diff', 'full']</code></p> required Source code in <code>gumpy/difference.py</code> <pre><code>def update_view(self, method: str):\n    \"\"\"Update the viewing method. Can either be `diff` or `full`:\n\n    * `diff`: Where applicable, variables return arrays of values from object1\n            where they are not equal to object 2\n    * `full`: Where applicable, variables return arrays of tuples showing\n            (object1_val, object2_val) where values are not equal between objects.\n\n    Args:\n        method (str): Name of the viewing method. Must be within `['diff', 'full']`\n    \"\"\"\n    assert isinstance(method, str), (\n        \"Invalid method \" + str(method) + \" of type \" + str(type(method))\n    )\n    assert method in [\"diff\", \"full\"], \"Invalid method: \" + method\n\n    if method == \"full\":\n        self.nucleotides = self._nucleotides_full\n\n    if method == \"diff\":\n        # Convert the full arrays into diff arrays\n        self.nucleotides = self.__full_to_diff(self._nucleotides_full)\n    self._view_method = method\n</code></pre>"},{"location":"reference/difference/#difference.FailedComparison","title":"<code>FailedComparison</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception to be raised in cases of a failed comparion</p> Source code in <code>gumpy/difference.py</code> <pre><code>class FailedComparison(Exception):\n    \"\"\"Exception to be raised in cases of a failed comparion\"\"\"\n\n    def __init__(self, message: str):\n        \"\"\"Constructor\n\n        Args:\n            message (str): Error message\n        \"\"\"\n        self.message = message\n        super().__init__(self.message)\n</code></pre>"},{"location":"reference/difference/#difference.FailedComparison.__init__","title":"<code>__init__(message)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Error message</p> required Source code in <code>gumpy/difference.py</code> <pre><code>def __init__(self, message: str):\n    \"\"\"Constructor\n\n    Args:\n        message (str): Error message\n    \"\"\"\n    self.message = message\n    super().__init__(self.message)\n</code></pre>"},{"location":"reference/difference/#difference.GeneDifference","title":"<code>GeneDifference</code>","text":"<p>               Bases: <code>Difference</code></p> <p>Object to store the differences within genes. The view system is inherited from     the Difference class.</p> <ul> <li>Set to <code>full</code> for arrays of tuple values where applicable.</li> <li>Set to <code>diff</code> for arrays of values from gene1 where the values vary. Default.</li> <li> <p>This can be updated using the update_view function.</p> </li> <li> <p>Instance variables:</p> <ul> <li>gene1 (gumpy.Gene): Gene object 1</li> <li>gene2 (gumpy.Gene): Gene object 2</li> <li>nucleotides (numpy.array): Array of the nucleotides at which the genes differ.     Format depends on the current view.</li> <li>mutations (numpy.array): Array of mutations in GARC between the two Gene     objects.</li> <li>indels (numpy.array): Array of indel lengths where the indel lengths differ.     Format depends on the current view.</li> <li>codons (numpy.array): Array of codons where the two Gene objects have     different codons. Format depends on the current view.</li> <li>amino_acid_sequence (numpy.array): Array of amino acids where the two Gene     objects have different amino acids. Format depends on the current view.</li> </ul> </li> <li>Functions:<ul> <li>amino_acid_variants(int) -&gt; dict: Takes an amino acid index and returns a     dictionary containing data from a vcf file (if applicable) for attributes     such as calls, ref, and alt for all nucleotides within the codons for this     amino acid index. If these genes do not code protien, returns {}</li> <li>nucleotide_variants(int) -&gt; dict: Takes a nucleotide index and returns a     dictionary containing data from a vcf file (if applicable) for attributes     such as calls, ref, and alt at the given index</li> <li>minor_populations() -&gt; [str]: Returns a list of minor population mutations     in GARC</li> </ul> </li> <li>Inherited functions:<ul> <li>update_view(str) -&gt; None: Used to change the viewing method for instance     variables. Input values are either <code>diff</code> or <code>full</code></li> </ul> </li> </ul> Source code in <code>gumpy/difference.py</code> <pre><code>class GeneDifference(Difference):\n    \"\"\"Object to store the differences within genes. The view system is inherited from\n        the Difference class.\n\n    * Set to `full` for arrays of tuple values where applicable.\n    * Set to `diff` for arrays of values from gene1 where the values vary. Default.\n    * This can be updated using the update_view function.\n\n    * Instance variables:\n        * gene1 (gumpy.Gene): Gene object 1\n        * gene2 (gumpy.Gene): Gene object 2\n        * nucleotides (numpy.array): Array of the nucleotides at which the genes differ.\n            Format depends on the current view.\n        * mutations (numpy.array): Array of mutations in GARC between the two Gene\n            objects.\n        * indels (numpy.array): Array of indel lengths where the indel lengths differ.\n            Format depends on the current view.\n        * codons (numpy.array): Array of codons where the two Gene objects have\n            different codons. Format depends on the current view.\n        * amino_acid_sequence (numpy.array): Array of amino acids where the two Gene\n            objects have different amino acids. Format depends on the current view.\n    * Functions:\n        * amino_acid_variants(int) -&gt; dict: Takes an amino acid index and returns a\n            dictionary containing data from a vcf file (if applicable) for attributes\n            such as calls, ref, and alt for all nucleotides within the codons for this\n            amino acid index. If these genes do not code protien, returns {}\n        * nucleotide_variants(int) -&gt; dict: Takes a nucleotide index and returns a\n            dictionary containing data from a vcf file (if applicable) for attributes\n            such as calls, ref, and alt at the given index\n        * minor_populations() -&gt; [str]: Returns a list of minor population mutations\n            in GARC\n    * Inherited functions:\n        * update_view(str) -&gt; None: Used to change the viewing method for instance\n            variables. Input values are either `diff` or `full`\n    \"\"\"\n\n    def __init__(self, gene1, gene2):\n        \"\"\"\n        Constructor. Takes in two gene objects and calculates the difference in a few\n            areas such as nucleotides, codons, and amino acids.\n\n        Args:\n            gene1 (gumpy.Gene): Gene object 1\n            gene2 (gumpy.Gene): Gene object 2\n        \"\"\"\n\n        assert isinstance(gene1, gumpy.Gene)\n        assert isinstance(gene2, gumpy.Gene)\n\n        if gene1.total_number_nucleotides != gene2.total_number_nucleotides:\n            # The lengths of the genes are different so comparing them is meaningless\n            raise FailedComparison(\n                \"The two genes (\"\n                + gene1.name\n                + \" and \"\n                + gene2.name\n                + \") are different lengths, so comparision failed...\"\n            )\n        if gene1.name != gene2.name:\n            warnings.warn(\n                \"The two genes given have different names (\"\n                + gene1.name\n                + \", \"\n                + gene2.name\n                + \") but the same length, continuing...\",\n                UserWarning,\n            )\n        if gene1.codes_protein != gene2.codes_protein:\n            raise FailedComparison(\n                f\"The two genes given do not have the same protein coding \"\n                f\"for {gene1.name}: Gene1 = {gene1.codes_protein}, \"\n                f\"Gene2 = {gene2.codes_protein}, so comparison failed...\"\n            )\n        self.gene1 = gene1\n        self.gene2 = gene2\n        self.codes_protein = gene1.codes_protein\n        self._view_method = \"diff\"\n\n        self._nucleotides_full = self.__nucleotides()\n        # self.mutations = self.__mutations()\n        self.__get_mutations()\n\n        self._codons_full = self.__codons()\n        self._amino_acids_full = self.__amino_acids()\n\n        self.__large_deletions()\n        self.__assign_vcf_evidence()\n\n        self.update_view(\"diff\")  # Use inherited method to set the view\n\n    def __assign_vcf_evidence(self) -&gt; None:\n        \"\"\"Once we have pulled out all of the mutations, find the VCF evidence\n        (if existing) for each\n        \"\"\"\n        evidences: List = []\n        for idx in self.nucleotide_index:\n            evidence1 = self.gene1.vcf_evidence.get(idx)\n            evidence2 = self.gene2.vcf_evidence.get(idx)\n\n            if evidence1 is not None and evidence2 is not None:\n                # We have a collision. For now, just concat FIXME\n                evidences.append([evidence1, evidence2])\n            elif evidence1 is not None:\n                evidences.append(evidence1)\n            elif evidence2 is not None:\n                evidences.append(evidence2)\n            else:\n                evidences.append(None)\n        self.vcf_evidences = evidences\n\n    def __large_deletions(self):\n        \"\"\"Check to see what proportion of the gene has been deleted. Report separately\n            than other mutations if &gt;=50% deleted\n\n        Updates internal arrays to denote a new mutation if deletion above threshold.\n        \"\"\"\n        # Find everywhere that we have different deletion within coding regions\n        mask = self.gene1.is_deleted != self.gene2.is_deleted\n\n        # Find out how much of the gene we have deleted\n        total = sum(self.gene1.is_deleted[mask]) + sum(self.gene2.is_deleted[mask])\n\n        if total &gt; 0:\n            # We have some deletions\n            percentage = total / len(self.gene1.nucleotide_sequence)\n            if percentage &gt;= 0.5:\n                # More than 50% deleted, so give a percentage\n                self.mutations = numpy.append(\n                    self.mutations, [f\"del_{round(percentage, 2)}\"]\n                )\n                # Pull out the start of the deletion for vcf evidence\n                self.nucleotide_index = numpy.append(\n                    self.nucleotide_index, [self.gene2.nucleotide_index[mask][0]]\n                )\n\n                self.amino_acid_number = numpy.append(self.amino_acid_number, [None])\n\n                # Get the nucleotide number of the first base of the gene\n                # Not predictable as promoters are variable length\n                self.nucleotide_number = numpy.append(\n                    self.nucleotide_number,\n                    [\n                        self.gene2.nucleotide_number[\n                            self.gene1.is_deleted | self.gene2.is_deleted\n                        ][0]\n                    ],\n                )\n\n                self.gene_position = numpy.append(self.gene_position, [None])\n                self.is_cds = numpy.append(self.is_cds, [True])\n                self.is_promoter = numpy.append(self.is_promoter, [False])\n                self.is_indel = numpy.append(self.is_indel, [True])\n                self.indel_length = numpy.append(self.indel_length, [-1 * total])\n                self.indel_nucleotides = numpy.append(\n                    self.indel_nucleotides,\n                    [\"\".join(self.gene1.nucleotide_sequence[mask])],\n                )\n                self.ref_nucleotides = numpy.append(self.ref_nucleotides, [None])\n                self.alt_nucleotides = numpy.append(self.alt_nucleotides, [None])\n                self.is_snp = numpy.append(self.is_snp, [False])\n                self.is_het = numpy.append(self.is_het, [False])\n                self.is_null = numpy.append(self.is_null, [False])\n            else:\n                # Check for a deletion at the start of the gene which is the result of\n                #   an upstream del\n                if self.gene1.reverse_complement:\n                    # This is difficult as revcomp shifts dels upstream by the length\n                    #   of the del\n                    # So we have to find a del in the RHS of the gene which would be\n                    #   the last item if not shifted\n                    pos = -1\n                    while pos * -1 &lt; len(self.gene1.nucleotide_sequence) / 2:\n                        if (\n                            self.gene1.indel_length[pos] &lt; 0\n                            and not self.gene1.is_indel[pos]\n                        ):\n                            # Del here in gene1 so check for validity\n                            if (\n                                self.gene1.nucleotide_index[pos]\n                                + self.gene1.indel_length[pos]\n                                + 1\n                                == self.gene1.nucleotide_index[-1]\n                            ):\n                                # Re-adusting for deletion, this matches\n                                break\n                        if (\n                            self.gene2.indel_length[pos] &lt; 0\n                            and not self.gene2.is_indel[pos]\n                        ):\n                            # Del here in gene2 so check for validity\n                            if (\n                                self.gene2.nucleotide_index[pos]\n                                + self.gene2.indel_length[pos]\n                                + 1\n                                == self.gene2.nucleotide_index[-1]\n                            ):\n                                # Re-adusting for deletion, this matches\n                                break\n                        pos -= 1\n                else:\n                    # If not revcomp, the del is the first item\n                    pos = 0\n\n                if (\n                    self.gene1.indel_length[pos] &lt; 0 and not self.gene1.is_indel[pos]\n                ) and (\n                    self.gene2.indel_length[pos] &lt; 0 and not self.gene2.is_indel[pos]\n                ):\n                    # Both have a del, so no difference\n                    return\n\n                if self.gene1.indel_length[pos] &lt; 0 and not self.gene1.is_indel[pos]:\n                    deleted = self.gene1.indel_nucleotides[pos]\n                elif self.gene2.indel_length[pos] &lt; 0 and not self.gene2.is_indel[pos]:\n                    deleted = self.gene2.indel_nucleotides[pos]\n                else:\n                    # Neither, so no difference either\n                    return\n\n                # Adjust idx to point to the  right VCF evidence\n                if self.gene1.reverse_complement:\n                    idx = self.gene1.nucleotide_index[pos + len(deleted) - 1]\n                else:\n                    idx = self.gene1.nucleotide_index[pos]\n\n                pos = self.gene1.nucleotide_number[pos]\n\n                self.mutations = numpy.append(self.mutations, [f\"{pos}_del_{deleted}\"])\n                # Pull out the start of the deletion for vcf evidence\n                self.nucleotide_index = numpy.append(self.nucleotide_index, [idx])\n                self.amino_acid_number = numpy.append(self.amino_acid_number, [None])\n\n                # Get the nucleotide number of the first base of the gene\n                # Not predictable as promoters are variable length\n                self.nucleotide_number = numpy.append(\n                    self.nucleotide_number,\n                    [\n                        self.gene2.nucleotide_number[\n                            self.gene1.is_deleted | self.gene2.is_deleted\n                        ][0]\n                    ],\n                )\n\n                self.gene_position = numpy.append(self.gene_position, [pos])\n                self.is_cds = numpy.append(self.is_cds, [True])\n                self.is_promoter = numpy.append(self.is_promoter, [False])\n                self.is_indel = numpy.append(self.is_indel, [True])\n                self.indel_length = numpy.append(self.indel_length, [len(deleted)])\n                self.indel_nucleotides = numpy.append(self.indel_nucleotides, [deleted])\n                self.ref_nucleotides = numpy.append(self.ref_nucleotides, [None])\n                self.alt_nucleotides = numpy.append(self.alt_nucleotides, [None])\n                self.is_snp = numpy.append(self.is_snp, [False])\n                self.is_het = numpy.append(self.is_het, [False])\n                self.is_null = numpy.append(self.is_null, [False])\n\n    def minor_populations(self, interpretation: str = \"reads\") -&gt; List[str]:\n        \"\"\"Get the minor population mutations in GARC\n\n        Args:\n            interpretation (str, optional): How to report minor population. 'reads'\n                reports number of reads. 'percentage' reports fractional read support.\n                Defaults to 'reads'.\n\n        Returns:\n            [str]: List of mutations in GARC\n        \"\"\"\n        return self.gene2.minority_populations_GARC(\n            interpretation=interpretation, reference=self.gene1\n        )\n\n    def __nucleotides(self) -&gt; numpy.ndarray:\n        \"\"\"Find the differences in nucleotides\n\n        Returns:\n            numpy.ndarray: Array of tuples (gene1_nucleotide, gene2_nucleotide)\n        \"\"\"\n        return numpy.array(\n            [\n                (n1, n2)\n                for (n1, n2) in zip(\n                    self.gene1.nucleotide_sequence, self.gene2.nucleotide_sequence\n                )\n                if n1 != n2\n            ]\n        )\n\n    def __get_mutations(self):\n        \"\"\"Get the mutations between the two genes, populating internal arrays\"\"\"\n\n        mutations = []\n        amino_acid_number = []\n        nucleotide_number = []\n        nucleotide_index = []\n        gene_position = []\n        is_cds = []\n        is_indel = []\n        is_promoter = []\n        indel_length = []\n        indel_nucleotides = []\n        ref_nucleotides = []\n        alt_nucleotides = []\n        is_snp = []\n        is_het = []\n        is_null = []\n        variants = []\n\n        if self.codes_protein:\n            mask = self.gene1.codons != self.gene2.codons\n            for r, num, a, codon1, codon2 in zip(\n                self.gene1.amino_acid_sequence[mask],\n                self.gene1.amino_acid_number[mask],\n                self.gene2.amino_acid_sequence[mask],\n                self.gene1.codons[mask],\n                self.gene2.codons[mask],\n            ):\n                # ref.append(r)\n                # alt.append(a)\n                mutations.append(r + str(num) + a)\n                if a == \"X\":\n                    is_null.append(True)\n                    is_het.append(False)\n                    is_snp.append(False)\n                elif a == \"Z\":\n                    is_null.append(False)\n                    is_het.append(True)\n                    is_snp.append(False)\n                else:\n                    is_null.append(False)\n                    is_het.append(False)\n                    is_snp.append(True)\n                amino_acid_number.append(num)\n                nucleotide_number.append(None)\n                nucleotide_index.append(None)\n                gene_position.append(num)\n                is_cds.append(True)\n                is_indel.append(False)\n                is_promoter.append(False)\n                indel_length.append(None)\n                indel_nucleotides.append(None)\n                ref_nucleotides.append(codon1)\n                alt_nucleotides.append(codon2)\n\n                # Reconstruct the variant which caused this mutation to allow joining\n                #   mutation and variant tables\n                codon_nucleotide_indices = self.gene1.nucleotide_index[\n                    self.gene1.is_cds\n                ][self.gene1.codon_number == num]\n                v = \"\"\n                for i, (r_, a_) in enumerate(zip(codon1, codon2)):\n                    if r_ != a_:\n                        v += str(codon_nucleotide_indices[i]) + r_ + \"&gt;\" + a_ + \"&amp;\"\n                if v[-1] == \"&amp;\":\n                    v = v[:-1]\n                variants.append(v)\n\n                # If synonymous mutation, pull out nucleotide variants too\n                # This lets us determine effects of mutations such as fabG1@L203L more\n                #   precisely\n                if r == a:\n                    for i, (rn, an) in enumerate(zip(codon1, codon2)):\n                        if rn != an:\n                            mutations.append(rn + str((num - 1) * 3 + i + 1) + an)\n                            is_null.append(an == \"x\")\n                            is_het.append(an == \"z\")\n                            is_snp.append(an not in [\"x\", \"z\"])\n                            amino_acid_number.append(None)\n                            nucleotide_number.append((num - 1) * 3 + i + 1)\n                            nucleotide_index.append(\n                                self.gene1.nucleotide_index[\n                                    self.gene1.nucleotide_number\n                                    == (num - 1) * 3 + i + 1\n                                ][0]\n                            )\n                            gene_position.append((num - 1) * 3 + i + 1)\n                            is_cds.append(True)\n                            is_indel.append(False)\n                            is_promoter.append(False)\n                            indel_length.append(None)\n                            indel_nucleotides.append(None)\n                            ref_nucleotides.append(rn)\n                            alt_nucleotides.append(an)\n\n                            variants.append(\n                                str(codon_nucleotide_indices[i]) + rn + \"&gt;\" + an\n                            )\n\n            mask = (\n                self.gene1.nucleotide_sequence != self.gene2.nucleotide_sequence\n            ) &amp; (self.gene1.is_promoter)\n\n            for r, num, a, idx in zip(\n                self.gene1.nucleotide_sequence[mask],\n                self.gene1.nucleotide_number[mask],\n                self.gene2.nucleotide_sequence[mask],\n                self.gene1.nucleotide_index[mask],\n            ):\n                mutations.append(r + str(num) + a)\n                # ref.append(r)\n                # alt.append(a)\n                amino_acid_number.append(None)\n                nucleotide_number.append(num)\n                nucleotide_index.append(idx)\n                gene_position.append(num)\n                is_cds.append(False)\n                is_indel.append(False)\n                is_promoter.append(True)\n                indel_length.append(None)\n                indel_nucleotides.append(None)\n                ref_nucleotides.append(r)\n                alt_nucleotides.append(a)\n                if a == \"x\":\n                    is_null.append(True)\n                    is_het.append(False)\n                    is_snp.append(False)\n                elif a == \"z\":\n                    is_null.append(False)\n                    is_het.append(True)\n                    is_snp.append(False)\n                else:\n                    is_null.append(False)\n                    is_het.append(False)\n                    is_snp.append(True)\n\n                # Reconstruct the variant which caused this mutation to allow joining\n                #   mutation and variant tables\n                variants.append(str(idx) + r + \"&gt;\" + a)\n\n        else:\n            mask = self.gene1.nucleotide_sequence != self.gene2.nucleotide_sequence\n\n            for r, num, a, idx in zip(\n                self.gene1.nucleotide_sequence[mask],\n                self.gene1.nucleotide_number[mask],\n                self.gene2.nucleotide_sequence[mask],\n                self.gene1.nucleotide_index[mask],\n            ):\n                mutations.append(r + str(num) + a)\n                # ref.append(r)\n                # alt.append(a)\n                amino_acid_number.append(None)\n                nucleotide_number.append(num)\n                nucleotide_index.append(idx)\n                gene_position.append(num)\n                if num &gt; 0:\n                    is_cds.append(False)\n                    is_promoter.append(False)\n                else:\n                    is_cds.append(False)\n                    is_promoter.append(True)\n                is_indel.append(False)\n                indel_length.append(None)\n                indel_nucleotides.append(None)\n                ref_nucleotides.append(r)\n                alt_nucleotides.append(a)\n                if a == \"x\":\n                    is_null.append(True)\n                    is_het.append(False)\n                    is_snp.append(False)\n                elif a == \"z\":\n                    is_null.append(False)\n                    is_het.append(True)\n                    is_snp.append(False)\n                else:\n                    is_null.append(False)\n                    is_het.append(False)\n                    is_snp.append(True)\n\n                # Reconstruct the variant which caused this mutation to allow joining\n                #   mutation and variant tables\n                variants.append(str(idx) + r + \"&gt;\" + a)\n\n        # now let's do indels\n        assert (\n            numpy.sum(\n                (self.gene1.is_indel &amp; self.gene2.is_indel)\n                &amp; (self.gene1.indel_nucleotides != self.gene2.indel_nucleotides)\n            )\n            == 0\n        ), (\n            \"both genes have different indels at one or more of the same positions -- \"\n            \"this cannot be easily be resolved!\"\n        )\n\n        mask = self.gene2.is_indel &amp; (\n            self.gene1.indel_nucleotides != self.gene2.indel_nucleotides\n        )\n\n        for num, length, alt, idx in zip(\n            self.gene1.nucleotide_number[mask],\n            self.gene2.indel_length[mask],\n            self.gene2.indel_nucleotides[mask],\n            self.gene2.indel_index[mask],\n        ):\n            # ref.append(None)\n            # alt.append(None)\n            amino_acid_number.append(None)\n            nucleotide_number.append(num)\n            nucleotide_index.append(idx)\n            gene_position.append(num)\n            if length &gt; 0:\n                mutations.append(str(num) + \"_ins_\" + str(alt))\n            else:\n                mutations.append(str(num) + \"_del_\" + str(alt))\n            if num &gt; 0:\n                is_cds.append(True)\n                is_promoter.append(False)\n            else:\n                is_cds.append(False)\n                is_promoter.append(True)\n            is_indel.append(True)\n            indel_length.append(length)\n            indel_nucleotides.append(alt)\n            ref_nucleotides.append(None)\n            alt_nucleotides.append(None)\n            is_null.append(False)\n            is_het.append(False)\n            is_snp.append(False)\n\n            # Reconstruct the variant which caused this mutation to allow joining\n            #   mutation and variant tables\n            m = mutations[-1].split(\"_\")[1:]\n            if self.gene2.reverse_complement:\n                # These are slightly different as revcomp need changes\n                variants.append(\n                    \"_\".join([self.gene2.revcomp_indel_nc_index[str(num)]] + m)\n                )\n            else:\n                variants.append(\n                    \"_\".join(\n                        [\n                            str(i)\n                            for i in self.gene2.nucleotide_index[\n                                self.gene2.nucleotide_number == num\n                            ]\n                        ]\n                        + m\n                    )\n                )\n\n        mask = self.gene1.is_indel &amp; (\n            self.gene1.indel_nucleotides != self.gene2.indel_nucleotides\n        )\n\n        for num, length, alt, idx in zip(\n            self.gene1.nucleotide_number[mask],\n            self.gene1.indel_length[mask],\n            self.gene1.indel_nucleotides[mask],\n            self.gene1.indel_index[mask],\n        ):\n            # ref.append(None)\n            # alt.append(None)\n            amino_acid_number.append(None)\n            nucleotide_number.append(num)\n            nucleotide_index.append(idx)\n            gene_position.append(num)\n            length *= -1\n            if length &gt; 0:\n                mutations.append(str(num) + \"_ins_\" + str(alt))\n            else:\n                mutations.append(str(num) + \"_del_\" + str(alt))\n            if num &gt; 0:\n                is_cds.append(True)\n                is_promoter.append(False)\n            else:\n                is_cds.append(False)\n                is_promoter.append(True)\n            is_indel.append(True)\n            indel_length.append(length)\n            indel_nucleotides.append(alt)\n            ref_nucleotides.append(None)\n            alt_nucleotides.append(None)\n            is_null.append(False)\n            is_het.append(False)\n            is_snp.append(False)\n\n            # Reconstruct the variant which caused this mutation to allow joining\n            #   mutation and variant tables\n            m = mutations[-1].split(\"_\")[1:]\n            if self.gene1.reverse_complement:\n                # These are slightly different as revcomp need changes\n                variants.append(\n                    \"_\".join([self.gene1.revcomp_indel_nc_index[str(num)]] + m)\n                )\n            else:\n                variants.append(\n                    \"_\".join(\n                        [\n                            str(i)\n                            for i in self.gene1.nucleotide_index[\n                                self.gene1.nucleotide_number == num\n                            ]\n                        ]\n                        + m\n                    )\n                )\n        self.mutations = numpy.array(mutations)\n        self.amino_acid_number = numpy.array(amino_acid_number)\n        self.nucleotide_number = numpy.array(nucleotide_number)\n        self.nucleotide_index = numpy.array(nucleotide_index)\n        self.gene_position = numpy.array(gene_position)\n        self.is_cds = numpy.array(is_cds)\n        self.is_promoter = numpy.array(is_promoter)\n        self.is_indel = numpy.array(is_indel)\n        self.indel_length = numpy.array(indel_length)\n        self.indel_nucleotides = numpy.array(indel_nucleotides)\n        self.ref_nucleotides = numpy.array(ref_nucleotides)\n        self.alt_nucleotides = numpy.array(alt_nucleotides)\n        self.is_snp = numpy.array(is_snp)\n        self.is_het = numpy.array(is_het)\n        self.is_null = numpy.array(is_null)\n        self.variants = variants\n\n    def __codons(self) -&gt; numpy.ndarray:\n        \"\"\"Find the codon positions which are different within the genes\n            (within codon regions)\n\n        Returns:\n            numpy.ndarray: Array of codons which differ of the form\n                [(gene1_codon, gene2_codon)]\n        \"\"\"\n        codons1 = convert_nucleotides_codons(\n            self.gene1.nucleotide_sequence[self.gene1.is_cds]\n        )\n        codons2 = convert_nucleotides_codons(\n            self.gene2.nucleotide_sequence[self.gene2.is_cds]\n        )\n        mask = codons1 != codons2\n        codons1 = codons1[mask]\n        codons2 = codons2[mask]\n        return numpy.array(list(zip(codons1, codons2)))\n\n    def __amino_acids(self) -&gt; numpy.ndarray:\n        \"\"\"Calculate the difference in amino acid sequences (within codon regions)\n\n        Returns:\n            numpy.ndarray: Array of tuples showing (amino_acid_1, amino_acid_2)\n        \"\"\"\n        codon_to_amino_acid = setup_codon_aa_dict()\n\n        aa_diff: List[Tuple[str | None, str | None]] = []\n        for codon1, codon2 in self._codons_full:\n            aa1 = codon_to_amino_acid[codon1]\n            aa2 = codon_to_amino_acid[codon2]\n            if codon1 != codon2:\n                aa_diff.append((aa1, aa2))\n                # Adding nucleotide variants for synon\n                if aa1 == aa2:\n                    for c1, c2 in zip(codon1, codon2):\n                        if c1 != c2:\n                            aa_diff.append((None, None))\n        # Mutations should be in order of aa-&gt;indel/promoter, so pad to match\n        fixed = aa_diff\n        # Promoters\n        to_add = sum(1 for p in numpy.logical_or(self.is_promoter, self.is_indel) if p)\n        for _ in range(to_add):\n            fixed.append((None, None))\n        return numpy.array(fixed)\n</code></pre>"},{"location":"reference/difference/#difference.GeneDifference.__amino_acids","title":"<code>__amino_acids()</code>","text":"<p>Calculate the difference in amino acid sequences (within codon regions)</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Array of tuples showing (amino_acid_1, amino_acid_2)</p> Source code in <code>gumpy/difference.py</code> <pre><code>def __amino_acids(self) -&gt; numpy.ndarray:\n    \"\"\"Calculate the difference in amino acid sequences (within codon regions)\n\n    Returns:\n        numpy.ndarray: Array of tuples showing (amino_acid_1, amino_acid_2)\n    \"\"\"\n    codon_to_amino_acid = setup_codon_aa_dict()\n\n    aa_diff: List[Tuple[str | None, str | None]] = []\n    for codon1, codon2 in self._codons_full:\n        aa1 = codon_to_amino_acid[codon1]\n        aa2 = codon_to_amino_acid[codon2]\n        if codon1 != codon2:\n            aa_diff.append((aa1, aa2))\n            # Adding nucleotide variants for synon\n            if aa1 == aa2:\n                for c1, c2 in zip(codon1, codon2):\n                    if c1 != c2:\n                        aa_diff.append((None, None))\n    # Mutations should be in order of aa-&gt;indel/promoter, so pad to match\n    fixed = aa_diff\n    # Promoters\n    to_add = sum(1 for p in numpy.logical_or(self.is_promoter, self.is_indel) if p)\n    for _ in range(to_add):\n        fixed.append((None, None))\n    return numpy.array(fixed)\n</code></pre>"},{"location":"reference/difference/#difference.GeneDifference.__assign_vcf_evidence","title":"<code>__assign_vcf_evidence()</code>","text":"<p>Once we have pulled out all of the mutations, find the VCF evidence (if existing) for each</p> Source code in <code>gumpy/difference.py</code> <pre><code>def __assign_vcf_evidence(self) -&gt; None:\n    \"\"\"Once we have pulled out all of the mutations, find the VCF evidence\n    (if existing) for each\n    \"\"\"\n    evidences: List = []\n    for idx in self.nucleotide_index:\n        evidence1 = self.gene1.vcf_evidence.get(idx)\n        evidence2 = self.gene2.vcf_evidence.get(idx)\n\n        if evidence1 is not None and evidence2 is not None:\n            # We have a collision. For now, just concat FIXME\n            evidences.append([evidence1, evidence2])\n        elif evidence1 is not None:\n            evidences.append(evidence1)\n        elif evidence2 is not None:\n            evidences.append(evidence2)\n        else:\n            evidences.append(None)\n    self.vcf_evidences = evidences\n</code></pre>"},{"location":"reference/difference/#difference.GeneDifference.__codons","title":"<code>__codons()</code>","text":"<p>Find the codon positions which are different within the genes     (within codon regions)</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Array of codons which differ of the form [(gene1_codon, gene2_codon)]</p> Source code in <code>gumpy/difference.py</code> <pre><code>def __codons(self) -&gt; numpy.ndarray:\n    \"\"\"Find the codon positions which are different within the genes\n        (within codon regions)\n\n    Returns:\n        numpy.ndarray: Array of codons which differ of the form\n            [(gene1_codon, gene2_codon)]\n    \"\"\"\n    codons1 = convert_nucleotides_codons(\n        self.gene1.nucleotide_sequence[self.gene1.is_cds]\n    )\n    codons2 = convert_nucleotides_codons(\n        self.gene2.nucleotide_sequence[self.gene2.is_cds]\n    )\n    mask = codons1 != codons2\n    codons1 = codons1[mask]\n    codons2 = codons2[mask]\n    return numpy.array(list(zip(codons1, codons2)))\n</code></pre>"},{"location":"reference/difference/#difference.GeneDifference.__get_mutations","title":"<code>__get_mutations()</code>","text":"<p>Get the mutations between the two genes, populating internal arrays</p> Source code in <code>gumpy/difference.py</code> <pre><code>def __get_mutations(self):\n    \"\"\"Get the mutations between the two genes, populating internal arrays\"\"\"\n\n    mutations = []\n    amino_acid_number = []\n    nucleotide_number = []\n    nucleotide_index = []\n    gene_position = []\n    is_cds = []\n    is_indel = []\n    is_promoter = []\n    indel_length = []\n    indel_nucleotides = []\n    ref_nucleotides = []\n    alt_nucleotides = []\n    is_snp = []\n    is_het = []\n    is_null = []\n    variants = []\n\n    if self.codes_protein:\n        mask = self.gene1.codons != self.gene2.codons\n        for r, num, a, codon1, codon2 in zip(\n            self.gene1.amino_acid_sequence[mask],\n            self.gene1.amino_acid_number[mask],\n            self.gene2.amino_acid_sequence[mask],\n            self.gene1.codons[mask],\n            self.gene2.codons[mask],\n        ):\n            # ref.append(r)\n            # alt.append(a)\n            mutations.append(r + str(num) + a)\n            if a == \"X\":\n                is_null.append(True)\n                is_het.append(False)\n                is_snp.append(False)\n            elif a == \"Z\":\n                is_null.append(False)\n                is_het.append(True)\n                is_snp.append(False)\n            else:\n                is_null.append(False)\n                is_het.append(False)\n                is_snp.append(True)\n            amino_acid_number.append(num)\n            nucleotide_number.append(None)\n            nucleotide_index.append(None)\n            gene_position.append(num)\n            is_cds.append(True)\n            is_indel.append(False)\n            is_promoter.append(False)\n            indel_length.append(None)\n            indel_nucleotides.append(None)\n            ref_nucleotides.append(codon1)\n            alt_nucleotides.append(codon2)\n\n            # Reconstruct the variant which caused this mutation to allow joining\n            #   mutation and variant tables\n            codon_nucleotide_indices = self.gene1.nucleotide_index[\n                self.gene1.is_cds\n            ][self.gene1.codon_number == num]\n            v = \"\"\n            for i, (r_, a_) in enumerate(zip(codon1, codon2)):\n                if r_ != a_:\n                    v += str(codon_nucleotide_indices[i]) + r_ + \"&gt;\" + a_ + \"&amp;\"\n            if v[-1] == \"&amp;\":\n                v = v[:-1]\n            variants.append(v)\n\n            # If synonymous mutation, pull out nucleotide variants too\n            # This lets us determine effects of mutations such as fabG1@L203L more\n            #   precisely\n            if r == a:\n                for i, (rn, an) in enumerate(zip(codon1, codon2)):\n                    if rn != an:\n                        mutations.append(rn + str((num - 1) * 3 + i + 1) + an)\n                        is_null.append(an == \"x\")\n                        is_het.append(an == \"z\")\n                        is_snp.append(an not in [\"x\", \"z\"])\n                        amino_acid_number.append(None)\n                        nucleotide_number.append((num - 1) * 3 + i + 1)\n                        nucleotide_index.append(\n                            self.gene1.nucleotide_index[\n                                self.gene1.nucleotide_number\n                                == (num - 1) * 3 + i + 1\n                            ][0]\n                        )\n                        gene_position.append((num - 1) * 3 + i + 1)\n                        is_cds.append(True)\n                        is_indel.append(False)\n                        is_promoter.append(False)\n                        indel_length.append(None)\n                        indel_nucleotides.append(None)\n                        ref_nucleotides.append(rn)\n                        alt_nucleotides.append(an)\n\n                        variants.append(\n                            str(codon_nucleotide_indices[i]) + rn + \"&gt;\" + an\n                        )\n\n        mask = (\n            self.gene1.nucleotide_sequence != self.gene2.nucleotide_sequence\n        ) &amp; (self.gene1.is_promoter)\n\n        for r, num, a, idx in zip(\n            self.gene1.nucleotide_sequence[mask],\n            self.gene1.nucleotide_number[mask],\n            self.gene2.nucleotide_sequence[mask],\n            self.gene1.nucleotide_index[mask],\n        ):\n            mutations.append(r + str(num) + a)\n            # ref.append(r)\n            # alt.append(a)\n            amino_acid_number.append(None)\n            nucleotide_number.append(num)\n            nucleotide_index.append(idx)\n            gene_position.append(num)\n            is_cds.append(False)\n            is_indel.append(False)\n            is_promoter.append(True)\n            indel_length.append(None)\n            indel_nucleotides.append(None)\n            ref_nucleotides.append(r)\n            alt_nucleotides.append(a)\n            if a == \"x\":\n                is_null.append(True)\n                is_het.append(False)\n                is_snp.append(False)\n            elif a == \"z\":\n                is_null.append(False)\n                is_het.append(True)\n                is_snp.append(False)\n            else:\n                is_null.append(False)\n                is_het.append(False)\n                is_snp.append(True)\n\n            # Reconstruct the variant which caused this mutation to allow joining\n            #   mutation and variant tables\n            variants.append(str(idx) + r + \"&gt;\" + a)\n\n    else:\n        mask = self.gene1.nucleotide_sequence != self.gene2.nucleotide_sequence\n\n        for r, num, a, idx in zip(\n            self.gene1.nucleotide_sequence[mask],\n            self.gene1.nucleotide_number[mask],\n            self.gene2.nucleotide_sequence[mask],\n            self.gene1.nucleotide_index[mask],\n        ):\n            mutations.append(r + str(num) + a)\n            # ref.append(r)\n            # alt.append(a)\n            amino_acid_number.append(None)\n            nucleotide_number.append(num)\n            nucleotide_index.append(idx)\n            gene_position.append(num)\n            if num &gt; 0:\n                is_cds.append(False)\n                is_promoter.append(False)\n            else:\n                is_cds.append(False)\n                is_promoter.append(True)\n            is_indel.append(False)\n            indel_length.append(None)\n            indel_nucleotides.append(None)\n            ref_nucleotides.append(r)\n            alt_nucleotides.append(a)\n            if a == \"x\":\n                is_null.append(True)\n                is_het.append(False)\n                is_snp.append(False)\n            elif a == \"z\":\n                is_null.append(False)\n                is_het.append(True)\n                is_snp.append(False)\n            else:\n                is_null.append(False)\n                is_het.append(False)\n                is_snp.append(True)\n\n            # Reconstruct the variant which caused this mutation to allow joining\n            #   mutation and variant tables\n            variants.append(str(idx) + r + \"&gt;\" + a)\n\n    # now let's do indels\n    assert (\n        numpy.sum(\n            (self.gene1.is_indel &amp; self.gene2.is_indel)\n            &amp; (self.gene1.indel_nucleotides != self.gene2.indel_nucleotides)\n        )\n        == 0\n    ), (\n        \"both genes have different indels at one or more of the same positions -- \"\n        \"this cannot be easily be resolved!\"\n    )\n\n    mask = self.gene2.is_indel &amp; (\n        self.gene1.indel_nucleotides != self.gene2.indel_nucleotides\n    )\n\n    for num, length, alt, idx in zip(\n        self.gene1.nucleotide_number[mask],\n        self.gene2.indel_length[mask],\n        self.gene2.indel_nucleotides[mask],\n        self.gene2.indel_index[mask],\n    ):\n        # ref.append(None)\n        # alt.append(None)\n        amino_acid_number.append(None)\n        nucleotide_number.append(num)\n        nucleotide_index.append(idx)\n        gene_position.append(num)\n        if length &gt; 0:\n            mutations.append(str(num) + \"_ins_\" + str(alt))\n        else:\n            mutations.append(str(num) + \"_del_\" + str(alt))\n        if num &gt; 0:\n            is_cds.append(True)\n            is_promoter.append(False)\n        else:\n            is_cds.append(False)\n            is_promoter.append(True)\n        is_indel.append(True)\n        indel_length.append(length)\n        indel_nucleotides.append(alt)\n        ref_nucleotides.append(None)\n        alt_nucleotides.append(None)\n        is_null.append(False)\n        is_het.append(False)\n        is_snp.append(False)\n\n        # Reconstruct the variant which caused this mutation to allow joining\n        #   mutation and variant tables\n        m = mutations[-1].split(\"_\")[1:]\n        if self.gene2.reverse_complement:\n            # These are slightly different as revcomp need changes\n            variants.append(\n                \"_\".join([self.gene2.revcomp_indel_nc_index[str(num)]] + m)\n            )\n        else:\n            variants.append(\n                \"_\".join(\n                    [\n                        str(i)\n                        for i in self.gene2.nucleotide_index[\n                            self.gene2.nucleotide_number == num\n                        ]\n                    ]\n                    + m\n                )\n            )\n\n    mask = self.gene1.is_indel &amp; (\n        self.gene1.indel_nucleotides != self.gene2.indel_nucleotides\n    )\n\n    for num, length, alt, idx in zip(\n        self.gene1.nucleotide_number[mask],\n        self.gene1.indel_length[mask],\n        self.gene1.indel_nucleotides[mask],\n        self.gene1.indel_index[mask],\n    ):\n        # ref.append(None)\n        # alt.append(None)\n        amino_acid_number.append(None)\n        nucleotide_number.append(num)\n        nucleotide_index.append(idx)\n        gene_position.append(num)\n        length *= -1\n        if length &gt; 0:\n            mutations.append(str(num) + \"_ins_\" + str(alt))\n        else:\n            mutations.append(str(num) + \"_del_\" + str(alt))\n        if num &gt; 0:\n            is_cds.append(True)\n            is_promoter.append(False)\n        else:\n            is_cds.append(False)\n            is_promoter.append(True)\n        is_indel.append(True)\n        indel_length.append(length)\n        indel_nucleotides.append(alt)\n        ref_nucleotides.append(None)\n        alt_nucleotides.append(None)\n        is_null.append(False)\n        is_het.append(False)\n        is_snp.append(False)\n\n        # Reconstruct the variant which caused this mutation to allow joining\n        #   mutation and variant tables\n        m = mutations[-1].split(\"_\")[1:]\n        if self.gene1.reverse_complement:\n            # These are slightly different as revcomp need changes\n            variants.append(\n                \"_\".join([self.gene1.revcomp_indel_nc_index[str(num)]] + m)\n            )\n        else:\n            variants.append(\n                \"_\".join(\n                    [\n                        str(i)\n                        for i in self.gene1.nucleotide_index[\n                            self.gene1.nucleotide_number == num\n                        ]\n                    ]\n                    + m\n                )\n            )\n    self.mutations = numpy.array(mutations)\n    self.amino_acid_number = numpy.array(amino_acid_number)\n    self.nucleotide_number = numpy.array(nucleotide_number)\n    self.nucleotide_index = numpy.array(nucleotide_index)\n    self.gene_position = numpy.array(gene_position)\n    self.is_cds = numpy.array(is_cds)\n    self.is_promoter = numpy.array(is_promoter)\n    self.is_indel = numpy.array(is_indel)\n    self.indel_length = numpy.array(indel_length)\n    self.indel_nucleotides = numpy.array(indel_nucleotides)\n    self.ref_nucleotides = numpy.array(ref_nucleotides)\n    self.alt_nucleotides = numpy.array(alt_nucleotides)\n    self.is_snp = numpy.array(is_snp)\n    self.is_het = numpy.array(is_het)\n    self.is_null = numpy.array(is_null)\n    self.variants = variants\n</code></pre>"},{"location":"reference/difference/#difference.GeneDifference.__init__","title":"<code>__init__(gene1, gene2)</code>","text":"<p>Constructor. Takes in two gene objects and calculates the difference in a few     areas such as nucleotides, codons, and amino acids.</p> <p>Parameters:</p> Name Type Description Default <code>gene1</code> <code>Gene</code> <p>Gene object 1</p> required <code>gene2</code> <code>Gene</code> <p>Gene object 2</p> required Source code in <code>gumpy/difference.py</code> <pre><code>def __init__(self, gene1, gene2):\n    \"\"\"\n    Constructor. Takes in two gene objects and calculates the difference in a few\n        areas such as nucleotides, codons, and amino acids.\n\n    Args:\n        gene1 (gumpy.Gene): Gene object 1\n        gene2 (gumpy.Gene): Gene object 2\n    \"\"\"\n\n    assert isinstance(gene1, gumpy.Gene)\n    assert isinstance(gene2, gumpy.Gene)\n\n    if gene1.total_number_nucleotides != gene2.total_number_nucleotides:\n        # The lengths of the genes are different so comparing them is meaningless\n        raise FailedComparison(\n            \"The two genes (\"\n            + gene1.name\n            + \" and \"\n            + gene2.name\n            + \") are different lengths, so comparision failed...\"\n        )\n    if gene1.name != gene2.name:\n        warnings.warn(\n            \"The two genes given have different names (\"\n            + gene1.name\n            + \", \"\n            + gene2.name\n            + \") but the same length, continuing...\",\n            UserWarning,\n        )\n    if gene1.codes_protein != gene2.codes_protein:\n        raise FailedComparison(\n            f\"The two genes given do not have the same protein coding \"\n            f\"for {gene1.name}: Gene1 = {gene1.codes_protein}, \"\n            f\"Gene2 = {gene2.codes_protein}, so comparison failed...\"\n        )\n    self.gene1 = gene1\n    self.gene2 = gene2\n    self.codes_protein = gene1.codes_protein\n    self._view_method = \"diff\"\n\n    self._nucleotides_full = self.__nucleotides()\n    # self.mutations = self.__mutations()\n    self.__get_mutations()\n\n    self._codons_full = self.__codons()\n    self._amino_acids_full = self.__amino_acids()\n\n    self.__large_deletions()\n    self.__assign_vcf_evidence()\n\n    self.update_view(\"diff\")  # Use inherited method to set the view\n</code></pre>"},{"location":"reference/difference/#difference.GeneDifference.__large_deletions","title":"<code>__large_deletions()</code>","text":"<p>Check to see what proportion of the gene has been deleted. Report separately     than other mutations if &gt;=50% deleted</p> <p>Updates internal arrays to denote a new mutation if deletion above threshold.</p> Source code in <code>gumpy/difference.py</code> <pre><code>def __large_deletions(self):\n    \"\"\"Check to see what proportion of the gene has been deleted. Report separately\n        than other mutations if &gt;=50% deleted\n\n    Updates internal arrays to denote a new mutation if deletion above threshold.\n    \"\"\"\n    # Find everywhere that we have different deletion within coding regions\n    mask = self.gene1.is_deleted != self.gene2.is_deleted\n\n    # Find out how much of the gene we have deleted\n    total = sum(self.gene1.is_deleted[mask]) + sum(self.gene2.is_deleted[mask])\n\n    if total &gt; 0:\n        # We have some deletions\n        percentage = total / len(self.gene1.nucleotide_sequence)\n        if percentage &gt;= 0.5:\n            # More than 50% deleted, so give a percentage\n            self.mutations = numpy.append(\n                self.mutations, [f\"del_{round(percentage, 2)}\"]\n            )\n            # Pull out the start of the deletion for vcf evidence\n            self.nucleotide_index = numpy.append(\n                self.nucleotide_index, [self.gene2.nucleotide_index[mask][0]]\n            )\n\n            self.amino_acid_number = numpy.append(self.amino_acid_number, [None])\n\n            # Get the nucleotide number of the first base of the gene\n            # Not predictable as promoters are variable length\n            self.nucleotide_number = numpy.append(\n                self.nucleotide_number,\n                [\n                    self.gene2.nucleotide_number[\n                        self.gene1.is_deleted | self.gene2.is_deleted\n                    ][0]\n                ],\n            )\n\n            self.gene_position = numpy.append(self.gene_position, [None])\n            self.is_cds = numpy.append(self.is_cds, [True])\n            self.is_promoter = numpy.append(self.is_promoter, [False])\n            self.is_indel = numpy.append(self.is_indel, [True])\n            self.indel_length = numpy.append(self.indel_length, [-1 * total])\n            self.indel_nucleotides = numpy.append(\n                self.indel_nucleotides,\n                [\"\".join(self.gene1.nucleotide_sequence[mask])],\n            )\n            self.ref_nucleotides = numpy.append(self.ref_nucleotides, [None])\n            self.alt_nucleotides = numpy.append(self.alt_nucleotides, [None])\n            self.is_snp = numpy.append(self.is_snp, [False])\n            self.is_het = numpy.append(self.is_het, [False])\n            self.is_null = numpy.append(self.is_null, [False])\n        else:\n            # Check for a deletion at the start of the gene which is the result of\n            #   an upstream del\n            if self.gene1.reverse_complement:\n                # This is difficult as revcomp shifts dels upstream by the length\n                #   of the del\n                # So we have to find a del in the RHS of the gene which would be\n                #   the last item if not shifted\n                pos = -1\n                while pos * -1 &lt; len(self.gene1.nucleotide_sequence) / 2:\n                    if (\n                        self.gene1.indel_length[pos] &lt; 0\n                        and not self.gene1.is_indel[pos]\n                    ):\n                        # Del here in gene1 so check for validity\n                        if (\n                            self.gene1.nucleotide_index[pos]\n                            + self.gene1.indel_length[pos]\n                            + 1\n                            == self.gene1.nucleotide_index[-1]\n                        ):\n                            # Re-adusting for deletion, this matches\n                            break\n                    if (\n                        self.gene2.indel_length[pos] &lt; 0\n                        and not self.gene2.is_indel[pos]\n                    ):\n                        # Del here in gene2 so check for validity\n                        if (\n                            self.gene2.nucleotide_index[pos]\n                            + self.gene2.indel_length[pos]\n                            + 1\n                            == self.gene2.nucleotide_index[-1]\n                        ):\n                            # Re-adusting for deletion, this matches\n                            break\n                    pos -= 1\n            else:\n                # If not revcomp, the del is the first item\n                pos = 0\n\n            if (\n                self.gene1.indel_length[pos] &lt; 0 and not self.gene1.is_indel[pos]\n            ) and (\n                self.gene2.indel_length[pos] &lt; 0 and not self.gene2.is_indel[pos]\n            ):\n                # Both have a del, so no difference\n                return\n\n            if self.gene1.indel_length[pos] &lt; 0 and not self.gene1.is_indel[pos]:\n                deleted = self.gene1.indel_nucleotides[pos]\n            elif self.gene2.indel_length[pos] &lt; 0 and not self.gene2.is_indel[pos]:\n                deleted = self.gene2.indel_nucleotides[pos]\n            else:\n                # Neither, so no difference either\n                return\n\n            # Adjust idx to point to the  right VCF evidence\n            if self.gene1.reverse_complement:\n                idx = self.gene1.nucleotide_index[pos + len(deleted) - 1]\n            else:\n                idx = self.gene1.nucleotide_index[pos]\n\n            pos = self.gene1.nucleotide_number[pos]\n\n            self.mutations = numpy.append(self.mutations, [f\"{pos}_del_{deleted}\"])\n            # Pull out the start of the deletion for vcf evidence\n            self.nucleotide_index = numpy.append(self.nucleotide_index, [idx])\n            self.amino_acid_number = numpy.append(self.amino_acid_number, [None])\n\n            # Get the nucleotide number of the first base of the gene\n            # Not predictable as promoters are variable length\n            self.nucleotide_number = numpy.append(\n                self.nucleotide_number,\n                [\n                    self.gene2.nucleotide_number[\n                        self.gene1.is_deleted | self.gene2.is_deleted\n                    ][0]\n                ],\n            )\n\n            self.gene_position = numpy.append(self.gene_position, [pos])\n            self.is_cds = numpy.append(self.is_cds, [True])\n            self.is_promoter = numpy.append(self.is_promoter, [False])\n            self.is_indel = numpy.append(self.is_indel, [True])\n            self.indel_length = numpy.append(self.indel_length, [len(deleted)])\n            self.indel_nucleotides = numpy.append(self.indel_nucleotides, [deleted])\n            self.ref_nucleotides = numpy.append(self.ref_nucleotides, [None])\n            self.alt_nucleotides = numpy.append(self.alt_nucleotides, [None])\n            self.is_snp = numpy.append(self.is_snp, [False])\n            self.is_het = numpy.append(self.is_het, [False])\n            self.is_null = numpy.append(self.is_null, [False])\n</code></pre>"},{"location":"reference/difference/#difference.GeneDifference.__nucleotides","title":"<code>__nucleotides()</code>","text":"<p>Find the differences in nucleotides</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Array of tuples (gene1_nucleotide, gene2_nucleotide)</p> Source code in <code>gumpy/difference.py</code> <pre><code>def __nucleotides(self) -&gt; numpy.ndarray:\n    \"\"\"Find the differences in nucleotides\n\n    Returns:\n        numpy.ndarray: Array of tuples (gene1_nucleotide, gene2_nucleotide)\n    \"\"\"\n    return numpy.array(\n        [\n            (n1, n2)\n            for (n1, n2) in zip(\n                self.gene1.nucleotide_sequence, self.gene2.nucleotide_sequence\n            )\n            if n1 != n2\n        ]\n    )\n</code></pre>"},{"location":"reference/difference/#difference.GeneDifference.minor_populations","title":"<code>minor_populations(interpretation='reads')</code>","text":"<p>Get the minor population mutations in GARC</p> <p>Parameters:</p> Name Type Description Default <code>interpretation</code> <code>str</code> <p>How to report minor population. 'reads' reports number of reads. 'percentage' reports fractional read support. Defaults to 'reads'.</p> <code>'reads'</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>[str]: List of mutations in GARC</p> Source code in <code>gumpy/difference.py</code> <pre><code>def minor_populations(self, interpretation: str = \"reads\") -&gt; List[str]:\n    \"\"\"Get the minor population mutations in GARC\n\n    Args:\n        interpretation (str, optional): How to report minor population. 'reads'\n            reports number of reads. 'percentage' reports fractional read support.\n            Defaults to 'reads'.\n\n    Returns:\n        [str]: List of mutations in GARC\n    \"\"\"\n    return self.gene2.minority_populations_GARC(\n        interpretation=interpretation, reference=self.gene1\n    )\n</code></pre>"},{"location":"reference/difference/#difference.GenomeDifference","title":"<code>GenomeDifference</code>","text":"<p>               Bases: <code>Difference</code></p> <p>GenomeDifference object captures the difference between two genomes. Other than <code>snp_distance</code>, all public instance variables should be arrays which align so <code>x[N] &lt;--&gt; y[N]</code></p> <ul> <li> <p>The difference can be viewed in one of two ways:</p> <ul> <li><code>diff</code>: Arrays of the values from genome1 where there are different values     in genome2, or values which exist in genome1 but not genome2 depending on     which is more appropriate (closer to classical subtraction).     This is the default view.</li> <li><code>full</code>: Arrays of tuples consisting of (genome1_val, genome2_val) -     more information but less like classical subtraction     and more difficult to wrangle meaningful information from.</li> <li>This option can be set by using the update_view() method</li> </ul> </li> <li> <p>Instance variables:</p> <ul> <li>snp_distance (int): SNP distance between the two genomes</li> <li>variants (numpy.array): Variants in GARC</li> <li>nucleotide_index (numpy.array): Genome index (1 based) of this variant</li> <li>indel_length (numpy.array): Length of the indel of this variant (None is     not an indel)</li> <li>indel_nucleotides (numpy.array): Nucleotides of this indel of this variant     (None if not an indel)</li> <li>vcf_evidence (numpy.array): VCF evidence to support this call</li> <li>gene_name (numpy.array): Name of the gene this variant affects     (None if intergene)</li> <li>gene_position (numpy.array): Position of this variant within this gene.     This refers to codon number if applicable (None if intergene)</li> <li>codon_idx (numpy.array): 0-based index of the nucleotide within the codon     this affects if applicable. None otherwise</li> </ul> </li> <li>Functions:<ul> <li>variants(int) -&gt; dict: Takes a genome index and returns a dictionary mapping     field-&gt;(genome1_val, genome2_val) for all fields of a vcf file     (if applicable)</li> <li>gene_differences() -&gt; [GeneDifference]: Returns a list of GeneDifference     objects</li> <li>minor_populations() -&gt; [str]: Returns a list of minor population mutations     in GARC</li> </ul> </li> <li>Inherited functions:<ul> <li>update_view(str) -&gt; None: Used to change the viewing method for instance     variables. Input values are either <code>diff</code> or <code>full</code></li> </ul> </li> </ul> Source code in <code>gumpy/difference.py</code> <pre><code>class GenomeDifference(Difference):\n    \"\"\"\n    GenomeDifference object captures the difference between two genomes. Other than\n    `snp_distance`, all public instance variables should be arrays\n    which align so `x[N] &lt;--&gt; y[N]`\n\n    * The difference can be viewed in one of two ways:\n        * `diff`: Arrays of the values from genome1 where there are different values\n            in genome2, or values which exist in genome1 but not genome2 depending on\n            which is more appropriate (closer to classical subtraction).\n            This is the default view.\n        * `full`: Arrays of tuples consisting of (genome1_val, genome2_val) -\n            more information but less like classical subtraction\n            and more difficult to wrangle meaningful information from.\n        * This option can be set by using the update_view() method\n\n    * Instance variables:\n        * snp_distance (int): SNP distance between the two genomes\n        * variants (numpy.array): Variants in GARC\n        * nucleotide_index (numpy.array): Genome index (1 based) of this variant\n        * indel_length (numpy.array): Length of the indel of this variant (None is\n            not an indel)\n        * indel_nucleotides (numpy.array): Nucleotides of this indel of this variant\n            (None if not an indel)\n        * vcf_evidence (numpy.array): VCF evidence to support this call\n        * gene_name (numpy.array): Name of the gene this variant affects\n            (None if intergene)\n        * gene_position (numpy.array): Position of this variant within this gene.\n            This refers to codon number if applicable (None if intergene)\n        * codon_idx (numpy.array): 0-based index of the nucleotide within the codon\n            this affects if applicable. None otherwise\n    * Functions:\n        * variants(int) -&gt; dict: Takes a genome index and returns a dictionary mapping\n            field-&gt;(genome1_val, genome2_val) for all fields of a vcf file\n            (if applicable)\n        * gene_differences() -&gt; [GeneDifference]: Returns a list of GeneDifference\n            objects\n        * minor_populations() -&gt; [str]: Returns a list of minor population mutations\n            in GARC\n    * Inherited functions:\n        * update_view(str) -&gt; None: Used to change the viewing method for instance\n            variables. Input values are either `diff` or `full`\n    \"\"\"\n\n    def __init__(self, genome1, genome2):\n        \"\"\"\n        Constructor for the GenomeDifference object.\n\n        Called implictly when `genome1.difference(genome2)` is performed.\n        Args:\n            genome1 (gumpy.Genome): A Genome object to compare against\n            genome2 (gumpy.Genome): The other Genome object\n        \"\"\"\n\n        # insist that both must be Genome objects\n        assert isinstance(genome1, gumpy.Genome)\n        assert isinstance(genome2, gumpy.Genome)\n\n        # Checking for the same genes, give an error if the genes are different\n        if genome1.genes.keys() != genome2.genes.keys():\n            genes_in_1_not_2 = set(genome1.genes.keys()).difference(\n                genome2.genes.keys()\n            )\n            genes_in_2_not_1 = set(genome2.genes.keys()).difference(\n                genome1.genes.keys()\n            )\n            message = \"The two genomes have different genes.\"\n            if len(genes_in_1_not_2) &gt; 0:\n                message += (\n                    f\" Genome 1 has {len(genes_in_1_not_2)} more \"\n                    f\"genes: {genes_in_1_not_2}.\"\n                )\n            if len(genes_in_2_not_1) &gt; 0:\n                message += (\n                    f\" Genome2 has {len(genes_in_2_not_1)} more \"\n                    f\"genes: {genes_in_2_not_1}.\"\n                )\n            raise FailedComparison(message)\n\n        self.genome1 = genome1\n        self.genome2 = genome2\n        self._view_method = \"diff\"\n\n        # Calculate SNPs\n        self.snp_distance = self.__snp_distance()\n        \"\"\"\n        Where applicable, the `full` difference arrays are stored as these can be \n        easily converted into `diff` arrays but not the other way around.\n        \"\"\"\n\n        self.__get_variants()\n\n        # Calculate differences\n        self._nucleotides_full = self.__nucleotides()\n\n        self.__assign_vcf_evidence()\n\n        self.update_view(self._view_method)\n\n    def get_gene_pos(\n        self, gene: str, idx: int, variant: str, start: int | None = None\n    ) -&gt; int | None:\n        \"\"\"Find the gene position of a given nucleotide index.\n        This is considerably faster than building a whole stacked_gene_pos array\n            (takes ~4.5mins for tb)\n\n        Args:\n            gene (str): Name of the gene to search\n            idx (int): Nucleotide index we want the gene position of\n            variant (str): Variant we're looking for in GARC\n            start (int): Start position. Defaults to None\n\n        Returns:\n            int | None: Gene position of this nucleotide index\n                        (or None if it lies outside of the gene)\n        \"\"\"\n        stacked_gene_mask = self.genome1.stacked_gene_name == gene\n        nc_idx = self.genome1.stacked_nucleotide_index[stacked_gene_mask]\n        nc_nums = self.genome1.stacked_nucleotide_number[stacked_gene_mask]\n\n        # Get the gene's nucleotide number\n        nc_num = nc_nums[nc_idx == idx][0]\n\n        # If coding SNP, pull out the codon number instead\n        if (\n            self.genome2.genes[gene][\"codes_protein\"]\n            and nc_num &gt; 0\n            and \"ins\" not in variant\n            and \"del\" not in variant\n        ):\n            # Use floor division (//)\n            codon_number = (nc_num + 2) // 3\n            return codon_number\n        elif \"ins\" in variant:\n            # Insertions need a little nudge in revcomp because of `ins at, del after`\n            if self.genome2.genes[gene][\"reverse_complement\"]:\n                nc_num -= 1\n        elif \"del\" in variant:\n            pos, t, bases = variant.split(\"_\")\n            if start is not None and idx != start:\n                # This is not the start of the deletion, so truncate the bases as\n                #   appropriate\n                dels = len(bases) - (idx - start)\n            else:\n                dels = len(bases)\n            # Deletions need even more nudging in revcomp because the entire deletion\n            #   is reversed so starts at the end\n            if self.genome2.genes[gene][\"reverse_complement\"]:\n                nc_num = nc_num - dels + 1\n\n                # Edge case of deletion starting in revcomp gene and extending\n                # past gene start, so return None\n                if (\n                    self.genome2.stacked_nucleotide_number[\n                        self.genome2.stacked_gene_name == gene\n                    ][-1]\n                    &gt; nc_num\n                ):\n                    return None\n\n        return nc_num\n\n    def _get_vcf_idx(self, vcf_row: Dict) -&gt; int | None:\n        \"\"\"Given a vcf row, figure out which alt it refers to. Should be available in\n            the GT field\n\n        Args:\n            vcf_row (dict): Internal representation of the VCF row for this variant\n\n        Returns:\n            int | None: 0-based index of the alts this refers to\n        \"\"\"\n        # Use `GT` field to figure out which one this call is\n        # (This will be **much** messier for minor populations)\n        gt = vcf_row[\"GT\"]\n        if gt[0] == gt[1]:\n            # Actual call so return the 1-based idx\n            return gt[0]\n        else:\n            # Het call so return None as it involves &gt;1\n            return None\n\n    def __assign_vcf_evidence(self) -&gt; None:\n        \"\"\"Once we have pulled out all of the variants, find the VCF evidence\n        (if existing) for each.\n        \"\"\"\n        evidences: List = []\n        indices: List = []\n        for i, idx in enumerate(self.nucleotide_index):\n            evidence1 = self.genome1.vcf_evidence.get(idx)\n            evidence2 = self.genome2.vcf_evidence.get(idx)\n\n            # As we add the vcf evidence for every deleted base\n            # This should only be reported for the actual start\n            if (\n                self.genome1.is_deleted[idx - 1]\n                and self.genome1.indel_length[idx - 1] &gt;= 0\n            ):\n                evidence1 = None\n            if (\n                self.genome2.is_deleted[idx - 1]\n                and self.genome2.indel_length[idx - 1] &gt;= 0\n            ):\n                evidence2 = None\n\n            if evidence1 is not None and evidence2 is not None:\n                # We have a collision. For now, just concat FIXME\n                evidences.append([evidence1, evidence2])\n                indices.append(\n                    [self._get_vcf_idx(evidence1), self._get_vcf_idx(evidence2)]\n                )\n            elif evidence1 is not None:\n                evidences.append(evidence1)\n                indices.append(self._get_vcf_idx(evidence1))\n            elif evidence2 is not None:\n                evidences.append(evidence2)\n                indices.append(self._get_vcf_idx(evidence2))\n            else:\n                evidences.append(None)\n                indices.append(None)\n\n        self.vcf_evidences = evidences\n        self.vcf_idx = indices\n\n    def minor_populations(self, interpretation: str = \"reads\") -&gt; List[str]:\n        \"\"\"Get the minor population mutations in GARC\n\n        Args:\n            interpretation (str, optional): How to report minor population.\n                'reads' reports number of reads. 'percentage' reports fractional\n                read support. Defaults to 'reads'.\n\n        Returns:\n            List[str]: List of mutations in GARC\n        \"\"\"\n        return self.genome2.minority_populations_GARC(\n            interpretation=interpretation, reference=self.genome1\n        )\n\n    def __snp_distance(self) -&gt; int:\n        \"\"\"Calculates the SNP distance between the two genomes\n\n        Returns:\n            int: The SNP distance between the two genomes\n        \"\"\"\n        # Ignores `z` and `x`\n        return sum(\n            [\n                1\n                for (base1, base2) in zip(\n                    self.genome1.nucleotide_sequence, self.genome2.nucleotide_sequence\n                )\n                if base1 != base2\n                and base1 in [\"a\", \"t\", \"c\", \"g\"]\n                and base2 in [\"a\", \"t\", \"c\", \"g\"]\n            ]\n        )\n\n    def __get_variants(self):\n        \"\"\"Get the variants between the two genomes, populating the internal arrays\"\"\"\n\n        variants = []\n        indices = []\n        is_snp = []\n        is_het = []\n        is_null = []\n        is_indel = []\n        indel_length = []\n        indel_nucleotides = []\n        refs = []\n        alts = []\n        gene_name = []\n        gene_pos = []\n        codon_idx = []\n\n        # first do the SNPs, HETs and NULLs\n        mask = self.genome1.nucleotide_sequence != self.genome2.nucleotide_sequence\n\n        # for now we simply allow the ref and alt to be different e.g. can have a\n        #   SNP on a NULL (x&gt;t)\n        for r, idx, a in tqdm(\n            zip(\n                self.genome1.nucleotide_sequence[mask],\n                self.genome1.nucleotide_index[mask],\n                self.genome2.nucleotide_sequence[mask],\n            ),\n            total=len(self.genome1.nucleotide_sequence[mask]),\n        ):\n            variants.append(str(idx) + r + \"&gt;\" + a)\n            refs.append(r)\n            alts.append(a)\n            indices.append(idx)\n            is_indel.append(False)\n            indel_length.append(0)\n            indel_nucleotides.append(None)\n            if a == \"z\":\n                is_het.append(True)\n                is_snp.append(False)\n                is_null.append(False)\n            elif a == \"x\":\n                is_het.append(False)\n                is_snp.append(False)\n                is_null.append(True)\n            elif a in [\"a\", \"t\", \"c\", \"g\"]:\n                is_het.append(False)\n                is_snp.append(True)\n                is_null.append(False)\n\n            # Find the genes at this pos\n            genes = sorted(\n                list(\n                    set(\n                        self.genome1.stacked_gene_name[\n                            self.genome1.stacked_nucleotide_index == idx\n                        ]\n                    )\n                )\n            )\n            if len(genes) &gt; 1:\n                # If we have genes, we need to duplicate some info\n                first = True\n                for gene in genes:\n                    if gene == \"\":\n                        # If we have genes, we don't care about this one\n                        continue\n                    gene_name.append(gene)\n                    gene_pos.append(self.get_gene_pos(gene, idx, variants[-1]))\n                    if (\n                        self.genome2.genes[gene][\"codes_protein\"]\n                        and gene_pos[-1] is not None\n                        and gene_pos[-1] &gt; 0\n                    ):\n                        # Get codon idx\n                        nc_idx = self.genome1.stacked_nucleotide_index[\n                            self.genome1.stacked_gene_name == gene\n                        ]\n                        nc_num = self.genome1.stacked_nucleotide_number[\n                            self.genome1.stacked_gene_name == gene\n                        ]\n                        codon_idx.append((nc_num[nc_idx == idx][0] - 1) % 3)\n                    else:\n                        codon_idx.append(None)\n\n                    # If this isn't the first one, we need to duplicate the row\n                    if first:\n                        first = False\n                    else:\n                        variants.append(variants[-1])\n                        refs.append(refs[-1])\n                        alts.append(alts[-1])\n                        indices.append(indices[-1])\n                        is_indel.append(is_indel[-1])\n                        indel_length.append(indel_length[-1])\n                        indel_nucleotides.append(indel_nucleotides[-1])\n                        is_het.append(is_het[-1])\n                        is_snp.append(is_snp[-1])\n                        is_null.append(is_null[-1])\n\n            else:\n                # We have 1 gene or none, so set to None if no gene is present\n                gene = genes[0] if genes[0] != \"\" else None\n                gene_name.append(gene)\n                if gene is not None:\n                    # Single gene, so pull out data\n                    gene_pos.append(self.get_gene_pos(gene, idx, variants[-1]))\n\n                    if (\n                        self.genome2.genes[gene][\"codes_protein\"]\n                        and gene_pos[-1] is not None\n                        and gene_pos[-1] &gt; 0\n                    ):\n                        # Get codon idx\n                        nc_idx = self.genome1.stacked_nucleotide_index[\n                            self.genome1.stacked_gene_name == gene\n                        ]\n                        nc_num = self.genome1.stacked_nucleotide_number[\n                            self.genome1.stacked_gene_name == gene\n                        ]\n                        codon_idx.append((nc_num[nc_idx == idx][0] - 1) % 3)\n                    else:\n                        codon_idx.append(None)\n                else:\n                    gene_pos.append(None)\n                    codon_idx.append(None)\n\n        # INDELs are trickier: we have to deal with the case where both genomes have\n        #   an indel at the same position\n        # if they are different we catch fire since that is too difficult to parse\n        #   right now\n        # if they are the same, then there is no difference\n        # the other cases are the usual one of there being an indel on the RHS and then\n        #   an indel on the LHS (but not the RHS)\n        # for the latter we 'reverse' the indel e.g. 1000_ins_at - None becomes 1000_del\n        #   at\n        # subtraction becomes \"how do we go from the LHS to the RHS in a-b?\"\n\n        # for indels catch fire if both genomes have different indels at the same\n        #   position\n        assert (\n            numpy.sum(\n                self.genome1.is_indel\n                &amp; self.genome2.is_indel\n                &amp; (self.genome1.indel_nucleotides != self.genome2.indel_nucleotides)\n            )\n            == 0\n        ), (\n            \"both genomes have indels of different lengths at one or more of the \"\n            \"same positions -- this cannot be easily resolved!\"\n        )\n\n        # the other case is where there is an identical indel at a position but\n        #   this leads to a difference of zero!\n\n        # if the indel is on the RHS, then it is unchanged\n        mask = self.genome2.is_indel &amp; (\n            self.genome1.indel_nucleotides != self.genome2.indel_nucleotides\n        )\n\n        for idx, length, alt, r, a in zip(\n            self.genome1.nucleotide_index[mask],\n            self.genome2.indel_length[mask],\n            self.genome2.indel_nucleotides[mask],\n            self.genome1.nucleotide_sequence,\n            self.genome2.nucleotide_sequence,\n        ):\n            indices.append(idx)\n            is_indel.append(True)\n            is_het.append(False)\n            is_snp.append(False)\n            is_null.append(False)\n            refs.append(None)\n            alts.append(None)\n            indel_length.append(length)\n            indel_nucleotides.append(alt)\n            if length &gt; 0:\n                variants.append(str(idx) + \"_ins_\" + str(alt))\n            else:\n                variants.append(str(idx) + \"_del_\" + str(alt))\n\n            # Find the genes at this pos\n            positions = []\n            seen_genes = set()\n            if \"ins\" in variants[-1]:\n                # Insertion, so only need to check a single index\n                positions.append(idx)\n                start = None\n            else:\n                # Deletion, so we need to check every deleted position for genes\n                pos, _, bases = variants[-1].split(\"_\")\n                start = idx\n                for i in range(len(bases)):\n                    positions.append(idx + i)\n            first = True\n            for pos in positions:\n                genes = sorted(\n                    list(\n                        set(\n                            self.genome1.stacked_gene_name[\n                                self.genome1.stacked_nucleotide_index == pos\n                            ]\n                        )\n                    )\n                )\n                adding = False\n                if len(genes) &gt; 1:\n                    multi = True\n                    # If we have genes, we need to duplicate some info\n                    for gene in genes:\n                        if gene == \"\":\n                            # If we have genes, we don't care about this one\n                            continue\n\n                        if gene in seen_genes:\n                            # If we've already seen it, skip\n                            continue\n                        else:\n                            # Mark as seen now we have seen it\n                            seen_genes.add(gene)\n                            adding = True\n                        gene_name.append(gene)\n                        gene_pos.append(\n                            self.get_gene_pos(gene, pos, variants[-1], start=start)\n                        )\n                        if (\n                            self.genome2.genes[gene][\"codes_protein\"]\n                            and gene_pos[-1] is not None\n                            and gene_pos[-1] &gt; 0\n                        ):\n                            # Get codon pos\n                            nc_idx = self.genome1.stacked_nucleotide_index[\n                                self.genome1.stacked_gene_name == gene\n                            ]\n                            nc_num = self.genome1.stacked_nucleotide_number[\n                                self.genome1.stacked_gene_name == gene\n                            ]\n                            codon_idx.append((nc_num[nc_idx == pos][0] - 1) % 3)\n                        else:\n                            codon_idx.append(None)\n\n                        # If this isn't the first one, we need to duplicate the row\n                        if first:\n                            first = False\n                        else:\n                            variants.append(variants[-1])\n                            refs.append(refs[-1])\n                            alts.append(alt[-1])\n                            indices.append(indices[-1])\n                            is_indel.append(is_indel[-1])\n                            indel_length.append(indel_length[-1])\n                            indel_nucleotides.append(indel_nucleotides[-1])\n                            is_het.append(is_het[-1])\n                            is_snp.append(is_snp[-1])\n                            is_null.append(is_null[-1])\n                else:\n                    # We have 1 gene or none, so set to None if no gene is present\n                    gene = genes[0] if genes[0] != \"\" else None\n                    if gene in seen_genes:\n                        # If we've already seen it, or it's intragene so skip\n                        continue\n                    else:\n                        # Mark as seen now we have seen it\n                        seen_genes.add(gene)\n                        adding = True\n                    if gene is not None:\n                        # Single gene, so pull out data\n                        gene_name.append(gene)\n                        gene_pos.append(\n                            self.get_gene_pos(gene, pos, variants[-1], start=start)\n                        )\n\n                        if (\n                            self.genome2.genes[gene][\"codes_protein\"]\n                            and gene_pos[-1] is not None\n                            and gene_pos[-1] &gt; 0\n                        ):\n                            # Get codon pos\n                            nc_idx = self.genome1.stacked_nucleotide_index[\n                                self.genome1.stacked_gene_name == gene\n                            ]\n                            nc_num = self.genome1.stacked_nucleotide_number[\n                                self.genome1.stacked_gene_name == gene\n                            ]\n                            codon_idx.append((nc_num[nc_idx == pos][0] - 1) % 3)\n                        else:\n                            codon_idx.append(None)\n                    else:\n                        # We don't care about intragene values if its not the first item\n                        if pos != idx:\n                            continue\n                        gene_name.append(None)\n                        gene_pos.append(None)\n                        codon_idx.append(None)\n                # If this isn't the first one, we need to duplicate the row\n                if first:\n                    first = False\n                elif adding and not multi:\n                    variants.append(variants[-1])\n                    refs.append(refs[-1])\n                    alts.append(alt[-1])\n                    indices.append(indices[-1])\n                    is_indel.append(is_indel[-1])\n                    indel_length.append(indel_length[-1])\n                    indel_nucleotides.append(indel_nucleotides[-1])\n                    is_het.append(is_het[-1])\n                    is_snp.append(is_snp[-1])\n                    is_null.append(is_null[-1])\n\n        # if the indel is on the LHS, then it is unchanged, then it needs 'reversing'\n        #   since we are returning how to get to the RHS from the LHS hence we\n        #   delete an insertion etc\n        mask = self.genome1.is_indel &amp; (\n            self.genome1.indel_nucleotides != self.genome2.indel_nucleotides\n        )\n\n        for idx, length, alt, r, a in zip(\n            self.genome1.nucleotide_index[mask],\n            self.genome1.indel_length[mask],\n            self.genome1.indel_nucleotides[mask],\n            self.genome1.nucleotide_sequence,\n            self.genome2.nucleotide_sequence,\n        ):\n            indices.append(idx)\n            is_indel.append(True)\n            is_het.append(False)\n            is_snp.append(False)\n            is_null.append(False)\n            refs.append(None)\n            alts.append(None)\n            length *= -1\n            indel_length.append(length)\n            indel_nucleotides.append(alt)\n            if length &gt; 0:\n                variants.append(str(idx) + \"_ins_\" + str(alt))\n            else:\n                variants.append(str(idx) + \"_del_\" + str(alt))\n\n            # Find the genes at this pos\n            positions = []\n            seen_genes = set()\n            if \"ins\" in variants[-1]:\n                # Insertion, so only need to check a single index\n                positions.append(idx)\n                start = None\n            else:\n                # Deletion, so we need to check every deleted position for genes\n                pos, _, bases = variants[-1].split(\"_\")\n                start = idx\n                for i in range(len(bases)):\n                    positions.append(idx + i)\n            first = True\n            for pos in positions:\n                genes = sorted(\n                    list(\n                        set(\n                            self.genome1.stacked_gene_name[\n                                self.genome1.stacked_nucleotide_index == pos\n                            ]\n                        )\n                    )\n                )\n                adding = False\n                multi = False\n                if len(genes) &gt; 1:\n                    multi = True\n                    # If we have genes, we need to duplicate some info\n                    for gene in genes:\n                        if gene == \"\":\n                            # If we have genes, we don't care about this one\n                            continue\n\n                        if gene in seen_genes:\n                            # If we've already seen it, skip\n                            continue\n                        else:\n                            # Mark as seen now we have seen it\n                            seen_genes.add(gene)\n                            adding = True\n\n                        gene_name.append(gene)\n                        gene_pos.append(\n                            self.get_gene_pos(gene, pos, variants[-1], start=start)\n                        )\n                        if (\n                            self.genome2.genes[gene][\"codes_protein\"]\n                            and gene_pos[-1] is not None\n                            and gene_pos[-1] &gt; 0\n                        ):\n                            # Get codon pos\n                            nc_idx = self.genome1.stacked_nucleotide_index[\n                                self.genome1.stacked_gene_name == gene\n                            ]\n                            nc_num = self.genome1.stacked_nucleotide_number[\n                                self.genome1.stacked_gene_name == gene\n                            ]\n                            codon_idx.append((nc_num[nc_idx == pos][0] - 1) % 3)\n                        else:\n                            codon_idx.append(None)\n                        # If this isn't the first one, we need to duplicate the row\n                        if first:\n                            first = False\n                        else:\n                            variants.append(variants[-1])\n                            refs.append(refs[-1])\n                            alts.append(alt[-1])\n                            indices.append(indices[-1])\n                            is_indel.append(is_indel[-1])\n                            indel_length.append(indel_length[-1])\n                            indel_nucleotides.append(indel_nucleotides[-1])\n                            is_het.append(is_het[-1])\n                            is_snp.append(is_snp[-1])\n                            is_null.append(is_null[-1])\n\n                else:\n                    # We have 1 gene or none, so set to None if no gene is present\n                    gene = genes[0] if genes[0] != \"\" else None\n                    if gene in seen_genes:\n                        # If we've already seen it, or it's intragene so skip\n                        continue\n                    else:\n                        # Mark as seen now we have seen it\n                        seen_genes.add(gene)\n                        adding = True\n                    if gene is not None:\n                        # Single gene, so pull out data\n                        gene_name.append(gene)\n                        gene_pos.append(\n                            self.get_gene_pos(gene, pos, variants[-1], start=start)\n                        )\n\n                        if (\n                            self.genome2.genes[gene][\"codes_protein\"]\n                            and gene_pos[-1] is not None\n                            and gene_pos[-1] &gt; 0\n                        ):\n                            # Get codon pos\n                            nc_idx = self.genome1.stacked_nucleotide_index[\n                                self.genome1.stacked_gene_name == gene\n                            ]\n                            nc_num = self.genome1.stacked_nucleotide_number[\n                                self.genome1.stacked_gene_name == gene\n                            ]\n                            codon_idx.append((nc_num[nc_idx == pos][0] - 1) % 3)\n                        else:\n                            codon_idx.append(None)\n                    else:\n                        # We don't care about intragene values if its not the first item\n                        if pos != idx:\n                            continue\n                        gene_name.append(None)\n                        gene_pos.append(None)\n                        codon_idx.append(None)\n\n                # If this isn't the first one, we need to duplicate the row\n                if first:\n                    first = False\n                elif adding and not multi:\n                    variants.append(variants[-1])\n                    refs.append(refs[-1])\n                    alts.append(alt[-1])\n                    indices.append(indices[-1])\n                    is_indel.append(is_indel[-1])\n                    indel_length.append(indel_length[-1])\n                    indel_nucleotides.append(indel_nucleotides[-1])\n                    is_het.append(is_het[-1])\n                    is_snp.append(is_snp[-1])\n                    is_null.append(is_null[-1])\n\n        self.variants = numpy.array(variants)\n        self.nucleotide_index = numpy.array(indices)\n        self.is_indel = numpy.array(is_indel)\n        self.indel_length = numpy.array(indel_length)\n        self.indel_nucleotides = numpy.array(indel_nucleotides)\n        self.is_snp = numpy.array(is_snp)\n        self.is_het = numpy.array(is_het)\n        self.is_null = numpy.array(is_null)\n        self.gene_name = gene_name\n        self.gene_pos = gene_pos\n        self.codon_idx = codon_idx\n\n    def __nucleotides(self) -&gt; numpy.ndarray:\n        \"\"\"Calculate the difference in nucleotides\n        Returns:\n            numpy.ndarray: Numpy array of tuples of (genome1_nucleotide,\n                genome2_nucleotide)\n        \"\"\"\n        mask = self.genome1.nucleotide_sequence != self.genome2.nucleotide_sequence\n        return numpy.array(\n            list(\n                zip(\n                    self.genome1.nucleotide_sequence[mask],\n                    self.genome2.nucleotide_sequence[mask],\n                )\n            )\n        )\n</code></pre>"},{"location":"reference/difference/#difference.GenomeDifference.snp_distance","title":"<code>snp_distance = self.__snp_distance()</code>  <code>instance-attribute</code>","text":"<p>Where applicable, the <code>full</code> difference arrays are stored as these can be  easily converted into <code>diff</code> arrays but not the other way around.</p>"},{"location":"reference/difference/#difference.GenomeDifference.__assign_vcf_evidence","title":"<code>__assign_vcf_evidence()</code>","text":"<p>Once we have pulled out all of the variants, find the VCF evidence (if existing) for each.</p> Source code in <code>gumpy/difference.py</code> <pre><code>def __assign_vcf_evidence(self) -&gt; None:\n    \"\"\"Once we have pulled out all of the variants, find the VCF evidence\n    (if existing) for each.\n    \"\"\"\n    evidences: List = []\n    indices: List = []\n    for i, idx in enumerate(self.nucleotide_index):\n        evidence1 = self.genome1.vcf_evidence.get(idx)\n        evidence2 = self.genome2.vcf_evidence.get(idx)\n\n        # As we add the vcf evidence for every deleted base\n        # This should only be reported for the actual start\n        if (\n            self.genome1.is_deleted[idx - 1]\n            and self.genome1.indel_length[idx - 1] &gt;= 0\n        ):\n            evidence1 = None\n        if (\n            self.genome2.is_deleted[idx - 1]\n            and self.genome2.indel_length[idx - 1] &gt;= 0\n        ):\n            evidence2 = None\n\n        if evidence1 is not None and evidence2 is not None:\n            # We have a collision. For now, just concat FIXME\n            evidences.append([evidence1, evidence2])\n            indices.append(\n                [self._get_vcf_idx(evidence1), self._get_vcf_idx(evidence2)]\n            )\n        elif evidence1 is not None:\n            evidences.append(evidence1)\n            indices.append(self._get_vcf_idx(evidence1))\n        elif evidence2 is not None:\n            evidences.append(evidence2)\n            indices.append(self._get_vcf_idx(evidence2))\n        else:\n            evidences.append(None)\n            indices.append(None)\n\n    self.vcf_evidences = evidences\n    self.vcf_idx = indices\n</code></pre>"},{"location":"reference/difference/#difference.GenomeDifference.__get_variants","title":"<code>__get_variants()</code>","text":"<p>Get the variants between the two genomes, populating the internal arrays</p> Source code in <code>gumpy/difference.py</code> <pre><code>def __get_variants(self):\n    \"\"\"Get the variants between the two genomes, populating the internal arrays\"\"\"\n\n    variants = []\n    indices = []\n    is_snp = []\n    is_het = []\n    is_null = []\n    is_indel = []\n    indel_length = []\n    indel_nucleotides = []\n    refs = []\n    alts = []\n    gene_name = []\n    gene_pos = []\n    codon_idx = []\n\n    # first do the SNPs, HETs and NULLs\n    mask = self.genome1.nucleotide_sequence != self.genome2.nucleotide_sequence\n\n    # for now we simply allow the ref and alt to be different e.g. can have a\n    #   SNP on a NULL (x&gt;t)\n    for r, idx, a in tqdm(\n        zip(\n            self.genome1.nucleotide_sequence[mask],\n            self.genome1.nucleotide_index[mask],\n            self.genome2.nucleotide_sequence[mask],\n        ),\n        total=len(self.genome1.nucleotide_sequence[mask]),\n    ):\n        variants.append(str(idx) + r + \"&gt;\" + a)\n        refs.append(r)\n        alts.append(a)\n        indices.append(idx)\n        is_indel.append(False)\n        indel_length.append(0)\n        indel_nucleotides.append(None)\n        if a == \"z\":\n            is_het.append(True)\n            is_snp.append(False)\n            is_null.append(False)\n        elif a == \"x\":\n            is_het.append(False)\n            is_snp.append(False)\n            is_null.append(True)\n        elif a in [\"a\", \"t\", \"c\", \"g\"]:\n            is_het.append(False)\n            is_snp.append(True)\n            is_null.append(False)\n\n        # Find the genes at this pos\n        genes = sorted(\n            list(\n                set(\n                    self.genome1.stacked_gene_name[\n                        self.genome1.stacked_nucleotide_index == idx\n                    ]\n                )\n            )\n        )\n        if len(genes) &gt; 1:\n            # If we have genes, we need to duplicate some info\n            first = True\n            for gene in genes:\n                if gene == \"\":\n                    # If we have genes, we don't care about this one\n                    continue\n                gene_name.append(gene)\n                gene_pos.append(self.get_gene_pos(gene, idx, variants[-1]))\n                if (\n                    self.genome2.genes[gene][\"codes_protein\"]\n                    and gene_pos[-1] is not None\n                    and gene_pos[-1] &gt; 0\n                ):\n                    # Get codon idx\n                    nc_idx = self.genome1.stacked_nucleotide_index[\n                        self.genome1.stacked_gene_name == gene\n                    ]\n                    nc_num = self.genome1.stacked_nucleotide_number[\n                        self.genome1.stacked_gene_name == gene\n                    ]\n                    codon_idx.append((nc_num[nc_idx == idx][0] - 1) % 3)\n                else:\n                    codon_idx.append(None)\n\n                # If this isn't the first one, we need to duplicate the row\n                if first:\n                    first = False\n                else:\n                    variants.append(variants[-1])\n                    refs.append(refs[-1])\n                    alts.append(alts[-1])\n                    indices.append(indices[-1])\n                    is_indel.append(is_indel[-1])\n                    indel_length.append(indel_length[-1])\n                    indel_nucleotides.append(indel_nucleotides[-1])\n                    is_het.append(is_het[-1])\n                    is_snp.append(is_snp[-1])\n                    is_null.append(is_null[-1])\n\n        else:\n            # We have 1 gene or none, so set to None if no gene is present\n            gene = genes[0] if genes[0] != \"\" else None\n            gene_name.append(gene)\n            if gene is not None:\n                # Single gene, so pull out data\n                gene_pos.append(self.get_gene_pos(gene, idx, variants[-1]))\n\n                if (\n                    self.genome2.genes[gene][\"codes_protein\"]\n                    and gene_pos[-1] is not None\n                    and gene_pos[-1] &gt; 0\n                ):\n                    # Get codon idx\n                    nc_idx = self.genome1.stacked_nucleotide_index[\n                        self.genome1.stacked_gene_name == gene\n                    ]\n                    nc_num = self.genome1.stacked_nucleotide_number[\n                        self.genome1.stacked_gene_name == gene\n                    ]\n                    codon_idx.append((nc_num[nc_idx == idx][0] - 1) % 3)\n                else:\n                    codon_idx.append(None)\n            else:\n                gene_pos.append(None)\n                codon_idx.append(None)\n\n    # INDELs are trickier: we have to deal with the case where both genomes have\n    #   an indel at the same position\n    # if they are different we catch fire since that is too difficult to parse\n    #   right now\n    # if they are the same, then there is no difference\n    # the other cases are the usual one of there being an indel on the RHS and then\n    #   an indel on the LHS (but not the RHS)\n    # for the latter we 'reverse' the indel e.g. 1000_ins_at - None becomes 1000_del\n    #   at\n    # subtraction becomes \"how do we go from the LHS to the RHS in a-b?\"\n\n    # for indels catch fire if both genomes have different indels at the same\n    #   position\n    assert (\n        numpy.sum(\n            self.genome1.is_indel\n            &amp; self.genome2.is_indel\n            &amp; (self.genome1.indel_nucleotides != self.genome2.indel_nucleotides)\n        )\n        == 0\n    ), (\n        \"both genomes have indels of different lengths at one or more of the \"\n        \"same positions -- this cannot be easily resolved!\"\n    )\n\n    # the other case is where there is an identical indel at a position but\n    #   this leads to a difference of zero!\n\n    # if the indel is on the RHS, then it is unchanged\n    mask = self.genome2.is_indel &amp; (\n        self.genome1.indel_nucleotides != self.genome2.indel_nucleotides\n    )\n\n    for idx, length, alt, r, a in zip(\n        self.genome1.nucleotide_index[mask],\n        self.genome2.indel_length[mask],\n        self.genome2.indel_nucleotides[mask],\n        self.genome1.nucleotide_sequence,\n        self.genome2.nucleotide_sequence,\n    ):\n        indices.append(idx)\n        is_indel.append(True)\n        is_het.append(False)\n        is_snp.append(False)\n        is_null.append(False)\n        refs.append(None)\n        alts.append(None)\n        indel_length.append(length)\n        indel_nucleotides.append(alt)\n        if length &gt; 0:\n            variants.append(str(idx) + \"_ins_\" + str(alt))\n        else:\n            variants.append(str(idx) + \"_del_\" + str(alt))\n\n        # Find the genes at this pos\n        positions = []\n        seen_genes = set()\n        if \"ins\" in variants[-1]:\n            # Insertion, so only need to check a single index\n            positions.append(idx)\n            start = None\n        else:\n            # Deletion, so we need to check every deleted position for genes\n            pos, _, bases = variants[-1].split(\"_\")\n            start = idx\n            for i in range(len(bases)):\n                positions.append(idx + i)\n        first = True\n        for pos in positions:\n            genes = sorted(\n                list(\n                    set(\n                        self.genome1.stacked_gene_name[\n                            self.genome1.stacked_nucleotide_index == pos\n                        ]\n                    )\n                )\n            )\n            adding = False\n            if len(genes) &gt; 1:\n                multi = True\n                # If we have genes, we need to duplicate some info\n                for gene in genes:\n                    if gene == \"\":\n                        # If we have genes, we don't care about this one\n                        continue\n\n                    if gene in seen_genes:\n                        # If we've already seen it, skip\n                        continue\n                    else:\n                        # Mark as seen now we have seen it\n                        seen_genes.add(gene)\n                        adding = True\n                    gene_name.append(gene)\n                    gene_pos.append(\n                        self.get_gene_pos(gene, pos, variants[-1], start=start)\n                    )\n                    if (\n                        self.genome2.genes[gene][\"codes_protein\"]\n                        and gene_pos[-1] is not None\n                        and gene_pos[-1] &gt; 0\n                    ):\n                        # Get codon pos\n                        nc_idx = self.genome1.stacked_nucleotide_index[\n                            self.genome1.stacked_gene_name == gene\n                        ]\n                        nc_num = self.genome1.stacked_nucleotide_number[\n                            self.genome1.stacked_gene_name == gene\n                        ]\n                        codon_idx.append((nc_num[nc_idx == pos][0] - 1) % 3)\n                    else:\n                        codon_idx.append(None)\n\n                    # If this isn't the first one, we need to duplicate the row\n                    if first:\n                        first = False\n                    else:\n                        variants.append(variants[-1])\n                        refs.append(refs[-1])\n                        alts.append(alt[-1])\n                        indices.append(indices[-1])\n                        is_indel.append(is_indel[-1])\n                        indel_length.append(indel_length[-1])\n                        indel_nucleotides.append(indel_nucleotides[-1])\n                        is_het.append(is_het[-1])\n                        is_snp.append(is_snp[-1])\n                        is_null.append(is_null[-1])\n            else:\n                # We have 1 gene or none, so set to None if no gene is present\n                gene = genes[0] if genes[0] != \"\" else None\n                if gene in seen_genes:\n                    # If we've already seen it, or it's intragene so skip\n                    continue\n                else:\n                    # Mark as seen now we have seen it\n                    seen_genes.add(gene)\n                    adding = True\n                if gene is not None:\n                    # Single gene, so pull out data\n                    gene_name.append(gene)\n                    gene_pos.append(\n                        self.get_gene_pos(gene, pos, variants[-1], start=start)\n                    )\n\n                    if (\n                        self.genome2.genes[gene][\"codes_protein\"]\n                        and gene_pos[-1] is not None\n                        and gene_pos[-1] &gt; 0\n                    ):\n                        # Get codon pos\n                        nc_idx = self.genome1.stacked_nucleotide_index[\n                            self.genome1.stacked_gene_name == gene\n                        ]\n                        nc_num = self.genome1.stacked_nucleotide_number[\n                            self.genome1.stacked_gene_name == gene\n                        ]\n                        codon_idx.append((nc_num[nc_idx == pos][0] - 1) % 3)\n                    else:\n                        codon_idx.append(None)\n                else:\n                    # We don't care about intragene values if its not the first item\n                    if pos != idx:\n                        continue\n                    gene_name.append(None)\n                    gene_pos.append(None)\n                    codon_idx.append(None)\n            # If this isn't the first one, we need to duplicate the row\n            if first:\n                first = False\n            elif adding and not multi:\n                variants.append(variants[-1])\n                refs.append(refs[-1])\n                alts.append(alt[-1])\n                indices.append(indices[-1])\n                is_indel.append(is_indel[-1])\n                indel_length.append(indel_length[-1])\n                indel_nucleotides.append(indel_nucleotides[-1])\n                is_het.append(is_het[-1])\n                is_snp.append(is_snp[-1])\n                is_null.append(is_null[-1])\n\n    # if the indel is on the LHS, then it is unchanged, then it needs 'reversing'\n    #   since we are returning how to get to the RHS from the LHS hence we\n    #   delete an insertion etc\n    mask = self.genome1.is_indel &amp; (\n        self.genome1.indel_nucleotides != self.genome2.indel_nucleotides\n    )\n\n    for idx, length, alt, r, a in zip(\n        self.genome1.nucleotide_index[mask],\n        self.genome1.indel_length[mask],\n        self.genome1.indel_nucleotides[mask],\n        self.genome1.nucleotide_sequence,\n        self.genome2.nucleotide_sequence,\n    ):\n        indices.append(idx)\n        is_indel.append(True)\n        is_het.append(False)\n        is_snp.append(False)\n        is_null.append(False)\n        refs.append(None)\n        alts.append(None)\n        length *= -1\n        indel_length.append(length)\n        indel_nucleotides.append(alt)\n        if length &gt; 0:\n            variants.append(str(idx) + \"_ins_\" + str(alt))\n        else:\n            variants.append(str(idx) + \"_del_\" + str(alt))\n\n        # Find the genes at this pos\n        positions = []\n        seen_genes = set()\n        if \"ins\" in variants[-1]:\n            # Insertion, so only need to check a single index\n            positions.append(idx)\n            start = None\n        else:\n            # Deletion, so we need to check every deleted position for genes\n            pos, _, bases = variants[-1].split(\"_\")\n            start = idx\n            for i in range(len(bases)):\n                positions.append(idx + i)\n        first = True\n        for pos in positions:\n            genes = sorted(\n                list(\n                    set(\n                        self.genome1.stacked_gene_name[\n                            self.genome1.stacked_nucleotide_index == pos\n                        ]\n                    )\n                )\n            )\n            adding = False\n            multi = False\n            if len(genes) &gt; 1:\n                multi = True\n                # If we have genes, we need to duplicate some info\n                for gene in genes:\n                    if gene == \"\":\n                        # If we have genes, we don't care about this one\n                        continue\n\n                    if gene in seen_genes:\n                        # If we've already seen it, skip\n                        continue\n                    else:\n                        # Mark as seen now we have seen it\n                        seen_genes.add(gene)\n                        adding = True\n\n                    gene_name.append(gene)\n                    gene_pos.append(\n                        self.get_gene_pos(gene, pos, variants[-1], start=start)\n                    )\n                    if (\n                        self.genome2.genes[gene][\"codes_protein\"]\n                        and gene_pos[-1] is not None\n                        and gene_pos[-1] &gt; 0\n                    ):\n                        # Get codon pos\n                        nc_idx = self.genome1.stacked_nucleotide_index[\n                            self.genome1.stacked_gene_name == gene\n                        ]\n                        nc_num = self.genome1.stacked_nucleotide_number[\n                            self.genome1.stacked_gene_name == gene\n                        ]\n                        codon_idx.append((nc_num[nc_idx == pos][0] - 1) % 3)\n                    else:\n                        codon_idx.append(None)\n                    # If this isn't the first one, we need to duplicate the row\n                    if first:\n                        first = False\n                    else:\n                        variants.append(variants[-1])\n                        refs.append(refs[-1])\n                        alts.append(alt[-1])\n                        indices.append(indices[-1])\n                        is_indel.append(is_indel[-1])\n                        indel_length.append(indel_length[-1])\n                        indel_nucleotides.append(indel_nucleotides[-1])\n                        is_het.append(is_het[-1])\n                        is_snp.append(is_snp[-1])\n                        is_null.append(is_null[-1])\n\n            else:\n                # We have 1 gene or none, so set to None if no gene is present\n                gene = genes[0] if genes[0] != \"\" else None\n                if gene in seen_genes:\n                    # If we've already seen it, or it's intragene so skip\n                    continue\n                else:\n                    # Mark as seen now we have seen it\n                    seen_genes.add(gene)\n                    adding = True\n                if gene is not None:\n                    # Single gene, so pull out data\n                    gene_name.append(gene)\n                    gene_pos.append(\n                        self.get_gene_pos(gene, pos, variants[-1], start=start)\n                    )\n\n                    if (\n                        self.genome2.genes[gene][\"codes_protein\"]\n                        and gene_pos[-1] is not None\n                        and gene_pos[-1] &gt; 0\n                    ):\n                        # Get codon pos\n                        nc_idx = self.genome1.stacked_nucleotide_index[\n                            self.genome1.stacked_gene_name == gene\n                        ]\n                        nc_num = self.genome1.stacked_nucleotide_number[\n                            self.genome1.stacked_gene_name == gene\n                        ]\n                        codon_idx.append((nc_num[nc_idx == pos][0] - 1) % 3)\n                    else:\n                        codon_idx.append(None)\n                else:\n                    # We don't care about intragene values if its not the first item\n                    if pos != idx:\n                        continue\n                    gene_name.append(None)\n                    gene_pos.append(None)\n                    codon_idx.append(None)\n\n            # If this isn't the first one, we need to duplicate the row\n            if first:\n                first = False\n            elif adding and not multi:\n                variants.append(variants[-1])\n                refs.append(refs[-1])\n                alts.append(alt[-1])\n                indices.append(indices[-1])\n                is_indel.append(is_indel[-1])\n                indel_length.append(indel_length[-1])\n                indel_nucleotides.append(indel_nucleotides[-1])\n                is_het.append(is_het[-1])\n                is_snp.append(is_snp[-1])\n                is_null.append(is_null[-1])\n\n    self.variants = numpy.array(variants)\n    self.nucleotide_index = numpy.array(indices)\n    self.is_indel = numpy.array(is_indel)\n    self.indel_length = numpy.array(indel_length)\n    self.indel_nucleotides = numpy.array(indel_nucleotides)\n    self.is_snp = numpy.array(is_snp)\n    self.is_het = numpy.array(is_het)\n    self.is_null = numpy.array(is_null)\n    self.gene_name = gene_name\n    self.gene_pos = gene_pos\n    self.codon_idx = codon_idx\n</code></pre>"},{"location":"reference/difference/#difference.GenomeDifference.__init__","title":"<code>__init__(genome1, genome2)</code>","text":"<p>Constructor for the GenomeDifference object.</p> <p>Called implictly when <code>genome1.difference(genome2)</code> is performed. Args:     genome1 (gumpy.Genome): A Genome object to compare against     genome2 (gumpy.Genome): The other Genome object</p> Source code in <code>gumpy/difference.py</code> <pre><code>def __init__(self, genome1, genome2):\n    \"\"\"\n    Constructor for the GenomeDifference object.\n\n    Called implictly when `genome1.difference(genome2)` is performed.\n    Args:\n        genome1 (gumpy.Genome): A Genome object to compare against\n        genome2 (gumpy.Genome): The other Genome object\n    \"\"\"\n\n    # insist that both must be Genome objects\n    assert isinstance(genome1, gumpy.Genome)\n    assert isinstance(genome2, gumpy.Genome)\n\n    # Checking for the same genes, give an error if the genes are different\n    if genome1.genes.keys() != genome2.genes.keys():\n        genes_in_1_not_2 = set(genome1.genes.keys()).difference(\n            genome2.genes.keys()\n        )\n        genes_in_2_not_1 = set(genome2.genes.keys()).difference(\n            genome1.genes.keys()\n        )\n        message = \"The two genomes have different genes.\"\n        if len(genes_in_1_not_2) &gt; 0:\n            message += (\n                f\" Genome 1 has {len(genes_in_1_not_2)} more \"\n                f\"genes: {genes_in_1_not_2}.\"\n            )\n        if len(genes_in_2_not_1) &gt; 0:\n            message += (\n                f\" Genome2 has {len(genes_in_2_not_1)} more \"\n                f\"genes: {genes_in_2_not_1}.\"\n            )\n        raise FailedComparison(message)\n\n    self.genome1 = genome1\n    self.genome2 = genome2\n    self._view_method = \"diff\"\n\n    # Calculate SNPs\n    self.snp_distance = self.__snp_distance()\n    \"\"\"\n    Where applicable, the `full` difference arrays are stored as these can be \n    easily converted into `diff` arrays but not the other way around.\n    \"\"\"\n\n    self.__get_variants()\n\n    # Calculate differences\n    self._nucleotides_full = self.__nucleotides()\n\n    self.__assign_vcf_evidence()\n\n    self.update_view(self._view_method)\n</code></pre>"},{"location":"reference/difference/#difference.GenomeDifference.__nucleotides","title":"<code>__nucleotides()</code>","text":"<p>Calculate the difference in nucleotides Returns:     numpy.ndarray: Numpy array of tuples of (genome1_nucleotide,         genome2_nucleotide)</p> Source code in <code>gumpy/difference.py</code> <pre><code>def __nucleotides(self) -&gt; numpy.ndarray:\n    \"\"\"Calculate the difference in nucleotides\n    Returns:\n        numpy.ndarray: Numpy array of tuples of (genome1_nucleotide,\n            genome2_nucleotide)\n    \"\"\"\n    mask = self.genome1.nucleotide_sequence != self.genome2.nucleotide_sequence\n    return numpy.array(\n        list(\n            zip(\n                self.genome1.nucleotide_sequence[mask],\n                self.genome2.nucleotide_sequence[mask],\n            )\n        )\n    )\n</code></pre>"},{"location":"reference/difference/#difference.GenomeDifference.__snp_distance","title":"<code>__snp_distance()</code>","text":"<p>Calculates the SNP distance between the two genomes</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The SNP distance between the two genomes</p> Source code in <code>gumpy/difference.py</code> <pre><code>def __snp_distance(self) -&gt; int:\n    \"\"\"Calculates the SNP distance between the two genomes\n\n    Returns:\n        int: The SNP distance between the two genomes\n    \"\"\"\n    # Ignores `z` and `x`\n    return sum(\n        [\n            1\n            for (base1, base2) in zip(\n                self.genome1.nucleotide_sequence, self.genome2.nucleotide_sequence\n            )\n            if base1 != base2\n            and base1 in [\"a\", \"t\", \"c\", \"g\"]\n            and base2 in [\"a\", \"t\", \"c\", \"g\"]\n        ]\n    )\n</code></pre>"},{"location":"reference/difference/#difference.GenomeDifference.get_gene_pos","title":"<code>get_gene_pos(gene, idx, variant, start=None)</code>","text":"<p>Find the gene position of a given nucleotide index. This is considerably faster than building a whole stacked_gene_pos array     (takes ~4.5mins for tb)</p> <p>Parameters:</p> Name Type Description Default <code>gene</code> <code>str</code> <p>Name of the gene to search</p> required <code>idx</code> <code>int</code> <p>Nucleotide index we want the gene position of</p> required <code>variant</code> <code>str</code> <p>Variant we're looking for in GARC</p> required <code>start</code> <code>int</code> <p>Start position. Defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <code>int | None</code> <p>int | None: Gene position of this nucleotide index         (or None if it lies outside of the gene)</p> Source code in <code>gumpy/difference.py</code> <pre><code>def get_gene_pos(\n    self, gene: str, idx: int, variant: str, start: int | None = None\n) -&gt; int | None:\n    \"\"\"Find the gene position of a given nucleotide index.\n    This is considerably faster than building a whole stacked_gene_pos array\n        (takes ~4.5mins for tb)\n\n    Args:\n        gene (str): Name of the gene to search\n        idx (int): Nucleotide index we want the gene position of\n        variant (str): Variant we're looking for in GARC\n        start (int): Start position. Defaults to None\n\n    Returns:\n        int | None: Gene position of this nucleotide index\n                    (or None if it lies outside of the gene)\n    \"\"\"\n    stacked_gene_mask = self.genome1.stacked_gene_name == gene\n    nc_idx = self.genome1.stacked_nucleotide_index[stacked_gene_mask]\n    nc_nums = self.genome1.stacked_nucleotide_number[stacked_gene_mask]\n\n    # Get the gene's nucleotide number\n    nc_num = nc_nums[nc_idx == idx][0]\n\n    # If coding SNP, pull out the codon number instead\n    if (\n        self.genome2.genes[gene][\"codes_protein\"]\n        and nc_num &gt; 0\n        and \"ins\" not in variant\n        and \"del\" not in variant\n    ):\n        # Use floor division (//)\n        codon_number = (nc_num + 2) // 3\n        return codon_number\n    elif \"ins\" in variant:\n        # Insertions need a little nudge in revcomp because of `ins at, del after`\n        if self.genome2.genes[gene][\"reverse_complement\"]:\n            nc_num -= 1\n    elif \"del\" in variant:\n        pos, t, bases = variant.split(\"_\")\n        if start is not None and idx != start:\n            # This is not the start of the deletion, so truncate the bases as\n            #   appropriate\n            dels = len(bases) - (idx - start)\n        else:\n            dels = len(bases)\n        # Deletions need even more nudging in revcomp because the entire deletion\n        #   is reversed so starts at the end\n        if self.genome2.genes[gene][\"reverse_complement\"]:\n            nc_num = nc_num - dels + 1\n\n            # Edge case of deletion starting in revcomp gene and extending\n            # past gene start, so return None\n            if (\n                self.genome2.stacked_nucleotide_number[\n                    self.genome2.stacked_gene_name == gene\n                ][-1]\n                &gt; nc_num\n            ):\n                return None\n\n    return nc_num\n</code></pre>"},{"location":"reference/difference/#difference.GenomeDifference.minor_populations","title":"<code>minor_populations(interpretation='reads')</code>","text":"<p>Get the minor population mutations in GARC</p> <p>Parameters:</p> Name Type Description Default <code>interpretation</code> <code>str</code> <p>How to report minor population. 'reads' reports number of reads. 'percentage' reports fractional read support. Defaults to 'reads'.</p> <code>'reads'</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of mutations in GARC</p> Source code in <code>gumpy/difference.py</code> <pre><code>def minor_populations(self, interpretation: str = \"reads\") -&gt; List[str]:\n    \"\"\"Get the minor population mutations in GARC\n\n    Args:\n        interpretation (str, optional): How to report minor population.\n            'reads' reports number of reads. 'percentage' reports fractional\n            read support. Defaults to 'reads'.\n\n    Returns:\n        List[str]: List of mutations in GARC\n    \"\"\"\n    return self.genome2.minority_populations_GARC(\n        interpretation=interpretation, reference=self.genome1\n    )\n</code></pre>"},{"location":"reference/difference/#difference.convert_nucleotides_codons","title":"<code>convert_nucleotides_codons(nucleotides)</code>","text":"<p>Helper function to convert an array of nucleotides into an array of codons</p> <p>Parameters:</p> Name Type Description Default <code>nucleotides</code> <code>ndarray</code> <p>Array of nucleotides</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Array of codons</p> Source code in <code>gumpy/difference.py</code> <pre><code>def convert_nucleotides_codons(nucleotides: numpy.ndarray) -&gt; numpy.ndarray:\n    \"\"\"Helper function to convert an array of nucleotides into an array of codons\n\n    Args:\n        nucleotides (numpy.ndarray): Array of nucleotides\n\n    Returns:\n        numpy.ndarray: Array of codons\n    \"\"\"\n    codons = []\n    c = \"\"\n    for index in range(1, len(nucleotides) + 1):\n        c += nucleotides[index - 1]\n        if index % 3 == 0:\n            # There have been 3 bases seen so add the codon\n            codons.append(c)\n            c = \"\"\n    return numpy.array(codons)\n</code></pre>"},{"location":"reference/difference/#difference.setup_codon_aa_dict","title":"<code>setup_codon_aa_dict()</code>","text":"<p>Setup a conversion dictionary to convert codons to amino acids</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, str]</code> <p>Dictionary mapping codons of form 'xyz' to amino acids of form 'X'</p> Source code in <code>gumpy/difference.py</code> <pre><code>def setup_codon_aa_dict() -&gt; Dict[str, str]:\n    \"\"\"Setup a conversion dictionary to convert codons to amino acids\n\n    Returns:\n        dict: Dictionary mapping codons of form 'xyz' to amino acids of form 'X'\n    \"\"\"\n    # Defined bases\n    bases = [\"t\", \"c\", \"a\", \"g\", \"x\", \"z\", \"o\"]\n    # Defined amino acids in correct order\n    aminoacids = (\n        \"FFLLXZOSSSSXZOYY!!XZOCC!WXZOXXXXXXXZZZZXZOOOOOXOOLLLLXZOPPPPXZOHHQQXZORRRRXZOXXX\"\n        \"XXXXZZZZXZOOOOOXOOIIIMXZOTTTTXZONNKKXZOSSRRXZOXXXXXXXZZZZXZOOOOOXOOVVVVXZOAAAAXZ\"\n        \"ODDEEXZOGGGGXZOXXXXXXXZZZZXZOOOOOXOOXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n        \"XXXXXZZZZXZOZZZZXZOZZZZXZOZZZZXZOXXXXXXXZZZZXZOOOOOXOOOOOOXOOOOOOXOOOOOOXOOOOOOX\"\n        \"OOXXXXXXXOOOOXOOOOOOXOO\"\n    )\n    all_codons = [a + b + c for a in bases for b in bases for c in bases]\n    return dict(zip(all_codons, aminoacids))\n</code></pre>"},{"location":"reference/gene/","title":"gene","text":"<p>Gene object</p>"},{"location":"reference/gene/#gene.Gene","title":"<code>Gene</code>","text":"<p>               Bases: <code>object</code></p> <p>Gene object that uses underlying numpy arrays</p> Source code in <code>gumpy/gene.py</code> <pre><code>class Gene(object):\n    \"\"\"Gene object that uses underlying numpy arrays\"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        nucleotide_sequence: numpy.ndarray,\n        nucleotide_index: numpy.ndarray,\n        nucleotide_number: numpy.ndarray,\n        is_cds: numpy.ndarray,\n        is_promoter: numpy.ndarray,\n        is_indel: numpy.ndarray,\n        indel_length: numpy.ndarray,\n        indel_nucleotides: numpy.ndarray,\n        reverse_complement: bool,\n        codes_protein: bool,\n        feature_type: str,\n        ribosomal_shifts: List[int],\n        minority_populations: List,\n        is_deleted: numpy.ndarray,\n        vcf_evidence: dict,\n    ):\n        \"\"\"Constructor for the Gene object.\n\n        Args:\n            name (str, optional): Name of the gene. Defaults to None\n            nucleotide_sequence (numpy.array, optional): Numpy array of the nucleotide\n                sequence. Defaults to None\n            nucleotide_index (numpy.array, optional): Numpy array of the gene indices.\n                Defaults to None\n            nucleotide_number (numpy.array, optional): Numpy array of the gene\n                numbering. Defaults to None\n            is_cds (numpy.array, optional): Numpy array to act as a mask for whether\n                given elements are codons. Defaults to None\n            is_promoter (numpy.array, optional): Numpy array to act as a mask for\n                whether given elements are promoters. Defaults to None\n            is_indel (numpy.array, optional): Numpy array to act as a mask for whether\n                given elements are indels. Defaults to None\n            indel_length (numpy.array, optional): Numpy array denoting the lengths of\n                the indels whenever is_indel==True. Defaults to None\n            indel_nucleotides (numpy.array, optional): Numpy array describing the\n                nucleotides inserted or deleted whenever is_indel==True.\n                    Defaults to None\n            reverse_complement (boolean, optional): Boolean showing whether this gene\n                is reverse complement. Defaults to False\n            codes_protein (boolean, optional): Boolean showing whether this gene codes\n                a protein. Defaults to True\n            feature_type (str, optional): The name of the type of feature that this\n                gene represents. Defaults to None\n            ribosomal_shifts (list(int), optional): Indices of repeated bases due to\n                ribosomal frame shifting. Defaults to []\n            minority_populations ([int, str, str|(str,str), int, float], optional):\n                List of minor populations. Each minor population is defined as\n                [position, type, bases - either str or tuple of (ref, alt),\n                depth supporting this, fractional read support]\n            is_deleted (numpy.array, optional): Numpy array of booleans showing if a\n                given nucleotide index is deleted. Defaults to None\n            vcf_evidence (dict, optional): Dictionary tracking genome indices which\n                have VCF evidence to support these calls. Defaults to None\n        \"\"\"\n        # Using [] as a default value is dangerous, so convert from None\n        if ribosomal_shifts is None:\n            ribosomal_shifts = []\n        if is_deleted is None:\n            is_deleted = [i for i in nucleotide_index]\n\n        assert name is not None, \"must provide a gene name!\"\n        assert isinstance(name, str)\n        self.name = name\n\n        assert isinstance(feature_type, str)\n        self.feature_type = feature_type\n        assert codes_protein in [True, False], (\n            name + \": codes_protein must be True or False!\"\n        )\n        self.codes_protein = codes_protein\n\n        assert reverse_complement in [True, False], (\n            name + \": reverse_complement must be True or False!\"\n        )\n        self.reverse_complement = reverse_complement\n\n        assert isinstance(nucleotide_sequence, numpy.ndarray), (\n            name + \": sequence of bases must be a Numpy array!\"\n        )\n\n        assert isinstance(nucleotide_index, numpy.ndarray) and numpy.issubdtype(\n            nucleotide_index.dtype.type, numpy.integer\n        ), (name + \": genome indices must be a Numpy array of integers!\")\n\n        assert isinstance(nucleotide_number, numpy.ndarray), (\n            name + \": gene numbering must be a Numpy array of integers!\"\n        )\n\n        # check it is a list, and if it is that it is made up of integers and\n        #   only integers\n        assert isinstance(ribosomal_shifts, list)\n        if len(ribosomal_shifts) &gt; 0:\n            assert all([isinstance(i, int) for i in ribosomal_shifts])\n\n        assert len(nucleotide_index) == len(\n            nucleotide_sequence\n        ), \"all inputs arrays must be the same length!\"\n        assert len(nucleotide_index) == len(\n            nucleotide_number\n        ), \"all inputs arrays must be the same length!\"\n        assert len(nucleotide_index) == len(\n            is_cds\n        ), \"all inputs arrays must be the same length!\"\n        assert len(nucleotide_index) == len(\n            is_promoter\n        ), \"all inputs arrays must be the same length!\"\n        assert len(nucleotide_index) == len(\n            is_indel\n        ), \"all inputs arrays must be the same length!\"\n        assert len(nucleotide_index) == len(\n            indel_length\n        ), \"all inputs arrays must be the same length!\"\n        assert len(nucleotide_index) == len(\n            indel_nucleotides\n        ), \"all inputs arrays must be the same length!\"\n        assert len(nucleotide_index) == len(\n            is_deleted\n        ), \"all inputs arrays must be the same length!\"\n\n        nucleotide_sequence = numpy.char.lower(nucleotide_sequence)\n        assert numpy.count_nonzero(\n            numpy.isin(nucleotide_sequence, [\"a\", \"t\", \"c\", \"g\", \"x\", \"z\", \"o\"])\n        ) == len(nucleotide_sequence), (\n            name + \": sequence can only contain a,t,c,g,z,x\"\n        )\n\n        self.nucleotide_sequence = nucleotide_sequence\n        self.nucleotide_index = nucleotide_index\n        self.nucleotide_number = nucleotide_number\n        self.is_cds = is_cds\n        self.is_promoter = is_promoter\n        self.is_indel = is_indel\n        self.indel_nucleotides = indel_nucleotides\n        self.indel_length = indel_length\n        self.minority_populations = (\n            [] if minority_populations is None else minority_populations\n        )\n        self.is_deleted = is_deleted\n        self.vcf_evidence: dict = {} if vcf_evidence is None else vcf_evidence\n\n        self.minor_nc_changes: dict = {}\n\n        # Track the original nucleotide position of each indel if this gene is revcomp\n        self.revcomp_indel_nc_index: dict = {}\n\n        # As revcomp changes some of the positions for indels, track separately\n        # so we can track the genome position they came from\n        self.indel_index = copy.deepcopy(self.nucleotide_index)\n\n        self.__adjust_dels()\n\n        # Make appropriate changes to the arrays to encorporate the frame shift\n        for shift in ribosomal_shifts:\n            self.__duplicate(shift)\n        if self.reverse_complement:\n            self.nucleotide_sequence = self._complement(self.nucleotide_sequence[::-1])\n            self.nucleotide_index = self.nucleotide_index[::-1]\n            self.nucleotide_number = self.nucleotide_number[::-1]\n            self.is_cds = self.is_cds[::-1]\n            self.is_promoter = self.is_promoter[::-1]\n            self.__revcomp_indel()\n            if self.codes_protein:\n                self.codon_number = numpy.floor_divide(\n                    self.nucleotide_number[self.is_cds] + 2, 3\n                )\n                self.gene_position = numpy.concatenate(\n                    (\n                        self.nucleotide_number[self.nucleotide_number &lt; 0],\n                        self.codon_number,\n                    )\n                )\n            else:\n                self.gene_position = self.nucleotide_number\n        else:\n            if self.codes_protein:\n                self.codon_number = numpy.floor_divide(\n                    self.nucleotide_number[self.is_cds] + 2, 3\n                )\n                self.gene_position = numpy.concatenate(\n                    (\n                        self.nucleotide_number[self.nucleotide_number &lt; 0],\n                        self.codon_number,\n                    )\n                )\n            else:\n                self.gene_position = self.nucleotide_number\n\n        self.total_number_nucleotides = len(nucleotide_sequence)\n\n        if self.codes_protein:\n            self._setup_conversion_dicts()\n            self._translate_sequence()\n\n        self._convert_minority_populations()\n\n    def _convert_minority_populations(self) -&gt; None:\n        \"\"\"Convert the minority population details to gene indices + revcomp as req\"\"\"\n        fixed = []\n        for pop in self.minority_populations:\n            # Update genome index to gene index\n            pos = pop[0]\n            pos = self.nucleotide_number[self.nucleotide_index == pos][0]\n            type_ = pop[1]\n            bases = pop[2]\n\n            if self.reverse_complement:\n                # Is revcomp so update bases to reflect this\n                if type_ in [\"ref\", \"snp\"]:\n                    ref, alt = self._complement(bases)\n                    bases = (ref, alt)\n                else:\n                    # Is an indel so a little more complex\n                    bases = \"\".join(self._complement(bases))[::-1]\n                    if type_ == \"del\":\n                        pos = pos - len(bases) + 1\n            fixed.append([pos, type_, bases, pop[3], pop[4]])\n        self.minority_populations = sorted(fixed, key=lambda x: x[0])\n\n    def __adjust_dels(self) -&gt; None:\n        \"\"\"Adjust some of the deletions, such as deletions starting/ending in another\n            gene.\n        Also adjust the vcf evidences so they aren't present unless it is the start\n            of the del\n        \"\"\"\n        # Starting in another gene\n        if self.is_deleted[0] and self.indel_length[0] == 0:\n            # Find first N contiguous deletions\n            n = 0\n            for i in self.is_deleted:\n                if not i:\n                    break\n                n += 1\n            self.indel_length[0] = -1 * n\n            self.indel_nucleotides[0] = \"\".join(self.nucleotide_sequence[:n])\n\n        # Ending in another (truncating indel_length)\n        for idx, indel in enumerate(self.indel_length):\n            if indel &lt; 0 and -1 * indel &gt; len(self.indel_length[idx:]):\n                # Too long so truncate\n                self.indel_length[idx] = -1 * len(self.indel_length[idx:])\n                self.indel_nucleotides[idx] = \"\".join(self.nucleotide_sequence[idx:])\n\n        # Clean up vcf_evidences so only the start of a del has the evidence (to avoid\n        #   erroneous evidences)\n        for i, (deleted, length) in enumerate(zip(self.is_deleted, self.indel_length)):\n            if deleted and length &gt;= 0:\n                # Deleted but this isn't the start\n                nucleotide_index = self.nucleotide_index[i]\n                if self.vcf_evidence.get(nucleotide_index, None) is not None:\n                    # Delete if exists\n                    del self.vcf_evidence[nucleotide_index]\n\n    def minority_populations_GARC(\n        self, interpretation: str = \"reads\", reference=None\n    ) -&gt; List[str]:\n        \"\"\"Fetch the mutations caused by minority populations in GARC\n\n        Args:\n            interpretation (str, optional): Which way to interpret the coverage calls.\n                'reads' gives absolute read coverage. 'percentage' gives fractional\n                read support. Defaults to 'reads'.\n            reference (gumpy.Gene, optional): The reference to denote mutations from.\n                Defaults to self.\n\n        Returns:\n            [str]: List of mutations in GARC\n        \"\"\"\n\n        # Depending on interpretation requested, we either want [3] or [4]\n        if interpretation == \"percentage\":\n            coverage = 4\n        else:\n            coverage = 3\n\n        # Make sure we have a reference to compare against\n        if reference is None:\n            reference = self\n        else:\n            assert len(reference.minority_populations) == 0, (\n                \"Minority populations can only be compared when 1 Gene \"\n                \"does not have them!\"\n            )\n\n        # Map gene_position--&gt;[minor populations at this position]\n        # This also groups codons together\n        gene_pos_map = defaultdict(list)\n        for population in self.minority_populations:\n            pos = self.gene_position[self.nucleotide_number == population[0]][0]\n            gene_pos_map[pos].append(population)\n\n        mutations = []\n        for gene_pos in gene_pos_map.keys():\n            populations = gene_pos_map[gene_pos]\n            # As these don't have alt codons for Z calls, track the number of\n            #   nucleotide changes separately\n            nc_changes = len([i for i in populations if i[1] == \"snp\"])\n            if len(populations) == 1:\n                # We have exactly one so return it\n                pos, type_, bases, cov, frs = populations[0]\n                if type_ == \"snp\":\n                    if self.codes_protein and gene_pos &gt; 0:\n                        self.minor_nc_changes[gene_pos] = nc_changes\n                        # Get the ref codon to build the ref/alt AAs\n                        ref_codon = list(\n                            reference.codons[self.amino_acid_number == gene_pos][0]\n                        )\n                        codon_idx = (pos - 1) % 3\n                        alt_codon = copy.deepcopy(ref_codon)\n                        alt_codon[codon_idx] = bases[1]\n                        ref = self.codon_to_amino_acid[\"\".join(ref_codon)]\n                        alt = self.codon_to_amino_acid[\"\".join(alt_codon)]\n                        mutations.append(\n                            ref\n                            + str(gene_pos)\n                            + alt\n                            + \":\"\n                            + str(populations[0][coverage])\n                        )\n                    else:\n                        self.minor_nc_changes[pos] = nc_changes\n                        ref = reference.nucleotide_sequence[\n                            self.nucleotide_number == pos\n                        ][0]\n                        alt = bases[1]\n                        mutations.append(\n                            ref + str(pos) + alt + \":\" + str(populations[0][coverage])\n                        )\n                else:\n                    self.minor_nc_changes[pos] = nc_changes\n                    mutations.append(\n                        str(pos)\n                        + \"_\"\n                        + type_\n                        + \"_\"\n                        + bases\n                        + \":\"\n                        + str(populations[0][coverage])\n                    )\n            else:\n                self.minor_nc_changes[gene_pos] = nc_changes\n                # We have a mixture here so report as Zs for SNPs, indel for indels,\n                #   and mixed for mixed indels and SNPs\n                c = Counter(\n                    [\n                        (\n                            (nc_idx, \"indel\")\n                            if type_ in [\"ins\", \"del\"]\n                            else (nc_idx, type_)\n                        )\n                        for nc_idx, type_, bases, cov, frs in gene_pos_map[gene_pos]\n                    ]\n                )\n\n                # Get the number of indels within this codon/base\n                indels = sum([count for (i, t), count in c.items() if t == \"indel\"])\n                snps = sum([count for (i, t), count in c.items() if t == \"snp\"])\n\n                if indels &gt; 0 and snps &gt; 0:\n                    # Mixed within the codon/base so return &lt;pos&gt;_mixed\n                    cov = max([pop[coverage] for pop in populations])\n                    mutations.append(str(gene_pos) + \"_mixed:\" + str(cov))\n                elif indels &gt; 0:\n                    # Just indels, so return of form &lt;pos&gt;_indel\n                    # Little bit more difficult here as we have to check each\n                    #   nucleotide_number this way, if there is only 1 indel per\n                    #   nucleotide, we can be specific\n                    for (i, t), count in c.items():\n                        if count == 1:\n                            # Exactly 1 indel at this position so be specific\n                            # Use the nc_idx instead of gene_pos as they may not be\n                            #   equal\n                            minor = [\n                                (nc_idx, type_, bases, cov, frs)\n                                for nc_idx, type_, bases, cov, frs in gene_pos_map[\n                                    gene_pos\n                                ]\n                                if nc_idx == i\n                            ][0]\n                            self.minor_nc_changes[minor[0]] = 0\n                            mutations.append(\n                                str(minor[0])\n                                + \"_\"\n                                + minor[1]\n                                + \"_\"\n                                + minor[2]\n                                + \":\"\n                                + str(minor[coverage])\n                            )\n                        else:\n                            # &gt;1 indel here, so `&lt;pos&gt;_indel` as as accurate as we\n                            #   can be\n                            minors = [\n                                (nc_idx, type_, bases, cov, frs)\n                                for nc_idx, type_, bases, cov, frs in gene_pos_map[\n                                    gene_pos\n                                ]\n                                if nc_idx == i\n                            ]\n                            self.minor_nc_changes[minors[0][0]] = 0\n                            cov = max([pop[coverage] for pop in minors])\n                            mutations.append(str(minors[0][0]) + \"_indel:\" + str(cov))\n                else:\n                    # Just SNPs, so return of form &lt;ref&gt;&lt;pos&gt;(z|Z) as appropriate\n                    cov = max([pop[coverage] for pop in populations])\n                    if self.codes_protein and gene_pos &gt; 0:\n                        # These need a little extra effort to pull out the ref AA\n                        ref = self.codon_to_amino_acid[\n                            reference.codons[self.amino_acid_number == gene_pos][0]\n                        ]\n                        mutations.append(ref + str(gene_pos) + \"Z:\" + str(cov))\n                    else:\n                        ref = reference.nucleotide_sequence[\n                            self.gene_position == gene_pos\n                        ][0]\n                        mutations.append(ref + str(gene_pos) + \"z:\" + str(cov))\n        return sorted(mutations)\n\n    def __revcomp_indel(self) -&gt; None:\n        \"\"\"Make some adjustments for deletions within revcomp genes.\n        The largest of which is that the gene position of the deletion needs adjusting\n            for revcomp.\n        In a normal gene, the position x says delete to the left y bases.\n        In a revcomp gene we want to say the position x says delete to the right\n            y bases. So the pos needs changing, and indel_nucleotides need revcomping.\n\n        Because its going the opposite direction, the same indel will refer to a\n            different nucleotide position.\n        \"\"\"\n        # Reverse the indel arrays\n        is_indel = self.is_indel[::-1]\n        indel_length = self.indel_length[::-1]\n        indel_nucleotides = self.indel_nucleotides[::-1]\n        fixed_indel_index = self.indel_index[::-1]\n        self.is_deleted = self.is_deleted[::-1]\n\n        # Check for positions where there actually is an indel\n        positions = numpy.where(indel_length != 0)\n        if len(positions) == 1 and len(positions[0]) == 0:\n            # No indels to adjust, so return\n            self.is_indel = is_indel\n            self.indel_length = indel_length\n            self.indel_nucleotides = indel_nucleotides\n            return\n\n        # Fixed arrays to avoid collision cases\n        fixed_indel_nucleotides = numpy.array([None for i in self.indel_nucleotides])\n        fixed_is_indel = numpy.array([False for i in is_indel])\n        fixed_indel_length = numpy.array([0 for i in indel_length])\n        for pos in positions[0]:\n            if indel_length[pos] &gt; 0:\n                # An insertion at this pos so only revcomp the inserted bases\n                # Because this is backwards now, pos needs adjusting to point to the\n                #   right base for inserting after\n                old_pos = pos\n                pos = pos - 1\n                fixed_indel_nucleotides[pos] = \"\".join(\n                    self._complement(indel_nucleotides[old_pos][::-1])\n                )\n                fixed_is_indel[pos] = True\n                fixed_indel_length[pos] = indel_length[old_pos]\n                self.vcf_evidence[self.nucleotide_index[pos]] = self.vcf_evidence[\n                    self.nucleotide_index[old_pos]\n                ]\n                del self.vcf_evidence[self.nucleotide_index[old_pos]]\n                self.revcomp_indel_nc_index[str(self.nucleotide_number[pos])] = str(\n                    self.nucleotide_index[old_pos]\n                )\n            else:\n                # A deletion at this pos so adjust position\n                new_pos = pos - len(indel_nucleotides[pos]) + 1\n                fixed_indel_nucleotides[new_pos] = \"\".join(\n                    self._complement(indel_nucleotides[pos][::-1])\n                )\n                # Only set is_indel if it was set before\n                # In cases of large deletions, we don't want this set\n                if is_indel[pos]:\n                    fixed_is_indel[new_pos] = True\n                fixed_indel_length[new_pos] = indel_length[pos]\n                fixed_indel_index[new_pos] = fixed_indel_index[pos]\n                self.revcomp_indel_nc_index[str(self.nucleotide_number[new_pos])] = str(\n                    self.nucleotide_index[pos]\n                )\n\n        # Update instance variables\n        self.is_indel = fixed_is_indel\n        self.indel_length = fixed_indel_length\n        self.indel_nucleotides = fixed_indel_nucleotides\n        self.indel_index = fixed_indel_index\n\n    def __duplicate(self, index: int):\n        \"\"\"Duplicate all indices of important arrays to add the ribosomal shift\n\n        Args:\n            index (int): Gene index to duplicate in all arrays\n        \"\"\"\n        # Convert to gene array index\n        index = int(numpy.where(self.nucleotide_number == index)[0][0]) + 1\n\n        # Update the nucelotide_numbers so they include the duplicate\n        # Check for promoters before the codons\n        first_half = [self.nucleotide_number[i] for i in range(index)]\n        second_half = [\n            (\n                self.nucleotide_number[i] + 1\n                if self.nucleotide_number[i] &gt; 0\n                else self.nucleotide_number[i]\n            )\n            for i in range(index, len(self.nucleotide_number))\n        ]\n        self.nucleotide_number = numpy.array(\n            first_half + [self.nucleotide_number[index]] + second_half\n        )\n        # Update all\n        self.nucleotide_sequence = self.__duplicate_index(\n            index, self.nucleotide_sequence\n        )\n        self.nucleotide_index = self.__duplicate_index(index, self.nucleotide_index)\n        self.is_cds = self.__duplicate_index(index, self.is_cds)\n        self.is_promoter = self.__duplicate_index(index, self.is_promoter)\n        self.is_indel = self.__duplicate_index(index, self.is_indel)\n        self.indel_length = self.__duplicate_index(index, self.indel_length)\n        self.indel_index = self.__duplicate_index(index, self.indel_index)\n        self.indel_nucleotides = self.__duplicate_index(index, self.indel_nucleotides)\n\n    def __duplicate_index(self, index: int, array: numpy.ndarray) -&gt; numpy.ndarray:\n        \"\"\"Duplicates an element at a given index and returns the new array\n\n        Args:\n            index (int): Index of the array to duplicate\n            array (numpy.array): Array of items\n        Returns:\n            numpy.array: Array with duplicated item\n        \"\"\"\n        first_half = [array[i] for i in range(index)]\n        second_half = [array[i] for i in range(index, len(array))]\n        return numpy.array(first_half + [array[index]] + second_half)\n\n    def __eq__(self, other) -&gt; bool:\n        \"\"\"Overloading the equality operator to provide a method for determining if\n            two genes are the same\n\n        Args:\n            other (gumpy.Gene) : The other gene object to compare against\n\n        Returns:\n            bool : Boolean showing equality\n        \"\"\"\n        # Default to true\n        check: numpy.bool_ = numpy.bool_(True)\n        # Check all fields\n        check = check and self.name == other.name\n        check = check and numpy.all(\n            self.nucleotide_sequence == other.nucleotide_sequence\n        )\n        check = check and numpy.all(self.nucleotide_index == other.nucleotide_index)\n        check = check and numpy.all(self.nucleotide_number == other.nucleotide_number)\n        check = check and numpy.all(self.is_cds == other.is_cds)\n        check = check and numpy.all(self.is_promoter == other.is_promoter)\n        check = check and numpy.all(self.is_indel == other.is_indel)\n        check = check and numpy.all(self.indel_length == other.indel_length)\n        check = check and numpy.all(self.reverse_complement == other.reverse_complement)\n        check = check and numpy.all(self.codes_protein == other.codes_protein)\n        check = check and numpy.all(self.feature_type == other.feature_type)\n        if self.codes_protein:\n            check = check and numpy.all(\n                self.amino_acid_sequence == other.amino_acid_sequence\n            )\n            check = check and numpy.all(self.codons == other.codons)\n\n        return bool(check)\n\n    @staticmethod\n    def _complement(nucleotides_array: numpy.ndarray) -&gt; numpy.ndarray:\n        \"\"\"Simple private method for returning the complement of an array of bases.\n\n        * Note that takes account of HET and NULL calls via z and x, respectively\n\n        Args:\n            nucleotides_array (Iterable(str)): Some iterable of nucleotide bases.\n                Usually a numpy.array or list\n\n        Returns:\n            numpy.array: Array of complemented bases\n        \"\"\"\n\n        complementary_bases = {\n            \"a\": \"t\",\n            \"c\": \"g\",\n            \"g\": \"c\",\n            \"t\": \"a\",\n            \"x\": \"x\",\n            \"z\": \"z\",\n            \"o\": \"o\",\n            \"n\": \"n\",\n            \"r\": \"y\",\n            \"y\": \"r\",\n            \"s\": \"w\",\n            \"w\": \"s\",\n        }\n\n        complement = [complementary_bases[i] for i in nucleotides_array]\n\n        return numpy.array(complement)\n\n    def _translate_sequence(self):\n        \"\"\"Translate the coding sequence into amino acids\"\"\"\n\n        # this will ensure that only amino acids with all three bases present\n        unique, counts = numpy.unique(self.codon_number, return_counts=True)\n        self.amino_acid_number = unique[counts == 3]\n        self.amino_acid_number = self.amino_acid_number.astype(int)\n\n        cds_sequence = self.nucleotide_sequence[self.is_cds]\n\n        number_codons = int(numpy.sum(self.is_cds) / 3)\n\n        stacked_codons = cds_sequence.reshape((number_codons, 3))\n\n        codons = numpy.char.add(stacked_codons[:, 0], stacked_codons[:, 1])\n        self.codons = numpy.char.add(codons, stacked_codons[:, 2])\n\n        # now translate the triplets into amino acids using this new dictionary\n        self.amino_acid_sequence = numpy.array(\n            [self.codon_to_amino_acid[i] for i in self.codons]\n        )\n\n    def _setup_conversion_dicts(self):\n        \"\"\"Create the conversion dictionary for converting codon -&gt; amino acid\"\"\"\n        bases = [\"t\", \"c\", \"a\", \"g\", \"x\", \"z\", \"o\"]\n        aminoacids = (\n            \"FFLLXZOSSSSXZOYY!!XZOCC!WXZOXXXXXXXZZZZXZOOOOOXOOLLLLXZOPPPPXZOHHQQXZORRRRX\"\n            \"ZOXXXXXXXZZZZXZOOOOOXOOIIIMXZOTTTTXZONNKKXZOSSRRXZOXXXXXXXZZZZXZOOOOOXOOVVV\"\n            \"VXZOAAAAXZODDEEXZOGGGGXZOXXXXXXXZZZZXZOOOOOXOOXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n            \"XXXXXXXXXXXXXXXXXXXXZZZZXZOZZZZXZOZZZZXZOZZZZXZOXXXXXXXZZZZXZOOOOOXOOOOOOXO\"\n            \"OOOOOXOOOOOOXOOOOOOXOOXXXXXXXOOOOXOOOOOOXOO\"\n        )\n        all_codons = numpy.array(\n            [a + b + c for a in bases for b in bases for c in bases]\n        )\n        self.codon_to_amino_acid = dict(zip(all_codons, aminoacids))\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Overload the print function to write a summary of the Gene.\n\n        Returns:\n            str: String describing the Gene\n        \"\"\"\n        string_length = 5\n\n        output = self.name + \" gene\\n\"\n        output += \"%i nucleotides\" % self.total_number_nucleotides\n        if self.codes_protein:\n            output += \", codes for protein\\n\"\n        else:\n            output += \"\\n\"\n        if self.nucleotide_sequence[self.is_promoter].size != 0:\n            # updated to use numpy.printoptions to control the formatting\n            # does return as `['a' 'c' 't' 'g']`` rather than `actg` but fixes\n            #   formatting issues from old code such as repeating elements if\n            #   len(promoter) &lt;= string_length\n            with numpy.printoptions(threshold=string_length * 2):\n                output += str(self.nucleotide_sequence[self.is_promoter]) + \"\\n\"\n                output += str(self.nucleotide_number[self.is_promoter]) + \"\\n\"\n        else:\n            output += \"promoter likely in adjacent gene(s)\\n\"\n        if self.codes_protein:\n            with numpy.printoptions(threshold=string_length * 2):\n                output += str(self.amino_acid_sequence) + \"\\n\"\n                output += str(self.amino_acid_number)\n        else:\n            with numpy.printoptions(threshold=string_length * 2):\n                output += str(self.nucleotide_sequence[self.is_cds]) + \"\\n\"\n                output += str(self.nucleotide_number[self.is_cds])\n\n        return output\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of nucleotides in the coding region (i.e. ignoring any\n            assumed promoter)\n\n        Returns:\n            int\n        \"\"\"\n\n        return len(self.nucleotide_sequence[self.is_cds])\n\n    def __sub__(self, other) -&gt; GeneDifference:\n        \"\"\"Generate a GeneDifference object for an in-depth examination of the\n            difference between two genes.\n\n        Args:\n            other (gumpy.Gene): Other Gene object\n\n        Returns:\n            gumpy.GeneDifference: The GeneDifference object to detail changes at all\n                levels such as indel and amino acid.\n        \"\"\"\n\n        assert isinstance(other, Gene)\n\n        return GeneDifference(self, other)\n\n    def valid_variant(self, variant: str) -&gt; bool:\n        \"\"\"Determines if a given variant is valid for this gene\n\n        Args:\n            variant (str): String of a mutation in GARC\n\n        Returns:\n            bool: True when variant is valid, False otherwise\n        \"\"\"\n        assert variant is not None, \"No Variant given!\"\n        assert isinstance(variant, str)\n        assert len(variant) &gt;= 2, \"Variant must be at least 2 characters e.g. A=\"\n\n        # Match mutation formats using regex\n\n        # Check for minority populations (and remove before continuing)\n        if \":\" in variant:\n            valid = True\n            variant_ = variant.split(\":\")\n\n            valid = valid and len(variant_) == 2\n\n            # Use duck typing to ensure it gives a valid number\n            try:\n                float(variant_[1])\n            except ValueError:\n                return False\n\n            # 0 is not valid either\n            valid = valid and float(variant_[1]) &gt; 0\n\n            if valid:\n                # Valid minority population, so continue without it\n                variant = variant_[0]\n            else:\n                return False\n\n        # Match promoter/non-coding SNP format\n        promoter = re.compile(\n            r\"\"\"\n                ([a-zA-Z_0-9.()]+@)? #Possibly a leading gene name\n                ([acgtzx]) #Reference base\n                (-?[0-9]+) #Position\n                ([acgtzx]) #Alt base\n                \"\"\",\n            re.VERBOSE,\n        )\n        promoter_match = promoter.fullmatch(variant)\n        if promoter_match is not None:\n            # The variant is either promoter or non-coding\n            # Check that the mutation is valid\n            name, ref, pos, alt = promoter_match.groups()\n            valid = True\n            # Strip '@' from gene name and compare\n            if name is not None and name != \"\":\n                valid = valid and name[:-1] == self.name\n            # Check that the pos is in the correct range\n            valid = valid and int(pos) in self.nucleotide_number\n            # Check that the ref matches the seq at the given pos\n            valid = (\n                valid\n                and self.nucleotide_sequence[self.nucleotide_number == int(pos)] == ref\n            )\n            # Mutation should not have same ref and alt\n            valid = valid and ref != alt\n            return valid\n        # Match amino acid SNP\n        snp = re.compile(\n            r\"\"\"\n                    ([a-zA-Z_0-9.()]+@)? #Possibly leading gene name\n                    ([A-Z!]) #Reference amino acid\n                    ([0-9]+) #Position\n                    ([A-Z!]) #Alt amino acid\n                    \"\"\",\n            re.VERBOSE,\n        )\n        snp_match = snp.fullmatch(variant)\n        if self.codes_protein and snp_match is not None:\n            # The variant is an amino acid SNP\n            # Check it is valid\n            name, ref, pos, alt = snp_match.groups()\n            valid = True\n            # Strip '@' from gene name and compare\n            if name is not None and name != \"\":\n                valid = valid and name[:-1] == self.name\n            # Check pos is in correct range\n            valid = valid and int(pos) in self.amino_acid_number\n            # Check ref matches the aa seq at the given pos\n            valid = (\n                valid\n                and self.amino_acid_sequence[self.amino_acid_number == int(pos)] == ref\n            )\n            return valid\n\n        # Match amino acid synon-mutation\n        synon = re.compile(\n            r\"\"\"\n                        ([a-zA-Z_0-9.()]+@)? #Possibly leading gene name\n                        ([0-9]+) #Pos\n                        = #Synonymous amino acid\n                        \"\"\",\n            re.VERBOSE,\n        )\n        synon_match = synon.fullmatch(variant)\n        if self.codes_protein and synon_match is not None:\n            # Variant is a synonymous mutation\n            # Check it is valid\n            name, pos = synon_match.groups()\n            valid = True\n            if name is not None and name != \"\":\n                valid = valid and name[:-1] == self.name\n            valid = valid and int(pos) in self.amino_acid_number\n            return valid\n\n        # Match indel\n        indel = re.compile(\n            r\"\"\"\n                    ([a-zA-Z_0-9.()]+@)? #Possibly leading gene name\n                    (-?[0-9]+) #Position\n                    _(ins|del|indel|mixed)_? #Type\n                    ([0-9]+|[acgtzx]+)? #Bases deleted/inserted\n                    \"\"\",\n            re.VERBOSE,\n        )\n        indel_match = indel.fullmatch(variant)\n        if indel_match is not None:\n            # Variant is an indel\n            # Check it is valid\n            name, pos, type_, bases = indel_match.groups()\n            valid = True\n            pos = int(pos)\n            end = numpy.max(self.nucleotide_number)\n            # Check the names match\n            if name is not None and name != \"\":\n                valid = valid and name[:-1] == self.name\n            # Check pos in correct range\n            valid = valid and int(pos) in self.nucleotide_number\n            if type_ == \"indel\" or type_ == \"mixed\":\n                # If a mutation is given as `indel` or `mixed`, no length/bases should\n                #   be given\n                valid = valid and (bases is None or bases == \"\")\n            if type_ == \"del\" and bases is not None and bases != \"\":\n                # Mutation was del, so check if the bases given match the ref\n                if bases.isnumeric():\n                    # A length was given rather than bases so just check that all bases\n                    #   are in the correct range\n                    if pos &lt; 0:\n                        # Is a promoter so be careful about pos+bases not being 0\n                        pos -= 1\n                    offset = 0\n                    for i in range(1, int(bases) + 1):\n                        if pos + i == 0:\n                            offset = 1\n                        # Ignore checking if the del passes the 5'end of the gene\n                        if pos + i + offset &gt; end:\n                            continue\n                        valid = valid and pos + i + offset in self.nucleotide_number\n                else:\n                    # Bases were given rather than a length, so check for equality\n                    #   against base seq\n                    offset = 0\n                    for index, base in enumerate(bases):\n                        if pos + index == 0:\n                            offset = 1\n                        if pos + index + offset &gt; end:\n                            # Ignore checking if the del passes the 5' end of the gene\n                            continue\n                        valid = (\n                            valid\n                            and int(pos) + index + offset in self.nucleotide_number\n                        )\n                        valid = (\n                            valid\n                            and self.nucleotide_sequence[\n                                self.nucleotide_number == int(pos) + index + offset\n                            ]\n                            == base\n                        )\n            if type_ == \"ins\":\n                # Just check that the position specified lies within the gene\n                valid = valid and pos in self.nucleotide_number\n            return valid\n        # Checking for percentage deletion\n        deletion = re.compile(\n            r\"\"\"\n                            ([a-zA-Z_0-9.()]+@)? #Possibly leading gene name\n                            del_ #Deletion\n                            ([01]\\.[0-9]+)\n                            \"\"\",\n            re.VERBOSE,\n        )\n        deletion_match = deletion.fullmatch(variant)\n        if deletion_match is not None:\n            name, percent = deletion_match.groups()\n            valid = True\n            if name is not None:\n                valid = valid and name[:-1] == self.name\n            percent = float(percent)\n            valid = valid and percent &lt;= 1 and percent &gt;= 0\n            return valid\n        # If none of the mutations have matched, return False\n        return False\n</code></pre>"},{"location":"reference/gene/#gene.Gene.__adjust_dels","title":"<code>__adjust_dels()</code>","text":"<p>Adjust some of the deletions, such as deletions starting/ending in another     gene. Also adjust the vcf evidences so they aren't present unless it is the start     of the del</p> Source code in <code>gumpy/gene.py</code> <pre><code>def __adjust_dels(self) -&gt; None:\n    \"\"\"Adjust some of the deletions, such as deletions starting/ending in another\n        gene.\n    Also adjust the vcf evidences so they aren't present unless it is the start\n        of the del\n    \"\"\"\n    # Starting in another gene\n    if self.is_deleted[0] and self.indel_length[0] == 0:\n        # Find first N contiguous deletions\n        n = 0\n        for i in self.is_deleted:\n            if not i:\n                break\n            n += 1\n        self.indel_length[0] = -1 * n\n        self.indel_nucleotides[0] = \"\".join(self.nucleotide_sequence[:n])\n\n    # Ending in another (truncating indel_length)\n    for idx, indel in enumerate(self.indel_length):\n        if indel &lt; 0 and -1 * indel &gt; len(self.indel_length[idx:]):\n            # Too long so truncate\n            self.indel_length[idx] = -1 * len(self.indel_length[idx:])\n            self.indel_nucleotides[idx] = \"\".join(self.nucleotide_sequence[idx:])\n\n    # Clean up vcf_evidences so only the start of a del has the evidence (to avoid\n    #   erroneous evidences)\n    for i, (deleted, length) in enumerate(zip(self.is_deleted, self.indel_length)):\n        if deleted and length &gt;= 0:\n            # Deleted but this isn't the start\n            nucleotide_index = self.nucleotide_index[i]\n            if self.vcf_evidence.get(nucleotide_index, None) is not None:\n                # Delete if exists\n                del self.vcf_evidence[nucleotide_index]\n</code></pre>"},{"location":"reference/gene/#gene.Gene.__duplicate","title":"<code>__duplicate(index)</code>","text":"<p>Duplicate all indices of important arrays to add the ribosomal shift</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Gene index to duplicate in all arrays</p> required Source code in <code>gumpy/gene.py</code> <pre><code>def __duplicate(self, index: int):\n    \"\"\"Duplicate all indices of important arrays to add the ribosomal shift\n\n    Args:\n        index (int): Gene index to duplicate in all arrays\n    \"\"\"\n    # Convert to gene array index\n    index = int(numpy.where(self.nucleotide_number == index)[0][0]) + 1\n\n    # Update the nucelotide_numbers so they include the duplicate\n    # Check for promoters before the codons\n    first_half = [self.nucleotide_number[i] for i in range(index)]\n    second_half = [\n        (\n            self.nucleotide_number[i] + 1\n            if self.nucleotide_number[i] &gt; 0\n            else self.nucleotide_number[i]\n        )\n        for i in range(index, len(self.nucleotide_number))\n    ]\n    self.nucleotide_number = numpy.array(\n        first_half + [self.nucleotide_number[index]] + second_half\n    )\n    # Update all\n    self.nucleotide_sequence = self.__duplicate_index(\n        index, self.nucleotide_sequence\n    )\n    self.nucleotide_index = self.__duplicate_index(index, self.nucleotide_index)\n    self.is_cds = self.__duplicate_index(index, self.is_cds)\n    self.is_promoter = self.__duplicate_index(index, self.is_promoter)\n    self.is_indel = self.__duplicate_index(index, self.is_indel)\n    self.indel_length = self.__duplicate_index(index, self.indel_length)\n    self.indel_index = self.__duplicate_index(index, self.indel_index)\n    self.indel_nucleotides = self.__duplicate_index(index, self.indel_nucleotides)\n</code></pre>"},{"location":"reference/gene/#gene.Gene.__duplicate_index","title":"<code>__duplicate_index(index, array)</code>","text":"<p>Duplicates an element at a given index and returns the new array</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the array to duplicate</p> required <code>array</code> <code>array</code> <p>Array of items</p> required <p>Returns:     numpy.array: Array with duplicated item</p> Source code in <code>gumpy/gene.py</code> <pre><code>def __duplicate_index(self, index: int, array: numpy.ndarray) -&gt; numpy.ndarray:\n    \"\"\"Duplicates an element at a given index and returns the new array\n\n    Args:\n        index (int): Index of the array to duplicate\n        array (numpy.array): Array of items\n    Returns:\n        numpy.array: Array with duplicated item\n    \"\"\"\n    first_half = [array[i] for i in range(index)]\n    second_half = [array[i] for i in range(index, len(array))]\n    return numpy.array(first_half + [array[index]] + second_half)\n</code></pre>"},{"location":"reference/gene/#gene.Gene.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Overloading the equality operator to provide a method for determining if     two genes are the same</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>gumpy.Gene) </code> <p>The other gene object to compare against</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Boolean showing equality</p> Source code in <code>gumpy/gene.py</code> <pre><code>def __eq__(self, other) -&gt; bool:\n    \"\"\"Overloading the equality operator to provide a method for determining if\n        two genes are the same\n\n    Args:\n        other (gumpy.Gene) : The other gene object to compare against\n\n    Returns:\n        bool : Boolean showing equality\n    \"\"\"\n    # Default to true\n    check: numpy.bool_ = numpy.bool_(True)\n    # Check all fields\n    check = check and self.name == other.name\n    check = check and numpy.all(\n        self.nucleotide_sequence == other.nucleotide_sequence\n    )\n    check = check and numpy.all(self.nucleotide_index == other.nucleotide_index)\n    check = check and numpy.all(self.nucleotide_number == other.nucleotide_number)\n    check = check and numpy.all(self.is_cds == other.is_cds)\n    check = check and numpy.all(self.is_promoter == other.is_promoter)\n    check = check and numpy.all(self.is_indel == other.is_indel)\n    check = check and numpy.all(self.indel_length == other.indel_length)\n    check = check and numpy.all(self.reverse_complement == other.reverse_complement)\n    check = check and numpy.all(self.codes_protein == other.codes_protein)\n    check = check and numpy.all(self.feature_type == other.feature_type)\n    if self.codes_protein:\n        check = check and numpy.all(\n            self.amino_acid_sequence == other.amino_acid_sequence\n        )\n        check = check and numpy.all(self.codons == other.codons)\n\n    return bool(check)\n</code></pre>"},{"location":"reference/gene/#gene.Gene.__init__","title":"<code>__init__(name, nucleotide_sequence, nucleotide_index, nucleotide_number, is_cds, is_promoter, is_indel, indel_length, indel_nucleotides, reverse_complement, codes_protein, feature_type, ribosomal_shifts, minority_populations, is_deleted, vcf_evidence)</code>","text":"<p>Constructor for the Gene object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the gene. Defaults to None</p> required <code>nucleotide_sequence</code> <code>array</code> <p>Numpy array of the nucleotide sequence. Defaults to None</p> required <code>nucleotide_index</code> <code>array</code> <p>Numpy array of the gene indices. Defaults to None</p> required <code>nucleotide_number</code> <code>array</code> <p>Numpy array of the gene numbering. Defaults to None</p> required <code>is_cds</code> <code>array</code> <p>Numpy array to act as a mask for whether given elements are codons. Defaults to None</p> required <code>is_promoter</code> <code>array</code> <p>Numpy array to act as a mask for whether given elements are promoters. Defaults to None</p> required <code>is_indel</code> <code>array</code> <p>Numpy array to act as a mask for whether given elements are indels. Defaults to None</p> required <code>indel_length</code> <code>array</code> <p>Numpy array denoting the lengths of the indels whenever is_indel==True. Defaults to None</p> required <code>indel_nucleotides</code> <code>array</code> <p>Numpy array describing the nucleotides inserted or deleted whenever is_indel==True.     Defaults to None</p> required <code>reverse_complement</code> <code>boolean</code> <p>Boolean showing whether this gene is reverse complement. Defaults to False</p> required <code>codes_protein</code> <code>boolean</code> <p>Boolean showing whether this gene codes a protein. Defaults to True</p> required <code>feature_type</code> <code>str</code> <p>The name of the type of feature that this gene represents. Defaults to None</p> required <code>ribosomal_shifts</code> <code>list(int)</code> <p>Indices of repeated bases due to ribosomal frame shifting. Defaults to []</p> required <code>minority_populations</code> <code>[int, str, str | (str, str), int, float]</code> <p>List of minor populations. Each minor population is defined as [position, type, bases - either str or tuple of (ref, alt), depth supporting this, fractional read support]</p> required <code>is_deleted</code> <code>array</code> <p>Numpy array of booleans showing if a given nucleotide index is deleted. Defaults to None</p> required <code>vcf_evidence</code> <code>dict</code> <p>Dictionary tracking genome indices which have VCF evidence to support these calls. Defaults to None</p> required Source code in <code>gumpy/gene.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    nucleotide_sequence: numpy.ndarray,\n    nucleotide_index: numpy.ndarray,\n    nucleotide_number: numpy.ndarray,\n    is_cds: numpy.ndarray,\n    is_promoter: numpy.ndarray,\n    is_indel: numpy.ndarray,\n    indel_length: numpy.ndarray,\n    indel_nucleotides: numpy.ndarray,\n    reverse_complement: bool,\n    codes_protein: bool,\n    feature_type: str,\n    ribosomal_shifts: List[int],\n    minority_populations: List,\n    is_deleted: numpy.ndarray,\n    vcf_evidence: dict,\n):\n    \"\"\"Constructor for the Gene object.\n\n    Args:\n        name (str, optional): Name of the gene. Defaults to None\n        nucleotide_sequence (numpy.array, optional): Numpy array of the nucleotide\n            sequence. Defaults to None\n        nucleotide_index (numpy.array, optional): Numpy array of the gene indices.\n            Defaults to None\n        nucleotide_number (numpy.array, optional): Numpy array of the gene\n            numbering. Defaults to None\n        is_cds (numpy.array, optional): Numpy array to act as a mask for whether\n            given elements are codons. Defaults to None\n        is_promoter (numpy.array, optional): Numpy array to act as a mask for\n            whether given elements are promoters. Defaults to None\n        is_indel (numpy.array, optional): Numpy array to act as a mask for whether\n            given elements are indels. Defaults to None\n        indel_length (numpy.array, optional): Numpy array denoting the lengths of\n            the indels whenever is_indel==True. Defaults to None\n        indel_nucleotides (numpy.array, optional): Numpy array describing the\n            nucleotides inserted or deleted whenever is_indel==True.\n                Defaults to None\n        reverse_complement (boolean, optional): Boolean showing whether this gene\n            is reverse complement. Defaults to False\n        codes_protein (boolean, optional): Boolean showing whether this gene codes\n            a protein. Defaults to True\n        feature_type (str, optional): The name of the type of feature that this\n            gene represents. Defaults to None\n        ribosomal_shifts (list(int), optional): Indices of repeated bases due to\n            ribosomal frame shifting. Defaults to []\n        minority_populations ([int, str, str|(str,str), int, float], optional):\n            List of minor populations. Each minor population is defined as\n            [position, type, bases - either str or tuple of (ref, alt),\n            depth supporting this, fractional read support]\n        is_deleted (numpy.array, optional): Numpy array of booleans showing if a\n            given nucleotide index is deleted. Defaults to None\n        vcf_evidence (dict, optional): Dictionary tracking genome indices which\n            have VCF evidence to support these calls. Defaults to None\n    \"\"\"\n    # Using [] as a default value is dangerous, so convert from None\n    if ribosomal_shifts is None:\n        ribosomal_shifts = []\n    if is_deleted is None:\n        is_deleted = [i for i in nucleotide_index]\n\n    assert name is not None, \"must provide a gene name!\"\n    assert isinstance(name, str)\n    self.name = name\n\n    assert isinstance(feature_type, str)\n    self.feature_type = feature_type\n    assert codes_protein in [True, False], (\n        name + \": codes_protein must be True or False!\"\n    )\n    self.codes_protein = codes_protein\n\n    assert reverse_complement in [True, False], (\n        name + \": reverse_complement must be True or False!\"\n    )\n    self.reverse_complement = reverse_complement\n\n    assert isinstance(nucleotide_sequence, numpy.ndarray), (\n        name + \": sequence of bases must be a Numpy array!\"\n    )\n\n    assert isinstance(nucleotide_index, numpy.ndarray) and numpy.issubdtype(\n        nucleotide_index.dtype.type, numpy.integer\n    ), (name + \": genome indices must be a Numpy array of integers!\")\n\n    assert isinstance(nucleotide_number, numpy.ndarray), (\n        name + \": gene numbering must be a Numpy array of integers!\"\n    )\n\n    # check it is a list, and if it is that it is made up of integers and\n    #   only integers\n    assert isinstance(ribosomal_shifts, list)\n    if len(ribosomal_shifts) &gt; 0:\n        assert all([isinstance(i, int) for i in ribosomal_shifts])\n\n    assert len(nucleotide_index) == len(\n        nucleotide_sequence\n    ), \"all inputs arrays must be the same length!\"\n    assert len(nucleotide_index) == len(\n        nucleotide_number\n    ), \"all inputs arrays must be the same length!\"\n    assert len(nucleotide_index) == len(\n        is_cds\n    ), \"all inputs arrays must be the same length!\"\n    assert len(nucleotide_index) == len(\n        is_promoter\n    ), \"all inputs arrays must be the same length!\"\n    assert len(nucleotide_index) == len(\n        is_indel\n    ), \"all inputs arrays must be the same length!\"\n    assert len(nucleotide_index) == len(\n        indel_length\n    ), \"all inputs arrays must be the same length!\"\n    assert len(nucleotide_index) == len(\n        indel_nucleotides\n    ), \"all inputs arrays must be the same length!\"\n    assert len(nucleotide_index) == len(\n        is_deleted\n    ), \"all inputs arrays must be the same length!\"\n\n    nucleotide_sequence = numpy.char.lower(nucleotide_sequence)\n    assert numpy.count_nonzero(\n        numpy.isin(nucleotide_sequence, [\"a\", \"t\", \"c\", \"g\", \"x\", \"z\", \"o\"])\n    ) == len(nucleotide_sequence), (\n        name + \": sequence can only contain a,t,c,g,z,x\"\n    )\n\n    self.nucleotide_sequence = nucleotide_sequence\n    self.nucleotide_index = nucleotide_index\n    self.nucleotide_number = nucleotide_number\n    self.is_cds = is_cds\n    self.is_promoter = is_promoter\n    self.is_indel = is_indel\n    self.indel_nucleotides = indel_nucleotides\n    self.indel_length = indel_length\n    self.minority_populations = (\n        [] if minority_populations is None else minority_populations\n    )\n    self.is_deleted = is_deleted\n    self.vcf_evidence: dict = {} if vcf_evidence is None else vcf_evidence\n\n    self.minor_nc_changes: dict = {}\n\n    # Track the original nucleotide position of each indel if this gene is revcomp\n    self.revcomp_indel_nc_index: dict = {}\n\n    # As revcomp changes some of the positions for indels, track separately\n    # so we can track the genome position they came from\n    self.indel_index = copy.deepcopy(self.nucleotide_index)\n\n    self.__adjust_dels()\n\n    # Make appropriate changes to the arrays to encorporate the frame shift\n    for shift in ribosomal_shifts:\n        self.__duplicate(shift)\n    if self.reverse_complement:\n        self.nucleotide_sequence = self._complement(self.nucleotide_sequence[::-1])\n        self.nucleotide_index = self.nucleotide_index[::-1]\n        self.nucleotide_number = self.nucleotide_number[::-1]\n        self.is_cds = self.is_cds[::-1]\n        self.is_promoter = self.is_promoter[::-1]\n        self.__revcomp_indel()\n        if self.codes_protein:\n            self.codon_number = numpy.floor_divide(\n                self.nucleotide_number[self.is_cds] + 2, 3\n            )\n            self.gene_position = numpy.concatenate(\n                (\n                    self.nucleotide_number[self.nucleotide_number &lt; 0],\n                    self.codon_number,\n                )\n            )\n        else:\n            self.gene_position = self.nucleotide_number\n    else:\n        if self.codes_protein:\n            self.codon_number = numpy.floor_divide(\n                self.nucleotide_number[self.is_cds] + 2, 3\n            )\n            self.gene_position = numpy.concatenate(\n                (\n                    self.nucleotide_number[self.nucleotide_number &lt; 0],\n                    self.codon_number,\n                )\n            )\n        else:\n            self.gene_position = self.nucleotide_number\n\n    self.total_number_nucleotides = len(nucleotide_sequence)\n\n    if self.codes_protein:\n        self._setup_conversion_dicts()\n        self._translate_sequence()\n\n    self._convert_minority_populations()\n</code></pre>"},{"location":"reference/gene/#gene.Gene.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of nucleotides in the coding region (i.e. ignoring any     assumed promoter)</p> <p>Returns:</p> Type Description <code>int</code> <p>int</p> Source code in <code>gumpy/gene.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of nucleotides in the coding region (i.e. ignoring any\n        assumed promoter)\n\n    Returns:\n        int\n    \"\"\"\n\n    return len(self.nucleotide_sequence[self.is_cds])\n</code></pre>"},{"location":"reference/gene/#gene.Gene.__repr__","title":"<code>__repr__()</code>","text":"<p>Overload the print function to write a summary of the Gene.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String describing the Gene</p> Source code in <code>gumpy/gene.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Overload the print function to write a summary of the Gene.\n\n    Returns:\n        str: String describing the Gene\n    \"\"\"\n    string_length = 5\n\n    output = self.name + \" gene\\n\"\n    output += \"%i nucleotides\" % self.total_number_nucleotides\n    if self.codes_protein:\n        output += \", codes for protein\\n\"\n    else:\n        output += \"\\n\"\n    if self.nucleotide_sequence[self.is_promoter].size != 0:\n        # updated to use numpy.printoptions to control the formatting\n        # does return as `['a' 'c' 't' 'g']`` rather than `actg` but fixes\n        #   formatting issues from old code such as repeating elements if\n        #   len(promoter) &lt;= string_length\n        with numpy.printoptions(threshold=string_length * 2):\n            output += str(self.nucleotide_sequence[self.is_promoter]) + \"\\n\"\n            output += str(self.nucleotide_number[self.is_promoter]) + \"\\n\"\n    else:\n        output += \"promoter likely in adjacent gene(s)\\n\"\n    if self.codes_protein:\n        with numpy.printoptions(threshold=string_length * 2):\n            output += str(self.amino_acid_sequence) + \"\\n\"\n            output += str(self.amino_acid_number)\n    else:\n        with numpy.printoptions(threshold=string_length * 2):\n            output += str(self.nucleotide_sequence[self.is_cds]) + \"\\n\"\n            output += str(self.nucleotide_number[self.is_cds])\n\n    return output\n</code></pre>"},{"location":"reference/gene/#gene.Gene.__revcomp_indel","title":"<code>__revcomp_indel()</code>","text":"<p>Make some adjustments for deletions within revcomp genes. The largest of which is that the gene position of the deletion needs adjusting     for revcomp. In a normal gene, the position x says delete to the left y bases. In a revcomp gene we want to say the position x says delete to the right     y bases. So the pos needs changing, and indel_nucleotides need revcomping.</p> <p>Because its going the opposite direction, the same indel will refer to a     different nucleotide position.</p> Source code in <code>gumpy/gene.py</code> <pre><code>def __revcomp_indel(self) -&gt; None:\n    \"\"\"Make some adjustments for deletions within revcomp genes.\n    The largest of which is that the gene position of the deletion needs adjusting\n        for revcomp.\n    In a normal gene, the position x says delete to the left y bases.\n    In a revcomp gene we want to say the position x says delete to the right\n        y bases. So the pos needs changing, and indel_nucleotides need revcomping.\n\n    Because its going the opposite direction, the same indel will refer to a\n        different nucleotide position.\n    \"\"\"\n    # Reverse the indel arrays\n    is_indel = self.is_indel[::-1]\n    indel_length = self.indel_length[::-1]\n    indel_nucleotides = self.indel_nucleotides[::-1]\n    fixed_indel_index = self.indel_index[::-1]\n    self.is_deleted = self.is_deleted[::-1]\n\n    # Check for positions where there actually is an indel\n    positions = numpy.where(indel_length != 0)\n    if len(positions) == 1 and len(positions[0]) == 0:\n        # No indels to adjust, so return\n        self.is_indel = is_indel\n        self.indel_length = indel_length\n        self.indel_nucleotides = indel_nucleotides\n        return\n\n    # Fixed arrays to avoid collision cases\n    fixed_indel_nucleotides = numpy.array([None for i in self.indel_nucleotides])\n    fixed_is_indel = numpy.array([False for i in is_indel])\n    fixed_indel_length = numpy.array([0 for i in indel_length])\n    for pos in positions[0]:\n        if indel_length[pos] &gt; 0:\n            # An insertion at this pos so only revcomp the inserted bases\n            # Because this is backwards now, pos needs adjusting to point to the\n            #   right base for inserting after\n            old_pos = pos\n            pos = pos - 1\n            fixed_indel_nucleotides[pos] = \"\".join(\n                self._complement(indel_nucleotides[old_pos][::-1])\n            )\n            fixed_is_indel[pos] = True\n            fixed_indel_length[pos] = indel_length[old_pos]\n            self.vcf_evidence[self.nucleotide_index[pos]] = self.vcf_evidence[\n                self.nucleotide_index[old_pos]\n            ]\n            del self.vcf_evidence[self.nucleotide_index[old_pos]]\n            self.revcomp_indel_nc_index[str(self.nucleotide_number[pos])] = str(\n                self.nucleotide_index[old_pos]\n            )\n        else:\n            # A deletion at this pos so adjust position\n            new_pos = pos - len(indel_nucleotides[pos]) + 1\n            fixed_indel_nucleotides[new_pos] = \"\".join(\n                self._complement(indel_nucleotides[pos][::-1])\n            )\n            # Only set is_indel if it was set before\n            # In cases of large deletions, we don't want this set\n            if is_indel[pos]:\n                fixed_is_indel[new_pos] = True\n            fixed_indel_length[new_pos] = indel_length[pos]\n            fixed_indel_index[new_pos] = fixed_indel_index[pos]\n            self.revcomp_indel_nc_index[str(self.nucleotide_number[new_pos])] = str(\n                self.nucleotide_index[pos]\n            )\n\n    # Update instance variables\n    self.is_indel = fixed_is_indel\n    self.indel_length = fixed_indel_length\n    self.indel_nucleotides = fixed_indel_nucleotides\n    self.indel_index = fixed_indel_index\n</code></pre>"},{"location":"reference/gene/#gene.Gene.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Generate a GeneDifference object for an in-depth examination of the     difference between two genes.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Gene</code> <p>Other Gene object</p> required <p>Returns:</p> Type Description <code>GeneDifference</code> <p>gumpy.GeneDifference: The GeneDifference object to detail changes at all levels such as indel and amino acid.</p> Source code in <code>gumpy/gene.py</code> <pre><code>def __sub__(self, other) -&gt; GeneDifference:\n    \"\"\"Generate a GeneDifference object for an in-depth examination of the\n        difference between two genes.\n\n    Args:\n        other (gumpy.Gene): Other Gene object\n\n    Returns:\n        gumpy.GeneDifference: The GeneDifference object to detail changes at all\n            levels such as indel and amino acid.\n    \"\"\"\n\n    assert isinstance(other, Gene)\n\n    return GeneDifference(self, other)\n</code></pre>"},{"location":"reference/gene/#gene.Gene.minority_populations_GARC","title":"<code>minority_populations_GARC(interpretation='reads', reference=None)</code>","text":"<p>Fetch the mutations caused by minority populations in GARC</p> <p>Parameters:</p> Name Type Description Default <code>interpretation</code> <code>str</code> <p>Which way to interpret the coverage calls. 'reads' gives absolute read coverage. 'percentage' gives fractional read support. Defaults to 'reads'.</p> <code>'reads'</code> <code>reference</code> <code>Gene</code> <p>The reference to denote mutations from. Defaults to self.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>[str]: List of mutations in GARC</p> Source code in <code>gumpy/gene.py</code> <pre><code>def minority_populations_GARC(\n    self, interpretation: str = \"reads\", reference=None\n) -&gt; List[str]:\n    \"\"\"Fetch the mutations caused by minority populations in GARC\n\n    Args:\n        interpretation (str, optional): Which way to interpret the coverage calls.\n            'reads' gives absolute read coverage. 'percentage' gives fractional\n            read support. Defaults to 'reads'.\n        reference (gumpy.Gene, optional): The reference to denote mutations from.\n            Defaults to self.\n\n    Returns:\n        [str]: List of mutations in GARC\n    \"\"\"\n\n    # Depending on interpretation requested, we either want [3] or [4]\n    if interpretation == \"percentage\":\n        coverage = 4\n    else:\n        coverage = 3\n\n    # Make sure we have a reference to compare against\n    if reference is None:\n        reference = self\n    else:\n        assert len(reference.minority_populations) == 0, (\n            \"Minority populations can only be compared when 1 Gene \"\n            \"does not have them!\"\n        )\n\n    # Map gene_position--&gt;[minor populations at this position]\n    # This also groups codons together\n    gene_pos_map = defaultdict(list)\n    for population in self.minority_populations:\n        pos = self.gene_position[self.nucleotide_number == population[0]][0]\n        gene_pos_map[pos].append(population)\n\n    mutations = []\n    for gene_pos in gene_pos_map.keys():\n        populations = gene_pos_map[gene_pos]\n        # As these don't have alt codons for Z calls, track the number of\n        #   nucleotide changes separately\n        nc_changes = len([i for i in populations if i[1] == \"snp\"])\n        if len(populations) == 1:\n            # We have exactly one so return it\n            pos, type_, bases, cov, frs = populations[0]\n            if type_ == \"snp\":\n                if self.codes_protein and gene_pos &gt; 0:\n                    self.minor_nc_changes[gene_pos] = nc_changes\n                    # Get the ref codon to build the ref/alt AAs\n                    ref_codon = list(\n                        reference.codons[self.amino_acid_number == gene_pos][0]\n                    )\n                    codon_idx = (pos - 1) % 3\n                    alt_codon = copy.deepcopy(ref_codon)\n                    alt_codon[codon_idx] = bases[1]\n                    ref = self.codon_to_amino_acid[\"\".join(ref_codon)]\n                    alt = self.codon_to_amino_acid[\"\".join(alt_codon)]\n                    mutations.append(\n                        ref\n                        + str(gene_pos)\n                        + alt\n                        + \":\"\n                        + str(populations[0][coverage])\n                    )\n                else:\n                    self.minor_nc_changes[pos] = nc_changes\n                    ref = reference.nucleotide_sequence[\n                        self.nucleotide_number == pos\n                    ][0]\n                    alt = bases[1]\n                    mutations.append(\n                        ref + str(pos) + alt + \":\" + str(populations[0][coverage])\n                    )\n            else:\n                self.minor_nc_changes[pos] = nc_changes\n                mutations.append(\n                    str(pos)\n                    + \"_\"\n                    + type_\n                    + \"_\"\n                    + bases\n                    + \":\"\n                    + str(populations[0][coverage])\n                )\n        else:\n            self.minor_nc_changes[gene_pos] = nc_changes\n            # We have a mixture here so report as Zs for SNPs, indel for indels,\n            #   and mixed for mixed indels and SNPs\n            c = Counter(\n                [\n                    (\n                        (nc_idx, \"indel\")\n                        if type_ in [\"ins\", \"del\"]\n                        else (nc_idx, type_)\n                    )\n                    for nc_idx, type_, bases, cov, frs in gene_pos_map[gene_pos]\n                ]\n            )\n\n            # Get the number of indels within this codon/base\n            indels = sum([count for (i, t), count in c.items() if t == \"indel\"])\n            snps = sum([count for (i, t), count in c.items() if t == \"snp\"])\n\n            if indels &gt; 0 and snps &gt; 0:\n                # Mixed within the codon/base so return &lt;pos&gt;_mixed\n                cov = max([pop[coverage] for pop in populations])\n                mutations.append(str(gene_pos) + \"_mixed:\" + str(cov))\n            elif indels &gt; 0:\n                # Just indels, so return of form &lt;pos&gt;_indel\n                # Little bit more difficult here as we have to check each\n                #   nucleotide_number this way, if there is only 1 indel per\n                #   nucleotide, we can be specific\n                for (i, t), count in c.items():\n                    if count == 1:\n                        # Exactly 1 indel at this position so be specific\n                        # Use the nc_idx instead of gene_pos as they may not be\n                        #   equal\n                        minor = [\n                            (nc_idx, type_, bases, cov, frs)\n                            for nc_idx, type_, bases, cov, frs in gene_pos_map[\n                                gene_pos\n                            ]\n                            if nc_idx == i\n                        ][0]\n                        self.minor_nc_changes[minor[0]] = 0\n                        mutations.append(\n                            str(minor[0])\n                            + \"_\"\n                            + minor[1]\n                            + \"_\"\n                            + minor[2]\n                            + \":\"\n                            + str(minor[coverage])\n                        )\n                    else:\n                        # &gt;1 indel here, so `&lt;pos&gt;_indel` as as accurate as we\n                        #   can be\n                        minors = [\n                            (nc_idx, type_, bases, cov, frs)\n                            for nc_idx, type_, bases, cov, frs in gene_pos_map[\n                                gene_pos\n                            ]\n                            if nc_idx == i\n                        ]\n                        self.minor_nc_changes[minors[0][0]] = 0\n                        cov = max([pop[coverage] for pop in minors])\n                        mutations.append(str(minors[0][0]) + \"_indel:\" + str(cov))\n            else:\n                # Just SNPs, so return of form &lt;ref&gt;&lt;pos&gt;(z|Z) as appropriate\n                cov = max([pop[coverage] for pop in populations])\n                if self.codes_protein and gene_pos &gt; 0:\n                    # These need a little extra effort to pull out the ref AA\n                    ref = self.codon_to_amino_acid[\n                        reference.codons[self.amino_acid_number == gene_pos][0]\n                    ]\n                    mutations.append(ref + str(gene_pos) + \"Z:\" + str(cov))\n                else:\n                    ref = reference.nucleotide_sequence[\n                        self.gene_position == gene_pos\n                    ][0]\n                    mutations.append(ref + str(gene_pos) + \"z:\" + str(cov))\n    return sorted(mutations)\n</code></pre>"},{"location":"reference/gene/#gene.Gene.valid_variant","title":"<code>valid_variant(variant)</code>","text":"<p>Determines if a given variant is valid for this gene</p> <p>Parameters:</p> Name Type Description Default <code>variant</code> <code>str</code> <p>String of a mutation in GARC</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True when variant is valid, False otherwise</p> Source code in <code>gumpy/gene.py</code> <pre><code>def valid_variant(self, variant: str) -&gt; bool:\n    \"\"\"Determines if a given variant is valid for this gene\n\n    Args:\n        variant (str): String of a mutation in GARC\n\n    Returns:\n        bool: True when variant is valid, False otherwise\n    \"\"\"\n    assert variant is not None, \"No Variant given!\"\n    assert isinstance(variant, str)\n    assert len(variant) &gt;= 2, \"Variant must be at least 2 characters e.g. A=\"\n\n    # Match mutation formats using regex\n\n    # Check for minority populations (and remove before continuing)\n    if \":\" in variant:\n        valid = True\n        variant_ = variant.split(\":\")\n\n        valid = valid and len(variant_) == 2\n\n        # Use duck typing to ensure it gives a valid number\n        try:\n            float(variant_[1])\n        except ValueError:\n            return False\n\n        # 0 is not valid either\n        valid = valid and float(variant_[1]) &gt; 0\n\n        if valid:\n            # Valid minority population, so continue without it\n            variant = variant_[0]\n        else:\n            return False\n\n    # Match promoter/non-coding SNP format\n    promoter = re.compile(\n        r\"\"\"\n            ([a-zA-Z_0-9.()]+@)? #Possibly a leading gene name\n            ([acgtzx]) #Reference base\n            (-?[0-9]+) #Position\n            ([acgtzx]) #Alt base\n            \"\"\",\n        re.VERBOSE,\n    )\n    promoter_match = promoter.fullmatch(variant)\n    if promoter_match is not None:\n        # The variant is either promoter or non-coding\n        # Check that the mutation is valid\n        name, ref, pos, alt = promoter_match.groups()\n        valid = True\n        # Strip '@' from gene name and compare\n        if name is not None and name != \"\":\n            valid = valid and name[:-1] == self.name\n        # Check that the pos is in the correct range\n        valid = valid and int(pos) in self.nucleotide_number\n        # Check that the ref matches the seq at the given pos\n        valid = (\n            valid\n            and self.nucleotide_sequence[self.nucleotide_number == int(pos)] == ref\n        )\n        # Mutation should not have same ref and alt\n        valid = valid and ref != alt\n        return valid\n    # Match amino acid SNP\n    snp = re.compile(\n        r\"\"\"\n                ([a-zA-Z_0-9.()]+@)? #Possibly leading gene name\n                ([A-Z!]) #Reference amino acid\n                ([0-9]+) #Position\n                ([A-Z!]) #Alt amino acid\n                \"\"\",\n        re.VERBOSE,\n    )\n    snp_match = snp.fullmatch(variant)\n    if self.codes_protein and snp_match is not None:\n        # The variant is an amino acid SNP\n        # Check it is valid\n        name, ref, pos, alt = snp_match.groups()\n        valid = True\n        # Strip '@' from gene name and compare\n        if name is not None and name != \"\":\n            valid = valid and name[:-1] == self.name\n        # Check pos is in correct range\n        valid = valid and int(pos) in self.amino_acid_number\n        # Check ref matches the aa seq at the given pos\n        valid = (\n            valid\n            and self.amino_acid_sequence[self.amino_acid_number == int(pos)] == ref\n        )\n        return valid\n\n    # Match amino acid synon-mutation\n    synon = re.compile(\n        r\"\"\"\n                    ([a-zA-Z_0-9.()]+@)? #Possibly leading gene name\n                    ([0-9]+) #Pos\n                    = #Synonymous amino acid\n                    \"\"\",\n        re.VERBOSE,\n    )\n    synon_match = synon.fullmatch(variant)\n    if self.codes_protein and synon_match is not None:\n        # Variant is a synonymous mutation\n        # Check it is valid\n        name, pos = synon_match.groups()\n        valid = True\n        if name is not None and name != \"\":\n            valid = valid and name[:-1] == self.name\n        valid = valid and int(pos) in self.amino_acid_number\n        return valid\n\n    # Match indel\n    indel = re.compile(\n        r\"\"\"\n                ([a-zA-Z_0-9.()]+@)? #Possibly leading gene name\n                (-?[0-9]+) #Position\n                _(ins|del|indel|mixed)_? #Type\n                ([0-9]+|[acgtzx]+)? #Bases deleted/inserted\n                \"\"\",\n        re.VERBOSE,\n    )\n    indel_match = indel.fullmatch(variant)\n    if indel_match is not None:\n        # Variant is an indel\n        # Check it is valid\n        name, pos, type_, bases = indel_match.groups()\n        valid = True\n        pos = int(pos)\n        end = numpy.max(self.nucleotide_number)\n        # Check the names match\n        if name is not None and name != \"\":\n            valid = valid and name[:-1] == self.name\n        # Check pos in correct range\n        valid = valid and int(pos) in self.nucleotide_number\n        if type_ == \"indel\" or type_ == \"mixed\":\n            # If a mutation is given as `indel` or `mixed`, no length/bases should\n            #   be given\n            valid = valid and (bases is None or bases == \"\")\n        if type_ == \"del\" and bases is not None and bases != \"\":\n            # Mutation was del, so check if the bases given match the ref\n            if bases.isnumeric():\n                # A length was given rather than bases so just check that all bases\n                #   are in the correct range\n                if pos &lt; 0:\n                    # Is a promoter so be careful about pos+bases not being 0\n                    pos -= 1\n                offset = 0\n                for i in range(1, int(bases) + 1):\n                    if pos + i == 0:\n                        offset = 1\n                    # Ignore checking if the del passes the 5'end of the gene\n                    if pos + i + offset &gt; end:\n                        continue\n                    valid = valid and pos + i + offset in self.nucleotide_number\n            else:\n                # Bases were given rather than a length, so check for equality\n                #   against base seq\n                offset = 0\n                for index, base in enumerate(bases):\n                    if pos + index == 0:\n                        offset = 1\n                    if pos + index + offset &gt; end:\n                        # Ignore checking if the del passes the 5' end of the gene\n                        continue\n                    valid = (\n                        valid\n                        and int(pos) + index + offset in self.nucleotide_number\n                    )\n                    valid = (\n                        valid\n                        and self.nucleotide_sequence[\n                            self.nucleotide_number == int(pos) + index + offset\n                        ]\n                        == base\n                    )\n        if type_ == \"ins\":\n            # Just check that the position specified lies within the gene\n            valid = valid and pos in self.nucleotide_number\n        return valid\n    # Checking for percentage deletion\n    deletion = re.compile(\n        r\"\"\"\n                        ([a-zA-Z_0-9.()]+@)? #Possibly leading gene name\n                        del_ #Deletion\n                        ([01]\\.[0-9]+)\n                        \"\"\",\n        re.VERBOSE,\n    )\n    deletion_match = deletion.fullmatch(variant)\n    if deletion_match is not None:\n        name, percent = deletion_match.groups()\n        valid = True\n        if name is not None:\n            valid = valid and name[:-1] == self.name\n        percent = float(percent)\n        valid = valid and percent &lt;= 1 and percent &gt;= 0\n        return valid\n    # If none of the mutations have matched, return False\n    return False\n</code></pre>"},{"location":"reference/genome/","title":"genome","text":"<p>Genome object</p>"},{"location":"reference/genome/#genome.Genome","title":"<code>Genome</code>","text":"<p>               Bases: <code>object</code></p> <p>Genome object</p> Source code in <code>gumpy/genome.py</code> <pre><code>class Genome(object):\n    \"\"\"Genome object\"\"\"\n\n    def __init__(\n        self,\n        genbank_file_: str,\n        show_progress_bar: bool = False,\n        gene_subset: List[str] | None = None,\n        max_promoter_length: int = 100,\n        max_gene_name_length: int = 20,\n        verbose: bool = False,\n        is_reference: bool = False,\n    ):\n        \"\"\"Constructor for the Genome object.\n\n        Args:\n            genbank_file_ (str) : The path to the genbank file.\n            show_progress_bar (bool, optional) : Boolean as whether to show a progress\n                bar when building Gene objects. Defaults to False.\n            gene_subset (list, optional) : List of gene names used to extract just a\n                subset of genes. Defaults to None\n            max_promoter_length (int, optional) : Size of the default maximum number of\n                upstream bases to consider the promoter of a gene. Defaults to 100\n            max_gene_name_length (int, optional) : Length of the longest gene name.\n                Defaults to 20\n            verbose (bool, optional) : Give verbose statements? Defaults to False\n            is_reference (bool, optional) : Is this a reference genome? i.e. mutations\n                can be derived with respect to it? Defaults to False\n        \"\"\"\n        self.show_progress_bar = show_progress_bar\n        self.gene_subset = gene_subset\n        self.max_promoter_length = max_promoter_length\n        self.max_gene_name_length = max_gene_name_length\n        self.verbose = verbose\n        self.is_reference = is_reference\n        self.vcf_file: VCFFile | None = None\n        self.gumpy_version: str | None = None\n\n        genbank_file = pathlib.Path(genbank_file_)\n\n        assert genbank_file.is_file(), \"GenBank file does not exist!\"\n        assert (\n            isinstance(self.max_promoter_length, int) and self.max_promoter_length &gt;= 0\n        ), \"the promoter length must be zero or a positive integer!\"\n\n        assert isinstance(self.verbose, bool)\n        assert isinstance(self.is_reference, bool)\n        assert isinstance(self.show_progress_bar, bool)\n        assert (\n            isinstance(self.max_gene_name_length, int) and self.max_gene_name_length &gt; 0\n        )\n        if self.gene_subset is not None:\n            # first check it is a list\n            assert isinstance(self.gene_subset, list)\n            # then check all elements in the list are strings\n            assert all(isinstance(i, str) for i in self.gene_subset)\n\n        if self.verbose:\n            timings = defaultdict(list)\n            start_time = time.time()\n\n        self.__parse_genbank_file(pathlib.Path(genbank_file))\n\n        if self.verbose:\n            timings[\"parse genbank\"].append(time.time() - start_time)\n            start_time = time.time()\n\n        self.__setup_arrays()\n\n        if self.verbose:\n            timings[\"define arrays\"].append(time.time() - start_time)\n            start_time = time.time()\n\n        if self.max_promoter_length &gt; 0:\n            self.__assign_promoter_regions()\n\n        if self.verbose:\n            timings[\"promoter\"].append(time.time() - start_time)\n            start_time = time.time()\n\n        self.__convert_references()\n\n    def __convert_references(self):\n        \"\"\"Convert BIOPython Reference objects to normal dictionaries. They do not\n        appear to have any greater application than storing structured data, so\n        removing the object wrappers appears to be a clean way to combat the object's\n        issues with serialization.\n        \"\"\"\n        for i, reference in enumerate(self.annotations[\"references\"]):\n            new_ref = {}\n            for key in vars(reference):\n                # This key contains unhelpfully structured data\n                if key == \"location\":\n                    new_loc = []\n                    for item in vars(reference)[key]:\n                        loc = {}\n                        for item_key in vars(item):\n                            if item_key == \"_start\" or item_key == \"_end\":\n                                # These are the only ones we care about\n                                loc[item_key] = int(getattr(item, item_key))\n                        new_loc.append(loc)\n                    new_ref[key] = new_loc\n                else:\n                    new_ref[key] = vars(reference)[key]\n            self.annotations[\"references\"][i] = new_ref\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Overload the print function to write a summary of the genome.\n\n        Returns:\n            str : String including attributes for the genome\n        \"\"\"\n\n        output = \"\"\n        if hasattr(self, \"name\"):\n            output += self.name + \"\\n\"\n        if hasattr(self, \"id\"):\n            output += self.id + \"\\n\"\n        if hasattr(self, \"description\"):\n            output += self.description + \"\\n\"\n        output += str(self.length) + \" bases\\n\"\n        output += \"\".join(i for i in self.nucleotide_sequence[0:6])\n        output += \"...\"\n        output += \"\".join(i for i in self.nucleotide_sequence[-6:]) + \"\\n\"\n        if self.gene_subset is None:\n            output += \"metadata for all genes/loci have been included\\n\"\n        elif len(self.gene_subset) &lt; 10:\n            output += (\n                \"the following \"\n                + str(len(self.gene_subset))\n                + \" genes have been included: \"\n            )\n            for i in self.gene_subset:\n                output += str(i) + \", \"\n        else:\n            output += str(len(self.gene_subset)) + \" gene/loci have been included.\"\n        return output\n\n    def __sub__(self, other) -&gt; GenomeDifference:\n        \"\"\"Generate a GenomeDifference object for a in-depth difference of the\n            two Genomes\n\n        Args:\n            other (gumpy.Genome) : The other genome used in the subtraction\n\n        Returns:\n            GenomeDifference: object containing numpy arrays of the\n                differences (variants)\n        \"\"\"\n\n        assert isinstance(other, Genome), \"RHS must be a gumpy.Genome object\"\n\n        return GenomeDifference(self, other)\n\n    def __eq__(self, other) -&gt; bool:\n        \"\"\"Overloading the equality operator so two Genome objects can be compared\n        directly. Checks for the equality based on fields, but does not check\n        for filename equality\n\n        Args:\n            other (gumpy.Genome) : The other Genome object to compare to\n\n        Returns:\n            bool : Boolean showing equality of the objects\n        \"\"\"\n        assert isinstance(other, Genome)\n\n        check = numpy.bool_(True)\n        check = check and numpy.bool_(self.genes == other.genes)\n        check = check and self.name == other.name\n        check = check and self.id == other.id\n        check = check and self.description == other.description\n        check = check and numpy.all(\n            self.nucleotide_sequence == other.nucleotide_sequence\n        )\n        check = check and numpy.all(self.nucleotide_index == other.nucleotide_index)\n        check = check and numpy.bool_(self.length == other.length)\n        check = check and numpy.all(\n            self.stacked_gene_name.tolist() == other.stacked_gene_name.tolist()\n        )\n\n        return bool(check)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Adding len functionality - len(genome) returns the length of the genome\n\n        Returns:\n            int : Length of the genome\n        \"\"\"\n        return self.length\n\n    def contains_gene(self, gene_name: str) -&gt; bool:\n        \"\"\"\n        Simply checks to see if the specified gene exists in the Genome object.\n\n        Args:\n            gene_name (str) : Name of the gene e.g. katG\n\n        Returns:\n            bool : Boolean showing if the genome contains a gene with that name\n        \"\"\"\n        assert isinstance(\n            gene_name, str\n        ), \"Gene name must be string. Gene name provided was of type: \" + str(\n            type(gene_name)\n        )\n        # Use of dict.get(obj) returns an object or None if obj does not exist in dict\n        # bool(None) = False, bool(obj) = True\n        return bool(self.genes.get(gene_name))\n\n    def at_index(self, index: int) -&gt; List[str] | None:\n        \"\"\"\n        Returns the name of any genome features (genes, loci) at a specified genome\n            index (1-based).\n\n        Args:\n            index (int): Genome index to check for genes at.\n\n        Returns:\n            List[str] | None: list of gene_names or locus_tags at that index\n                in the genome\n\n        \"\"\"\n        assert isinstance(index, int), \"index must be an integer!\"\n        assert index &gt; 0, \"index must be a positive integer!\"\n        assert index &lt;= self.length, \"index must be less than the length of the genome!\"\n\n        mask = self.stacked_nucleotide_index == index\n\n        foo = self.stacked_gene_name[mask]\n\n        putative_genes = list(foo[foo != \"\"])\n\n        if not putative_genes:\n            return None\n        else:\n            return putative_genes\n\n    def save_sequence(self, filename=None) -&gt; None:\n        \"\"\"\n        Save the genome as a compressed NPZ file (compressed internally using gzip).\n\n        This is purely done because loading an NPZ file back into memory is FAST\n            (~200\u00b5s) so this could allow future analyses\n\n        Args:\n            filename (str): path of the output file without the file extension\n        \"\"\"\n        numpy.savez_compressed(filename, sequence=self.nucleotide_sequence)\n\n    def __build_genome_variable_length_string(self, indices: numpy.ndarray) -&gt; str:\n        \"\"\"Build a string of the genome sequence, including indels - resulting in a\n            variable length genome\n\n        Args:\n            indices (List[int]): List of the indices of indels\n\n        Returns:\n            str: Genome sequence as a string\n        \"\"\"\n        genome_string = \"\"\n        # work backwards as easier to deal with insertions/deletions when you've\n        #   already gone past them\n        for i in indices[::-1]:\n            mask = self.nucleotide_index == i\n            base = self.nucleotide_sequence[mask][0]\n            genome_string = base + genome_string\n            if self.is_indel[mask]:\n                indel_length = self.indel_length[mask][0]\n                if indel_length &gt; 0:\n                    genome_string = self.indel_nucleotides[mask][0] + genome_string\n                elif indel_length &lt; 0:\n                    genome_string = genome_string[abs(indel_length) :]\n        return genome_string\n\n    def build_genome_string(\n        self,\n        fixed_length: bool = False,\n        nucleotide_index_range: Tuple[int, int] | None = None,\n    ) -&gt; str:\n        \"\"\"\n        Generate a string of the nucleotides in the genome (positive strand if DNA).\n\n        Args:\n            fixed_length (bool): if True, then do not add insertions and deletions.\n                Default False.\n            nucleotide_index_range (tuple, ints): the 1-based positions of the sequence\n                to return with start&lt;=index&lt;end.\n\n        Returns:\n            (str): the genome as a string.\n        \"\"\"\n        # create a string of the genome\n        if fixed_length:\n            if nucleotide_index_range is not None:\n                assert isinstance(nucleotide_index_range, tuple)\n                start, end = nucleotide_index_range\n                genome_string = \"\".join(self.nucleotide_sequence[start - 1 : end - 1])\n            else:\n                genome_string = \"\".join(self.nucleotide_sequence)\n        else:\n            if nucleotide_index_range is not None:\n                start, end = nucleotide_index_range\n                genome_string = self.__build_genome_variable_length_string(\n                    self.nucleotide_index[start - 1 : end - 1]\n                )\n            else:\n                genome_string = self.__build_genome_variable_length_string(\n                    self.nucleotide_index\n                )\n\n        return genome_string\n\n    def save_fasta(\n        self,\n        filename,\n        fixed_length: bool = False,\n        nucleotide_index_range: Tuple[int, int] | None = None,\n        compression: bool = False,\n        compresslevel: int = 2,\n        chars_per_line: int = 70,\n        nucleotides_uppercase: bool = True,\n        description: str | None = None,\n        overwrite_existing: bool = True,\n    ) -&gt; None:\n        \"\"\"\n        Save the genome as a FASTA file.\n\n        Args:\n            filename (str): path of the output file\n            fixed_length (bool): If True, ignore indels and only output a genome the\n                same length as the reference but with SNPs. This is useful for\n                phylogeny analyses and relatedness. If false, a genome including indels\n                is produced. Default is false.\n            nucleotide_index_range (tuple, optional): A tuple of (start,end)\n                genome indices\n            compression (bool): If True, save compressed using gzip. (bzip2 is too slow)\n            compresslevel (0-9): the higher the number, the harder the algorithm tries\n                to compress but it takes longer. Default is 2.\n            chars_per_line (int): the number of characters per line. Default=70. Must\n                be either a positive integer or None (i.e. no CRs)\n            nucleotide_uppercase (bool): If True, provide the nucleotides in\n                UPPER CASE. Default is True.\n            description (str, optional): what to write on the header line of the FASTA\n                file. If not provided, then a description will be automatically\n                generated from the GenBank file metadata.\n            overwrite_existing (bool): If False, then the code will refuse to overwrite\n                a FASTA file already on disc. Default is True.\n        \"\"\"\n\n        # check the arguments are well formed\n        if not overwrite_existing:\n            assert not pathlib.Path(filename).is_file(), (\n                \"filename already exists! \" + filename\n            )\n        assert isinstance(compression, bool)\n        assert isinstance(fixed_length, bool)\n        assert isinstance(nucleotides_uppercase, bool)\n        assert isinstance(chars_per_line, int)\n        if nucleotide_index_range is not None:\n            assert isinstance(nucleotide_index_range, tuple)\n            assert isinstance(nucleotide_index_range[0], int)\n            assert isinstance(nucleotide_index_range[1], int)\n            assert (\n                nucleotide_index_range[0] &gt;= 1\n            ), \"genomes are 1-based so the first base must be &gt;=1\"\n            assert nucleotide_index_range[1] &lt; self.length, \"longer than the genome!\"\n        assert compresslevel in range(1, 10), \"compresslevel must be in range 1-9!\"\n        assert (\n            chars_per_line &gt; 0\n        ), \"number of characters per line in the FASTA file must be a positive integer!\"\n        if description is not None:\n            assert isinstance(description, str)\n\n        # check the specified fileextension to see if the FASTA file needs compressing\n        if compression:\n            OUTPUT = gzip.open(filename + \".gz\", \"wb\", compresslevel=compresslevel)\n        else:\n            OUTPUT = open(filename, \"w\")\n\n        # create the header line for the FASTA file using \"|\" as delimiters\n        header = \"&gt;\"\n        if description is None:\n            if hasattr(self, \"name\"):\n                header += self.name + \"|\"\n            if hasattr(self, \"id\") and isinstance(self.id, str) and len(self.id) &gt; 0:\n                header += self.id + \"|\"\n            if (\n                hasattr(self, \"description\")\n                and isinstance(self.description, str)\n                and len(self.description) &gt; 0\n            ):\n                header += self.description + \"|\"\n            header = header[:-1]\n        else:\n            header += description\n        header += \"\\n\"\n\n        genome_string = self.build_genome_string(fixed_length, nucleotide_index_range)\n\n        # insert carriage returns so it looks pretty in the file...\n        output_string = self.__insert_newlines(genome_string, every=chars_per_line)\n        output_string += \"\\n\"\n\n        # set the case accordingly\n        if nucleotides_uppercase:\n            output_string = output_string.upper()\n        else:\n            output_string = output_string.lower()\n\n        # write out the FASTA files\n        if compression:\n            OUTPUT.write(str.encode(header))\n            OUTPUT.write(str.encode(output_string))\n        else:\n            OUTPUT.write(header)\n            OUTPUT.write(output_string)\n\n        OUTPUT.close()\n\n    def __add_empty_row(self, array: numpy.ndarray) -&gt; numpy.ndarray:\n        \"\"\"\n        Private function to add an empty row of the correct type to a numpy array\n        Args:\n            array (numpy.ndarray) : Array to add an empty row to\n        Returns:\n            (numpy.ndarray): The same array with an empty row of the same length and\n                dtype appended\n        \"\"\"\n\n        empty_row = numpy.zeros((1, array.shape[1]), dtype=array.dtype)\n\n        return numpy.vstack((array, empty_row))\n\n    def __parse_genbank_file(self, genbank_file: pathlib.Path) -&gt; None:\n        \"\"\"\n        Private function to parse a genbank file\n        Args:\n            genbank_file (Path) : pathlib.Path object of the genbank file\n        \"\"\"\n\n        if genbank_file.suffix == \".gz\":\n            file_handle = gzip.open(genbank_file, \"rt\")\n        elif genbank_file.suffix == \".gbk\":\n            file_handle = open(genbank_file, \"rt\")\n\n        reference_genome = SeqIO.read(file_handle, \"genbank\")\n\n        # convert to a numpy array at the first opportunity since slicing BioPython\n        #   is between 10 and 50,000 times slower!\n        self.nucleotide_sequence = numpy.array(\n            [i.lower() for i in str(reference_genome.seq)]\n        )\n\n        self.name = reference_genome.name\n        self.id = reference_genome.id\n        self.description = reference_genome.description\n\n        # store the length of the genome\n        self.length = len(self.nucleotide_sequence)\n\n        assert self.length &gt; 0, \"genome length zero!\"\n\n        # create an array of the genome indices\n        self.nucleotide_index = numpy.arange(1, self.length + 1, dtype=\"int\")\n\n        self.stacked_gene_name = numpy.zeros(\n            (1, self.length), dtype=\"&lt;U\" + str(int(self.max_gene_name_length))\n        )\n        self.stacked_is_cds = numpy.zeros((1, self.length), dtype=bool)\n        self.stacked_is_promoter = numpy.zeros((1, self.length), dtype=bool)\n        self.stacked_nucleotide_number = numpy.zeros((1, self.length), dtype=\"int\")\n        self.stacked_is_reverse_complement = numpy.zeros((1, self.length), dtype=bool)\n\n        self.is_indel = numpy.zeros(self.length, dtype=bool)\n        self.indel_length = numpy.zeros(self.length, int)\n        self.indel_nucleotides = numpy.empty(self.length, dtype=object)\n\n        assert (\n            len(reference_genome.annotations[\"accessions\"]) == 1\n        ), \"only GenBank files with a single accessions currently allowed\"\n\n        self.annotations = {}\n        for i in reference_genome.annotations.keys():\n            self.annotations[i] = reference_genome.annotations[i]\n\n        self.genes: Dict = {}\n\n        # loop through the features listed in the GenBank File\n        if self.verbose:\n            print(\"Iterating through features in GenBank file...\")\n\n        for record in tqdm(\n            reference_genome.features, disable=(not self.show_progress_bar)\n        ):\n            # only parse coding sequences and rRNA features\n            if record.type not in [\"CDS\", \"rRNA\"]:\n                continue\n\n            gene_name = None\n            type_ = None\n            codes_protein = True\n\n            # try and use the gene name if available, otherwise use the locus\n            if \"gene\" in record.qualifiers.keys():\n                gene_name = record.qualifiers[\"gene\"][0]\n                type_ = \"GENE\"\n\n            elif \"locus_tag\" in record.qualifiers.keys():\n                gene_name = record.qualifiers[\"locus_tag\"][0]\n                type_ = \"LOCUS\"\n\n            if gene_name is None or (\n                self.gene_subset is not None and gene_name not in self.gene_subset\n            ):\n                continue\n\n            # if this is ribosomal RNA, then record as such\n            if record.type == \"rRNA\":\n                type_ = \"RNA\"\n                codes_protein = False\n\n            # determine if this is a reverse complement gene (only relevant to\n            #   dsDNA genomes)\n            rev_comp = True if record.strand == -1 else False\n\n            # sigh, you can't assume that a gene_name is unique in a GenBank file\n            # this only allows for duplicates though.\n            # duplicates of duplicates will be foo_2_2\n            gene_name += \"_2\" if gene_name in self.genes.keys() else \"\"\n\n            # check the gene_name will fit in the max gene name length\n            assert len(gene_name) &lt;= self.max_gene_name_length, (\n                \"Gene \"\n                + gene_name\n                + \" is too long at \"\n                + str(len(gene_name))\n                + \" chars; need to specify max_gene_name_length\"\n            )\n\n            # note that BioPython \"helpfully\" turns these from 1-based into 0-based\n            #   coordinates, hence the +1\n            # gene_end has also been incremented by 1 so that slicing naturally works\n            gene_start = int(record.location.start) + 1\n            gene_end = int(record.location.end) + 1\n\n            # Check for ribosomal shift\n            # This happens when a start position &lt; end position\n            positions = [\n                (int(loc.start), int(loc.end)) for loc in record.location.parts\n            ]\n            shifts = []\n            # Check for -1 PFS\n            if len(positions) &gt; 1 and positions[0][1] &gt; positions[1][0]:\n                shifts.append(positions[1][0] - gene_start + 1)\n\n            # record feature metadata in a dict\n            self.genes[gene_name] = {\n                \"reverse_complement\": rev_comp,\n                \"type\": type_,\n                \"codes_protein\": codes_protein,\n                \"start\": gene_start,\n                \"end\": gene_end,\n                \"ribosomal_shifts\": shifts,\n            }\n\n        # now we can check that all the genes in the gene_subset exist in the\n        #   GenBank file!\n        if self.gene_subset is not None:\n            for i in self.gene_subset:\n                assert self.contains_gene(i), (\n                    \"Gene \" + i + \" not found in the Genbank file!\"\n                )\n\n    def __handle_rev_comp(self, rev_comp: bool, start: int, end: int, i: int) -&gt; None:\n        \"\"\"\n        Private function to handle the rev-comp changes required\n        Args:\n            rev_comp (bool) : Boolean to show if rev-comp is required\n            start (int) : Start index of the gene\n            end (int) : End index of the gene\n            i (int) : The index of the stacked row\n        \"\"\"\n        # Check if the arrays have the correct number of rows and add as required\n        while len(self.stacked_nucleotide_number) &lt;= i:\n            self.stacked_is_cds = self.__add_empty_row(self.stacked_is_cds)\n            self.stacked_is_reverse_complement = self.__add_empty_row(\n                self.stacked_is_reverse_complement\n            )\n            self.stacked_is_promoter = self.__add_empty_row(self.stacked_is_promoter)\n            self.stacked_nucleotide_number = self.__add_empty_row(\n                self.stacked_nucleotide_number\n            )\n        # Update the required items for rev_comp\n        # Use of array slicing here introduces speedups as not all of the array should\n        #   be considered\n        # (Previous method applied a mask which requires full array consideration\n        #   rather than direct access)\n        if rev_comp:\n            self.stacked_nucleotide_number[i][start - 1 : end - 1] = numpy.mod(\n                -1 * (self.nucleotide_index[start - 1 : end - 1] - end), self.length\n            )\n            self.stacked_is_reverse_complement[i][start - 1 : end - 1] = True\n        else:\n            self.stacked_nucleotide_number[i][start - 1 : end - 1] = numpy.mod(\n                1 + self.nucleotide_index[start - 1 : end - 1] - start, self.length\n            )\n\n    def __fit_gene(\n        self,\n        mask: numpy.ndarray,\n        genes: numpy.ndarray,\n        genes_mask: numpy.ndarray,\n        start: int,\n        end: int,\n        gene_name: str,\n        rev_comp: bool,\n    ) -&gt; Tuple[numpy.ndarray, numpy.ndarray, int]:\n        \"\"\"\n        Private function to fit a gene into the genes based on the dot product of\n            the masks numpy.dot([bool], [bool])-&gt; bool showing if there are collisions\n            of True values within args. This takes 10^-5 seconds which is a significant\n            improvement on use of numpy.all() iteration of 10^-2 seconds for TB\n            length genome\n\n        Args:\n            mask (numpy.ndarray) : Boolean array showing positions where the gene lies\n            genes (numpy.ndarray) : 2D numpy array of the format used for all stacked\n                values\n            genes_mask (numpy.ndarray) : The corresponding boolean mask arrays for the\n                `genes` arg\n            start (int) : Start index of the gene\n            end (int) : End index of the gene\n            gene_name (str) : Name of the gene\n            rev_comp (bool) : Boolean to show whether the gene required a\n                reverse complement\n\n        Returns:\n            (numpy_array) : Updated genes_mask array\n            (numpy_array) : Updated genes array\n        \"\"\"\n\n        for i, row in enumerate(genes_mask):\n            # use of the dot product of masks allows determining if a gene will fit\n            #   in an array\n            # Disable ruff here as `is False` doesn't work here\n            if numpy.dot(row, mask) == False:  # noqa: E712\n                # there is no collision with this row so add the row\n                # start/end have to be adjusted to account for 0 indexing of arrays and\n                #   1 indexing of genetics\n                row[start - 1 : end - 1] = True\n                genes[i][start - 1 : end - 1] = gene_name\n                self.__handle_rev_comp(rev_comp, start, end, i)\n                return genes_mask, genes, i\n\n        # if this point is reached, there has been no rows without collisions, so\n        #   add one\n        genes_mask = numpy.vstack((genes_mask, mask))\n        new_row = numpy.array([gene_name if m else \"\" for m in mask])\n        genes = numpy.vstack((genes, new_row))\n        i += 1\n        self.__handle_rev_comp(rev_comp, start, end, i)\n        return genes_mask, genes, i\n\n    def __find_overlaps(self):\n        \"\"\"\n        Private function to find the sections of the genome in which there are\n            overlapping genes. This should be more efficient than the older version\n            as it avoids consistent genome iteration. Use of the dot product on boolean\n            arrays returns a single boolean showing collisions in almost constant time\n            (10^-5 secs for TB size). This can be used to determine which row the gene\n            should be in\n        \"\"\"\n\n        # Boolean mask to show gene presence at indicies (default to all False values)\n        genes_mask = numpy.array([numpy.array([False for x in range(self.length)])])\n\n        # gene names\n        genes = numpy.array(\n            [numpy.array([\"\" for x in range(self.length)])],\n            dtype=\"U\" + str(self.max_gene_name_length),\n        )\n\n        # dict to pull out row indicies for each gene in the stacked arrays\n        self.gene_rows = dict()\n\n        if self.verbose:\n            print(\"Finding overlaps...\")\n\n        for gene_name in tqdm(self.genes, disable=(not self.show_progress_bar)):\n            # get the start/end/rev_comp values\n            start = self.genes[gene_name][\"start\"]\n            end = self.genes[gene_name][\"end\"]\n            rev_comp = self.genes[gene_name][\"reverse_complement\"]\n\n            # determine the boolean mask for this gene\n            mask = (self.nucleotide_index &gt;= start) &amp; (self.nucleotide_index &lt; end)\n\n            # fit the gene into the stacked arrays\n            genes_mask, genes, row = self.__fit_gene(\n                mask, genes, genes_mask, start, end, gene_name, rev_comp\n            )\n            self.gene_rows[gene_name] = row\n\n        # Singular array to determine if there are genes in places within the genome\n        self.genes_mask = numpy.any(genes_mask, axis=0)\n\n        # Set instance variable for the gene names\n        self.stacked_gene_name = genes\n\n    def __setup_arrays(self):\n        \"\"\"\n        Private function to initalise all of the required arrays, fitting the gene\n            names into the correct places within stacked arrays\n        \"\"\"\n        self.__find_overlaps()\n\n        # do as many assignments outside the loop, i.e. in one go to improve performance\n        self.stacked_is_cds = self.stacked_gene_name != \"\"\n\n        self.n_rows = self.stacked_gene_name.shape[0]\n\n        self.stacked_nucleotide_index = numpy.tile(\n            self.nucleotide_index, (self.n_rows, 1)\n        )\n\n        self.stacked_nucleotide_sequence = numpy.tile(\n            self.nucleotide_sequence, (self.n_rows, 1)\n        )\n\n        # Use a list to track minority populations\n        self.minor_populations = []\n\n        # Track which nucleotides are deleted\n        self.is_deleted = numpy.array([False for i in self.nucleotide_index])\n\n        # Use a dict to track VCF evidence as req\n        self.vcf_evidence = dict()\n\n    def __assign_promoter_regions(self):\n        \"\"\"\n        Private function to assign promoter regions to genes\n        \"\"\"\n        assert isinstance(\n            self.max_promoter_length, int\n        ), \"max_promoter_length must be an integer!\"\n\n        assert (\n            self.max_promoter_length &gt; 0\n        ), \"max_promoter_length must be greater than zero\"\n\n        # labelling promoters is a difficult problem since\n        #  (i)  it is arbitrary and\n        #  (ii) we need to ensure that only unassigned bases can be labelled as\n        #   promoters and each should only 'belong' to a single feature\n        # the latter is especially difficult when you have two genes next to one\n        #   another, one reverse complement, since their promoters can 'fight' for\n        #   space. It is this problem that means we have to grow each promoter out\n        #   one base at a time\n\n        # populate a dictionary to store the starts/ends of genes as they grow\n        #   with promoters\n        start_end = {\n            gene_name: {\n                \"start\": self.genes[gene_name][\"start\"],\n                \"end\": self.genes[gene_name][\"end\"],\n            }\n            for gene_name in self.genes\n        }\n        if self.verbose:\n            print(\"Assigning promoters...\")\n\n        for promoter in tqdm(\n            range(1, self.max_promoter_length + 1), disable=(not self.show_progress_bar)\n        ):\n            # Replacement `start_end` because dictionaries can't be changed during\n            #   iteration\n            new_start_end = dict()\n            for gene_name in start_end:\n                # Get the associated start/end\n                start = start_end[gene_name][\"start\"]\n                end = start_end[gene_name][\"end\"]\n                rev_comp = self.genes[gene_name][\"reverse_complement\"]\n                # Check if the region which the gene would grow into is empty\n                if rev_comp:\n                    # Indexing is weird so stacked_array[i][end-2] is the end of\n                    #   the gene making stacked_array[i][end-1] the next item on\n                    #   the right\n                    if end == len(self.nucleotide_sequence):\n                        # If the end would be out of range, loop back around to\n                        #   position 0\n                        end = 0\n                    pos = end - 1\n                else:\n                    # Similar indexing issue except indexing starts on start-1\n                    #   so start-2 is the next item on the left\n                    pos = start - 2\n                # Disable ruff for this line as `is True` doesn't work here\n                if self.genes_mask[pos] == True:  # noqa: E712\n                    # There is a gene here already so skip it\n                    continue\n                else:\n                    # This position is free so set the appropriate values\n                    new_start_end[gene_name] = start_end[\n                        gene_name\n                    ]  # Retain gene for future expansions\n                    # Get the row index for stacked arrays\n                    row = self.gene_rows[gene_name]\n\n                    # Set appropriate values\n                    self.stacked_gene_name[row][pos] = gene_name\n                    self.stacked_nucleotide_number[row][pos] = -1 * promoter\n                    self.stacked_is_reverse_complement[row][pos] = rev_comp\n                    self.stacked_is_promoter[row][pos] = True\n                    self.genes_mask[pos] = True\n\n                    # move the start/end values appropriately\n                    if rev_comp:\n                        new_start_end[gene_name][\"end\"] = end + 1\n                    else:\n                        new_start_end[gene_name][\"start\"] = start - 1\n            start_end = new_start_end\n\n    def __insert_newlines(self, string: str, every=70) -&gt; str:\n        \"\"\"\n        Simple private method for inserting a carriage return every N characters into\n            a long string.\n\n        Args:\n            string (str): the string to insert carriage returns\n            every (int): how many characters between each carriage return\n\n        Returns:\n            str: Same string with \"\\n\" characters inserted\n        \"\"\"\n\n        assert every &gt; 0, \"every must be an integer greater than zero\"\n\n        assert len(string) &gt; 1, \"string is too short!\"\n\n        return \"\\n\".join(string[i : i + every] for i in range(0, len(string), every))\n\n    def build_gene(self, gene: str) -&gt; Gene:\n        \"\"\"\n        Public function to build the gumpy.Gene object\n\n        Args:\n            gene (str) : The name of the gene\n\n        Returns:\n            gumpy.Gene : The instanciated gene object.\n        \"\"\"\n\n        # The mask for all stacked arrays (N-dim)\n        stacked_mask = self.stacked_gene_name == gene\n\n        # The mask for singular arrays (1-dim) by collapsing stacked mask to 1-dim\n        mask = numpy.any(stacked_mask, axis=0)\n\n        # check that the genome does contain the gene name\n        assert numpy.count_nonzero(mask) &gt; 0, \"gene (\" + gene + \") not found in genome!\"\n\n        # Revert is_cds to all False if this gene is non-coding\n        # Easier to do it like this than to mess with masking\n        nucleotide_seq = self.nucleotide_sequence[mask]\n        if not self.genes[gene][\"codes_protein\"]:\n            is_cd = numpy.array([False for i in range(len(nucleotide_seq))])\n        else:\n            is_cd = self.stacked_is_cds[stacked_mask]\n\n        gene_nucleotides = self.nucleotide_index[mask]\n        gene_minor_populations = []\n        for population in self.minor_populations:\n            if population[0] in gene_nucleotides:\n                # This minor population is within the gene\n                gene_minor_populations.append(population)\n\n        vcf_evidence = {\n            idx: self.vcf_evidence[idx]\n            for idx in self.vcf_evidence.keys()\n            if idx in gene_nucleotides\n        }\n\n        # instantiate a Gene object\n        g = Gene(\n            gene,\n            nucleotide_seq,\n            gene_nucleotides,\n            self.stacked_nucleotide_number[stacked_mask],\n            is_cd,\n            self.stacked_is_promoter[stacked_mask],\n            self.is_indel[mask],\n            self.indel_length[mask],\n            self.indel_nucleotides[mask],\n            self.genes[gene][\"reverse_complement\"],\n            self.genes[gene][\"codes_protein\"],\n            self.genes[gene][\"type\"],\n            self.genes[gene][\"ribosomal_shifts\"],\n            gene_minor_populations,\n            self.is_deleted[mask],\n            vcf_evidence,\n        )\n\n        return g\n\n    def __assign_deleted(self, genome) -&gt; None:\n        \"\"\"Assign a boolean array of which nucleotides are deleted by indels.\n        This holds the same 1-1 relationship as nucleotide_index &lt;-&gt; nucleotide_sequence\n\n        Args:\n            genome (gumpy.Genome): Genome to apply this to\n        \"\"\"\n        marking = 0\n        current_evidence = None\n        for idx, length in enumerate(genome.indel_length):\n            if length &lt; 0:\n                # We found a deletion, so mark the next N bases as deleted\n                # Deletions are -N here\n                marking -= length\n                current_evidence = genome.vcf_evidence[genome.nucleotide_index[idx]]\n\n            if marking &gt; 0:\n                # We mark this as deleted\n                genome.is_deleted[idx] = True\n                # Update evidence too so we can pull out VCF rows from downstream genes\n                genome.vcf_evidence[genome.nucleotide_index[idx]] = current_evidence\n                marking -= 1\n\n    def __add__(self, vcf: VCFFile):\n        \"\"\"Function to apply a VCF file to the genome  - producing a replica genome\n             the specified changes\n\n        Args:\n            vcf (gumpy.VCFFile): The VCFFile object for the VCF\n\n        Returns:\n            gumpy.Genome: The resulting Genome object\n        \"\"\"\n\n        assert isinstance(vcf, VCFFile), \"RHS must be a gumpy.VCFFile object!\"\n\n        assert isinstance(\n            vcf.calls, dict\n        ), \"something wrong with the gumpy.VCFFile object!\"\n\n        indices = [i[0] for i in vcf.calls.keys()]\n        if len(indices) &gt; 0:\n            # It's possible that a VCF only details minority populations, and max()\n            #   complains for empty\n            assert (\n                max(indices) &lt;= self.length\n            ), \"The VCF file details changes outside of this genome!\"\n\n        if len(self.minor_populations) &gt; 0 and len(vcf.minor_population_indices) &gt; 0:\n            # Both this genome and the VCF have minor populations so for simplicity\n            #   atm, complain\n            raise Exception(\n                \"Both the existing Genome and the VCF have minor populations!\"\n            )\n\n        if self.verbose:\n            print(\"Copying the genome...\")\n\n        # Replicate this Genome object\n        genome = copy.deepcopy(self)\n\n        \"\"\"\n        Using numpy's fancy array indexing may provide neat code, and provides some \n            speed in some cases, the constant time access of a standard dictionary \n            results in faster code when the mask only contains a few True values.\n\n        For TB length arrays with a ~0.1% True mask, applying a mask takes ~10^-3s\n            Applying a dictionary to the same array takes ~10^-4s\n\n        ~0.1% True mask is a reasonable amount for this task as a VCF file \n            is ~4000 entries\n        \"\"\"\n\n        if self.verbose:\n            print(\"Updating the genome...\")\n\n        # use the calls dict to change the nucleotide indicies in the copy of the genome\n        for idx, type_ in tqdm(vcf.calls.keys(), disable=(not self.show_progress_bar)):\n            for item in vcf.calls[(idx, type_)]:\n                genome.vcf_evidence[genome.nucleotide_index[idx - 1]] = item[\n                    \"original_vcf_row\"\n                ]\n\n                # deal with changes at a single nucleotide site\n                if type_ in [\"snp\", \"null\", \"het\"]:\n                    # only set values if the idx is to a single nucleotide\n                    genome.nucleotide_sequence[idx - 1] = item[\"call\"]\n\n                # deal with insertions and deletions\n                elif type_ == \"indel\":\n                    genome.is_indel[idx - 1] = True\n                    genome.indel_nucleotides[idx - 1] = item[\"call\"][1]\n\n                    if item[\"call\"][0] == \"ins\":\n                        genome.indel_length[idx - 1] = len(item[\"call\"][1])\n                    else:\n                        genome.indel_length[idx - 1] = -1 * len(item[\"call\"][1])\n\n                elif type_ == \"ref\":\n                    # These only exist due to reference calls\n                    # They only made it this far as they are required to pull\n                    # out minors at these positions\n                    pass\n\n        genome.minor_populations = []\n\n        for minor in vcf.minor_populations:\n            # Ensure that the VCF evidence for these is also recorded correctly\n            pos = minor[0]\n            evidence = minor[5]\n\n            # Store the VCF evidence of this\n            genome.vcf_evidence[genome.nucleotide_index[pos - 1]] = evidence\n\n            # Don't keep the VCF evidence with this, as it is already stored in the\n            #   main vcf_evidence dict\n            genome.minor_populations.append(minor[:5])\n\n        genome.vcf_file = vcf\n\n        # Let's assign some deleted regions (if exist)\n        self.__assign_deleted(genome)\n\n        # the genome has been altered so not a reference genome\n        genome.is_reference = False\n\n        return genome\n\n    def minority_populations_GARC(\n        self, interpretation: str = \"reads\", reference=None\n    ) -&gt; List[str]:\n        \"\"\"Get the variants in GARC of the minority populations for this genome.\n        Whether the variants are given in terms of reads or read percentage is\n            controlled by `interpretation`\n\n        Args:\n            interpretation (str, optional): Which interpretation to use. `reads` for\n                number of reads for this population. `percentage` for the decimal\n                percentage of total reads for this population. Defaults to 'reads'.\n            reference (gumpy.Genome, optional): The reference to denote mutations from.\n                Defaults to self\n        Returns:\n            List[str]: List of the variants in GARC\n        \"\"\"\n        # Use the interpretation type to pull out which index of the minor_populations\n        # Each item of minor_populations is (pos, type, bases, abs_coverage,\n        #   percent_coverage)\n        if interpretation == \"percentage\":\n            coverage = 4\n        else:\n            coverage = 3\n\n        if reference is None:\n            reference = self\n        else:\n            # Ensure that only one of the two Genomes has minor populations\n            assert len(reference.minor_populations) == 0, (\n                \"Minority populations can only be compared when 1 Genome \"\n                \"does not have them!\"\n            )\n\n        variants = []\n        for minor in self.minor_populations:\n            pos = minor[0]\n            type_ = minor[1]\n            bases = minor[2]\n            depth = minor[coverage]\n\n            if type_ in [\"ref\", \"snp\"]:\n                # These are functionally the same\n                for i, (r, alt) in enumerate(zip(*bases)):\n                    ref = reference.nucleotide_sequence[\n                        reference.nucleotide_index == pos + i\n                    ][0]\n                    variants.append(f\"{pos+i}{ref}&gt;{alt}:{depth}\")\n            else:\n                # Indels are the same too\n                variants.append(f\"{pos}_{type_}_{bases}:{depth}\")\n\n        return sorted(variants)\n</code></pre>"},{"location":"reference/genome/#genome.Genome.__add__","title":"<code>__add__(vcf)</code>","text":"<p>Function to apply a VCF file to the genome  - producing a replica genome      the specified changes</p> <p>Parameters:</p> Name Type Description Default <code>vcf</code> <code>VCFFile</code> <p>The VCFFile object for the VCF</p> required <p>Returns:</p> Type Description <p>gumpy.Genome: The resulting Genome object</p> Source code in <code>gumpy/genome.py</code> <pre><code>def __add__(self, vcf: VCFFile):\n    \"\"\"Function to apply a VCF file to the genome  - producing a replica genome\n         the specified changes\n\n    Args:\n        vcf (gumpy.VCFFile): The VCFFile object for the VCF\n\n    Returns:\n        gumpy.Genome: The resulting Genome object\n    \"\"\"\n\n    assert isinstance(vcf, VCFFile), \"RHS must be a gumpy.VCFFile object!\"\n\n    assert isinstance(\n        vcf.calls, dict\n    ), \"something wrong with the gumpy.VCFFile object!\"\n\n    indices = [i[0] for i in vcf.calls.keys()]\n    if len(indices) &gt; 0:\n        # It's possible that a VCF only details minority populations, and max()\n        #   complains for empty\n        assert (\n            max(indices) &lt;= self.length\n        ), \"The VCF file details changes outside of this genome!\"\n\n    if len(self.minor_populations) &gt; 0 and len(vcf.minor_population_indices) &gt; 0:\n        # Both this genome and the VCF have minor populations so for simplicity\n        #   atm, complain\n        raise Exception(\n            \"Both the existing Genome and the VCF have minor populations!\"\n        )\n\n    if self.verbose:\n        print(\"Copying the genome...\")\n\n    # Replicate this Genome object\n    genome = copy.deepcopy(self)\n\n    \"\"\"\n    Using numpy's fancy array indexing may provide neat code, and provides some \n        speed in some cases, the constant time access of a standard dictionary \n        results in faster code when the mask only contains a few True values.\n\n    For TB length arrays with a ~0.1% True mask, applying a mask takes ~10^-3s\n        Applying a dictionary to the same array takes ~10^-4s\n\n    ~0.1% True mask is a reasonable amount for this task as a VCF file \n        is ~4000 entries\n    \"\"\"\n\n    if self.verbose:\n        print(\"Updating the genome...\")\n\n    # use the calls dict to change the nucleotide indicies in the copy of the genome\n    for idx, type_ in tqdm(vcf.calls.keys(), disable=(not self.show_progress_bar)):\n        for item in vcf.calls[(idx, type_)]:\n            genome.vcf_evidence[genome.nucleotide_index[idx - 1]] = item[\n                \"original_vcf_row\"\n            ]\n\n            # deal with changes at a single nucleotide site\n            if type_ in [\"snp\", \"null\", \"het\"]:\n                # only set values if the idx is to a single nucleotide\n                genome.nucleotide_sequence[idx - 1] = item[\"call\"]\n\n            # deal with insertions and deletions\n            elif type_ == \"indel\":\n                genome.is_indel[idx - 1] = True\n                genome.indel_nucleotides[idx - 1] = item[\"call\"][1]\n\n                if item[\"call\"][0] == \"ins\":\n                    genome.indel_length[idx - 1] = len(item[\"call\"][1])\n                else:\n                    genome.indel_length[idx - 1] = -1 * len(item[\"call\"][1])\n\n            elif type_ == \"ref\":\n                # These only exist due to reference calls\n                # They only made it this far as they are required to pull\n                # out minors at these positions\n                pass\n\n    genome.minor_populations = []\n\n    for minor in vcf.minor_populations:\n        # Ensure that the VCF evidence for these is also recorded correctly\n        pos = minor[0]\n        evidence = minor[5]\n\n        # Store the VCF evidence of this\n        genome.vcf_evidence[genome.nucleotide_index[pos - 1]] = evidence\n\n        # Don't keep the VCF evidence with this, as it is already stored in the\n        #   main vcf_evidence dict\n        genome.minor_populations.append(minor[:5])\n\n    genome.vcf_file = vcf\n\n    # Let's assign some deleted regions (if exist)\n    self.__assign_deleted(genome)\n\n    # the genome has been altered so not a reference genome\n    genome.is_reference = False\n\n    return genome\n</code></pre>"},{"location":"reference/genome/#genome.Genome.__add_empty_row","title":"<code>__add_empty_row(array)</code>","text":"<p>Private function to add an empty row of the correct type to a numpy array Args:     array (numpy.ndarray) : Array to add an empty row to Returns:     (numpy.ndarray): The same array with an empty row of the same length and         dtype appended</p> Source code in <code>gumpy/genome.py</code> <pre><code>def __add_empty_row(self, array: numpy.ndarray) -&gt; numpy.ndarray:\n    \"\"\"\n    Private function to add an empty row of the correct type to a numpy array\n    Args:\n        array (numpy.ndarray) : Array to add an empty row to\n    Returns:\n        (numpy.ndarray): The same array with an empty row of the same length and\n            dtype appended\n    \"\"\"\n\n    empty_row = numpy.zeros((1, array.shape[1]), dtype=array.dtype)\n\n    return numpy.vstack((array, empty_row))\n</code></pre>"},{"location":"reference/genome/#genome.Genome.__assign_deleted","title":"<code>__assign_deleted(genome)</code>","text":"<p>Assign a boolean array of which nucleotides are deleted by indels. This holds the same 1-1 relationship as nucleotide_index &lt;-&gt; nucleotide_sequence</p> <p>Parameters:</p> Name Type Description Default <code>genome</code> <code>Genome</code> <p>Genome to apply this to</p> required Source code in <code>gumpy/genome.py</code> <pre><code>def __assign_deleted(self, genome) -&gt; None:\n    \"\"\"Assign a boolean array of which nucleotides are deleted by indels.\n    This holds the same 1-1 relationship as nucleotide_index &lt;-&gt; nucleotide_sequence\n\n    Args:\n        genome (gumpy.Genome): Genome to apply this to\n    \"\"\"\n    marking = 0\n    current_evidence = None\n    for idx, length in enumerate(genome.indel_length):\n        if length &lt; 0:\n            # We found a deletion, so mark the next N bases as deleted\n            # Deletions are -N here\n            marking -= length\n            current_evidence = genome.vcf_evidence[genome.nucleotide_index[idx]]\n\n        if marking &gt; 0:\n            # We mark this as deleted\n            genome.is_deleted[idx] = True\n            # Update evidence too so we can pull out VCF rows from downstream genes\n            genome.vcf_evidence[genome.nucleotide_index[idx]] = current_evidence\n            marking -= 1\n</code></pre>"},{"location":"reference/genome/#genome.Genome.__assign_promoter_regions","title":"<code>__assign_promoter_regions()</code>","text":"<p>Private function to assign promoter regions to genes</p> Source code in <code>gumpy/genome.py</code> <pre><code>def __assign_promoter_regions(self):\n    \"\"\"\n    Private function to assign promoter regions to genes\n    \"\"\"\n    assert isinstance(\n        self.max_promoter_length, int\n    ), \"max_promoter_length must be an integer!\"\n\n    assert (\n        self.max_promoter_length &gt; 0\n    ), \"max_promoter_length must be greater than zero\"\n\n    # labelling promoters is a difficult problem since\n    #  (i)  it is arbitrary and\n    #  (ii) we need to ensure that only unassigned bases can be labelled as\n    #   promoters and each should only 'belong' to a single feature\n    # the latter is especially difficult when you have two genes next to one\n    #   another, one reverse complement, since their promoters can 'fight' for\n    #   space. It is this problem that means we have to grow each promoter out\n    #   one base at a time\n\n    # populate a dictionary to store the starts/ends of genes as they grow\n    #   with promoters\n    start_end = {\n        gene_name: {\n            \"start\": self.genes[gene_name][\"start\"],\n            \"end\": self.genes[gene_name][\"end\"],\n        }\n        for gene_name in self.genes\n    }\n    if self.verbose:\n        print(\"Assigning promoters...\")\n\n    for promoter in tqdm(\n        range(1, self.max_promoter_length + 1), disable=(not self.show_progress_bar)\n    ):\n        # Replacement `start_end` because dictionaries can't be changed during\n        #   iteration\n        new_start_end = dict()\n        for gene_name in start_end:\n            # Get the associated start/end\n            start = start_end[gene_name][\"start\"]\n            end = start_end[gene_name][\"end\"]\n            rev_comp = self.genes[gene_name][\"reverse_complement\"]\n            # Check if the region which the gene would grow into is empty\n            if rev_comp:\n                # Indexing is weird so stacked_array[i][end-2] is the end of\n                #   the gene making stacked_array[i][end-1] the next item on\n                #   the right\n                if end == len(self.nucleotide_sequence):\n                    # If the end would be out of range, loop back around to\n                    #   position 0\n                    end = 0\n                pos = end - 1\n            else:\n                # Similar indexing issue except indexing starts on start-1\n                #   so start-2 is the next item on the left\n                pos = start - 2\n            # Disable ruff for this line as `is True` doesn't work here\n            if self.genes_mask[pos] == True:  # noqa: E712\n                # There is a gene here already so skip it\n                continue\n            else:\n                # This position is free so set the appropriate values\n                new_start_end[gene_name] = start_end[\n                    gene_name\n                ]  # Retain gene for future expansions\n                # Get the row index for stacked arrays\n                row = self.gene_rows[gene_name]\n\n                # Set appropriate values\n                self.stacked_gene_name[row][pos] = gene_name\n                self.stacked_nucleotide_number[row][pos] = -1 * promoter\n                self.stacked_is_reverse_complement[row][pos] = rev_comp\n                self.stacked_is_promoter[row][pos] = True\n                self.genes_mask[pos] = True\n\n                # move the start/end values appropriately\n                if rev_comp:\n                    new_start_end[gene_name][\"end\"] = end + 1\n                else:\n                    new_start_end[gene_name][\"start\"] = start - 1\n        start_end = new_start_end\n</code></pre>"},{"location":"reference/genome/#genome.Genome.__build_genome_variable_length_string","title":"<code>__build_genome_variable_length_string(indices)</code>","text":"<p>Build a string of the genome sequence, including indels - resulting in a     variable length genome</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>List[int]</code> <p>List of the indices of indels</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Genome sequence as a string</p> Source code in <code>gumpy/genome.py</code> <pre><code>def __build_genome_variable_length_string(self, indices: numpy.ndarray) -&gt; str:\n    \"\"\"Build a string of the genome sequence, including indels - resulting in a\n        variable length genome\n\n    Args:\n        indices (List[int]): List of the indices of indels\n\n    Returns:\n        str: Genome sequence as a string\n    \"\"\"\n    genome_string = \"\"\n    # work backwards as easier to deal with insertions/deletions when you've\n    #   already gone past them\n    for i in indices[::-1]:\n        mask = self.nucleotide_index == i\n        base = self.nucleotide_sequence[mask][0]\n        genome_string = base + genome_string\n        if self.is_indel[mask]:\n            indel_length = self.indel_length[mask][0]\n            if indel_length &gt; 0:\n                genome_string = self.indel_nucleotides[mask][0] + genome_string\n            elif indel_length &lt; 0:\n                genome_string = genome_string[abs(indel_length) :]\n    return genome_string\n</code></pre>"},{"location":"reference/genome/#genome.Genome.__convert_references","title":"<code>__convert_references()</code>","text":"<p>Convert BIOPython Reference objects to normal dictionaries. They do not appear to have any greater application than storing structured data, so removing the object wrappers appears to be a clean way to combat the object's issues with serialization.</p> Source code in <code>gumpy/genome.py</code> <pre><code>def __convert_references(self):\n    \"\"\"Convert BIOPython Reference objects to normal dictionaries. They do not\n    appear to have any greater application than storing structured data, so\n    removing the object wrappers appears to be a clean way to combat the object's\n    issues with serialization.\n    \"\"\"\n    for i, reference in enumerate(self.annotations[\"references\"]):\n        new_ref = {}\n        for key in vars(reference):\n            # This key contains unhelpfully structured data\n            if key == \"location\":\n                new_loc = []\n                for item in vars(reference)[key]:\n                    loc = {}\n                    for item_key in vars(item):\n                        if item_key == \"_start\" or item_key == \"_end\":\n                            # These are the only ones we care about\n                            loc[item_key] = int(getattr(item, item_key))\n                    new_loc.append(loc)\n                new_ref[key] = new_loc\n            else:\n                new_ref[key] = vars(reference)[key]\n        self.annotations[\"references\"][i] = new_ref\n</code></pre>"},{"location":"reference/genome/#genome.Genome.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Overloading the equality operator so two Genome objects can be compared directly. Checks for the equality based on fields, but does not check for filename equality</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>gumpy.Genome) </code> <p>The other Genome object to compare to</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Boolean showing equality of the objects</p> Source code in <code>gumpy/genome.py</code> <pre><code>def __eq__(self, other) -&gt; bool:\n    \"\"\"Overloading the equality operator so two Genome objects can be compared\n    directly. Checks for the equality based on fields, but does not check\n    for filename equality\n\n    Args:\n        other (gumpy.Genome) : The other Genome object to compare to\n\n    Returns:\n        bool : Boolean showing equality of the objects\n    \"\"\"\n    assert isinstance(other, Genome)\n\n    check = numpy.bool_(True)\n    check = check and numpy.bool_(self.genes == other.genes)\n    check = check and self.name == other.name\n    check = check and self.id == other.id\n    check = check and self.description == other.description\n    check = check and numpy.all(\n        self.nucleotide_sequence == other.nucleotide_sequence\n    )\n    check = check and numpy.all(self.nucleotide_index == other.nucleotide_index)\n    check = check and numpy.bool_(self.length == other.length)\n    check = check and numpy.all(\n        self.stacked_gene_name.tolist() == other.stacked_gene_name.tolist()\n    )\n\n    return bool(check)\n</code></pre>"},{"location":"reference/genome/#genome.Genome.__find_overlaps","title":"<code>__find_overlaps()</code>","text":"<p>Private function to find the sections of the genome in which there are     overlapping genes. This should be more efficient than the older version     as it avoids consistent genome iteration. Use of the dot product on boolean     arrays returns a single boolean showing collisions in almost constant time     (10^-5 secs for TB size). This can be used to determine which row the gene     should be in</p> Source code in <code>gumpy/genome.py</code> <pre><code>def __find_overlaps(self):\n    \"\"\"\n    Private function to find the sections of the genome in which there are\n        overlapping genes. This should be more efficient than the older version\n        as it avoids consistent genome iteration. Use of the dot product on boolean\n        arrays returns a single boolean showing collisions in almost constant time\n        (10^-5 secs for TB size). This can be used to determine which row the gene\n        should be in\n    \"\"\"\n\n    # Boolean mask to show gene presence at indicies (default to all False values)\n    genes_mask = numpy.array([numpy.array([False for x in range(self.length)])])\n\n    # gene names\n    genes = numpy.array(\n        [numpy.array([\"\" for x in range(self.length)])],\n        dtype=\"U\" + str(self.max_gene_name_length),\n    )\n\n    # dict to pull out row indicies for each gene in the stacked arrays\n    self.gene_rows = dict()\n\n    if self.verbose:\n        print(\"Finding overlaps...\")\n\n    for gene_name in tqdm(self.genes, disable=(not self.show_progress_bar)):\n        # get the start/end/rev_comp values\n        start = self.genes[gene_name][\"start\"]\n        end = self.genes[gene_name][\"end\"]\n        rev_comp = self.genes[gene_name][\"reverse_complement\"]\n\n        # determine the boolean mask for this gene\n        mask = (self.nucleotide_index &gt;= start) &amp; (self.nucleotide_index &lt; end)\n\n        # fit the gene into the stacked arrays\n        genes_mask, genes, row = self.__fit_gene(\n            mask, genes, genes_mask, start, end, gene_name, rev_comp\n        )\n        self.gene_rows[gene_name] = row\n\n    # Singular array to determine if there are genes in places within the genome\n    self.genes_mask = numpy.any(genes_mask, axis=0)\n\n    # Set instance variable for the gene names\n    self.stacked_gene_name = genes\n</code></pre>"},{"location":"reference/genome/#genome.Genome.__fit_gene","title":"<code>__fit_gene(mask, genes, genes_mask, start, end, gene_name, rev_comp)</code>","text":"<p>Private function to fit a gene into the genes based on the dot product of     the masks numpy.dot([bool], [bool])-&gt; bool showing if there are collisions     of True values within args. This takes 10^-5 seconds which is a significant     improvement on use of numpy.all() iteration of 10^-2 seconds for TB     length genome</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>numpy.ndarray) </code> <p>Boolean array showing positions where the gene lies</p> required <code>genes</code> <code>numpy.ndarray) </code> <p>2D numpy array of the format used for all stacked values</p> required <code>genes_mask</code> <code>numpy.ndarray) </code> <p>The corresponding boolean mask arrays for the <code>genes</code> arg</p> required <code>start</code> <code>int) </code> <p>Start index of the gene</p> required <code>end</code> <code>int) </code> <p>End index of the gene</p> required <code>gene_name</code> <code>str) </code> <p>Name of the gene</p> required <code>rev_comp</code> <code>bool) </code> <p>Boolean to show whether the gene required a reverse complement</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>(numpy_array) : Updated genes_mask array</p> <code>ndarray</code> <p>(numpy_array) : Updated genes array</p> Source code in <code>gumpy/genome.py</code> <pre><code>def __fit_gene(\n    self,\n    mask: numpy.ndarray,\n    genes: numpy.ndarray,\n    genes_mask: numpy.ndarray,\n    start: int,\n    end: int,\n    gene_name: str,\n    rev_comp: bool,\n) -&gt; Tuple[numpy.ndarray, numpy.ndarray, int]:\n    \"\"\"\n    Private function to fit a gene into the genes based on the dot product of\n        the masks numpy.dot([bool], [bool])-&gt; bool showing if there are collisions\n        of True values within args. This takes 10^-5 seconds which is a significant\n        improvement on use of numpy.all() iteration of 10^-2 seconds for TB\n        length genome\n\n    Args:\n        mask (numpy.ndarray) : Boolean array showing positions where the gene lies\n        genes (numpy.ndarray) : 2D numpy array of the format used for all stacked\n            values\n        genes_mask (numpy.ndarray) : The corresponding boolean mask arrays for the\n            `genes` arg\n        start (int) : Start index of the gene\n        end (int) : End index of the gene\n        gene_name (str) : Name of the gene\n        rev_comp (bool) : Boolean to show whether the gene required a\n            reverse complement\n\n    Returns:\n        (numpy_array) : Updated genes_mask array\n        (numpy_array) : Updated genes array\n    \"\"\"\n\n    for i, row in enumerate(genes_mask):\n        # use of the dot product of masks allows determining if a gene will fit\n        #   in an array\n        # Disable ruff here as `is False` doesn't work here\n        if numpy.dot(row, mask) == False:  # noqa: E712\n            # there is no collision with this row so add the row\n            # start/end have to be adjusted to account for 0 indexing of arrays and\n            #   1 indexing of genetics\n            row[start - 1 : end - 1] = True\n            genes[i][start - 1 : end - 1] = gene_name\n            self.__handle_rev_comp(rev_comp, start, end, i)\n            return genes_mask, genes, i\n\n    # if this point is reached, there has been no rows without collisions, so\n    #   add one\n    genes_mask = numpy.vstack((genes_mask, mask))\n    new_row = numpy.array([gene_name if m else \"\" for m in mask])\n    genes = numpy.vstack((genes, new_row))\n    i += 1\n    self.__handle_rev_comp(rev_comp, start, end, i)\n    return genes_mask, genes, i\n</code></pre>"},{"location":"reference/genome/#genome.Genome.__handle_rev_comp","title":"<code>__handle_rev_comp(rev_comp, start, end, i)</code>","text":"<p>Private function to handle the rev-comp changes required Args:     rev_comp (bool) : Boolean to show if rev-comp is required     start (int) : Start index of the gene     end (int) : End index of the gene     i (int) : The index of the stacked row</p> Source code in <code>gumpy/genome.py</code> <pre><code>def __handle_rev_comp(self, rev_comp: bool, start: int, end: int, i: int) -&gt; None:\n    \"\"\"\n    Private function to handle the rev-comp changes required\n    Args:\n        rev_comp (bool) : Boolean to show if rev-comp is required\n        start (int) : Start index of the gene\n        end (int) : End index of the gene\n        i (int) : The index of the stacked row\n    \"\"\"\n    # Check if the arrays have the correct number of rows and add as required\n    while len(self.stacked_nucleotide_number) &lt;= i:\n        self.stacked_is_cds = self.__add_empty_row(self.stacked_is_cds)\n        self.stacked_is_reverse_complement = self.__add_empty_row(\n            self.stacked_is_reverse_complement\n        )\n        self.stacked_is_promoter = self.__add_empty_row(self.stacked_is_promoter)\n        self.stacked_nucleotide_number = self.__add_empty_row(\n            self.stacked_nucleotide_number\n        )\n    # Update the required items for rev_comp\n    # Use of array slicing here introduces speedups as not all of the array should\n    #   be considered\n    # (Previous method applied a mask which requires full array consideration\n    #   rather than direct access)\n    if rev_comp:\n        self.stacked_nucleotide_number[i][start - 1 : end - 1] = numpy.mod(\n            -1 * (self.nucleotide_index[start - 1 : end - 1] - end), self.length\n        )\n        self.stacked_is_reverse_complement[i][start - 1 : end - 1] = True\n    else:\n        self.stacked_nucleotide_number[i][start - 1 : end - 1] = numpy.mod(\n            1 + self.nucleotide_index[start - 1 : end - 1] - start, self.length\n        )\n</code></pre>"},{"location":"reference/genome/#genome.Genome.__init__","title":"<code>__init__(genbank_file_, show_progress_bar=False, gene_subset=None, max_promoter_length=100, max_gene_name_length=20, verbose=False, is_reference=False)</code>","text":"<p>Constructor for the Genome object.</p> <p>Parameters:</p> Name Type Description Default <code>genbank_file_</code> <code>str) </code> <p>The path to the genbank file.</p> required <code>show_progress_bar</code> <code>bool, optional) </code> <p>Boolean as whether to show a progress bar when building Gene objects. Defaults to False.</p> <code>False</code> <code>gene_subset</code> <code>list, optional) </code> <p>List of gene names used to extract just a subset of genes. Defaults to None</p> <code>None</code> <code>max_promoter_length</code> <code>int, optional) </code> <p>Size of the default maximum number of upstream bases to consider the promoter of a gene. Defaults to 100</p> <code>100</code> <code>max_gene_name_length</code> <code>int, optional) </code> <p>Length of the longest gene name. Defaults to 20</p> <code>20</code> <code>verbose</code> <code>bool, optional) </code> <p>Give verbose statements? Defaults to False</p> <code>False</code> <code>is_reference</code> <code>bool, optional) </code> <p>Is this a reference genome? i.e. mutations can be derived with respect to it? Defaults to False</p> <code>False</code> Source code in <code>gumpy/genome.py</code> <pre><code>def __init__(\n    self,\n    genbank_file_: str,\n    show_progress_bar: bool = False,\n    gene_subset: List[str] | None = None,\n    max_promoter_length: int = 100,\n    max_gene_name_length: int = 20,\n    verbose: bool = False,\n    is_reference: bool = False,\n):\n    \"\"\"Constructor for the Genome object.\n\n    Args:\n        genbank_file_ (str) : The path to the genbank file.\n        show_progress_bar (bool, optional) : Boolean as whether to show a progress\n            bar when building Gene objects. Defaults to False.\n        gene_subset (list, optional) : List of gene names used to extract just a\n            subset of genes. Defaults to None\n        max_promoter_length (int, optional) : Size of the default maximum number of\n            upstream bases to consider the promoter of a gene. Defaults to 100\n        max_gene_name_length (int, optional) : Length of the longest gene name.\n            Defaults to 20\n        verbose (bool, optional) : Give verbose statements? Defaults to False\n        is_reference (bool, optional) : Is this a reference genome? i.e. mutations\n            can be derived with respect to it? Defaults to False\n    \"\"\"\n    self.show_progress_bar = show_progress_bar\n    self.gene_subset = gene_subset\n    self.max_promoter_length = max_promoter_length\n    self.max_gene_name_length = max_gene_name_length\n    self.verbose = verbose\n    self.is_reference = is_reference\n    self.vcf_file: VCFFile | None = None\n    self.gumpy_version: str | None = None\n\n    genbank_file = pathlib.Path(genbank_file_)\n\n    assert genbank_file.is_file(), \"GenBank file does not exist!\"\n    assert (\n        isinstance(self.max_promoter_length, int) and self.max_promoter_length &gt;= 0\n    ), \"the promoter length must be zero or a positive integer!\"\n\n    assert isinstance(self.verbose, bool)\n    assert isinstance(self.is_reference, bool)\n    assert isinstance(self.show_progress_bar, bool)\n    assert (\n        isinstance(self.max_gene_name_length, int) and self.max_gene_name_length &gt; 0\n    )\n    if self.gene_subset is not None:\n        # first check it is a list\n        assert isinstance(self.gene_subset, list)\n        # then check all elements in the list are strings\n        assert all(isinstance(i, str) for i in self.gene_subset)\n\n    if self.verbose:\n        timings = defaultdict(list)\n        start_time = time.time()\n\n    self.__parse_genbank_file(pathlib.Path(genbank_file))\n\n    if self.verbose:\n        timings[\"parse genbank\"].append(time.time() - start_time)\n        start_time = time.time()\n\n    self.__setup_arrays()\n\n    if self.verbose:\n        timings[\"define arrays\"].append(time.time() - start_time)\n        start_time = time.time()\n\n    if self.max_promoter_length &gt; 0:\n        self.__assign_promoter_regions()\n\n    if self.verbose:\n        timings[\"promoter\"].append(time.time() - start_time)\n        start_time = time.time()\n\n    self.__convert_references()\n</code></pre>"},{"location":"reference/genome/#genome.Genome.__insert_newlines","title":"<code>__insert_newlines(string, every=70)</code>","text":"<pre><code>    Simple private method for inserting a carriage return every N characters into\n        a long string.\n\n    Args:\n        string (str): the string to insert carriage returns\n        every (int): how many characters between each carriage return\n\n    Returns:\n        str: Same string with \"\n</code></pre> <p>\" characters inserted</p> Source code in <code>gumpy/genome.py</code> <pre><code>def __insert_newlines(self, string: str, every=70) -&gt; str:\n    \"\"\"\n    Simple private method for inserting a carriage return every N characters into\n        a long string.\n\n    Args:\n        string (str): the string to insert carriage returns\n        every (int): how many characters between each carriage return\n\n    Returns:\n        str: Same string with \"\\n\" characters inserted\n    \"\"\"\n\n    assert every &gt; 0, \"every must be an integer greater than zero\"\n\n    assert len(string) &gt; 1, \"string is too short!\"\n\n    return \"\\n\".join(string[i : i + every] for i in range(0, len(string), every))\n</code></pre>"},{"location":"reference/genome/#genome.Genome.__len__","title":"<code>__len__()</code>","text":"<p>Adding len functionality - len(genome) returns the length of the genome</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Length of the genome</p> Source code in <code>gumpy/genome.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Adding len functionality - len(genome) returns the length of the genome\n\n    Returns:\n        int : Length of the genome\n    \"\"\"\n    return self.length\n</code></pre>"},{"location":"reference/genome/#genome.Genome.__parse_genbank_file","title":"<code>__parse_genbank_file(genbank_file)</code>","text":"<p>Private function to parse a genbank file Args:     genbank_file (Path) : pathlib.Path object of the genbank file</p> Source code in <code>gumpy/genome.py</code> <pre><code>def __parse_genbank_file(self, genbank_file: pathlib.Path) -&gt; None:\n    \"\"\"\n    Private function to parse a genbank file\n    Args:\n        genbank_file (Path) : pathlib.Path object of the genbank file\n    \"\"\"\n\n    if genbank_file.suffix == \".gz\":\n        file_handle = gzip.open(genbank_file, \"rt\")\n    elif genbank_file.suffix == \".gbk\":\n        file_handle = open(genbank_file, \"rt\")\n\n    reference_genome = SeqIO.read(file_handle, \"genbank\")\n\n    # convert to a numpy array at the first opportunity since slicing BioPython\n    #   is between 10 and 50,000 times slower!\n    self.nucleotide_sequence = numpy.array(\n        [i.lower() for i in str(reference_genome.seq)]\n    )\n\n    self.name = reference_genome.name\n    self.id = reference_genome.id\n    self.description = reference_genome.description\n\n    # store the length of the genome\n    self.length = len(self.nucleotide_sequence)\n\n    assert self.length &gt; 0, \"genome length zero!\"\n\n    # create an array of the genome indices\n    self.nucleotide_index = numpy.arange(1, self.length + 1, dtype=\"int\")\n\n    self.stacked_gene_name = numpy.zeros(\n        (1, self.length), dtype=\"&lt;U\" + str(int(self.max_gene_name_length))\n    )\n    self.stacked_is_cds = numpy.zeros((1, self.length), dtype=bool)\n    self.stacked_is_promoter = numpy.zeros((1, self.length), dtype=bool)\n    self.stacked_nucleotide_number = numpy.zeros((1, self.length), dtype=\"int\")\n    self.stacked_is_reverse_complement = numpy.zeros((1, self.length), dtype=bool)\n\n    self.is_indel = numpy.zeros(self.length, dtype=bool)\n    self.indel_length = numpy.zeros(self.length, int)\n    self.indel_nucleotides = numpy.empty(self.length, dtype=object)\n\n    assert (\n        len(reference_genome.annotations[\"accessions\"]) == 1\n    ), \"only GenBank files with a single accessions currently allowed\"\n\n    self.annotations = {}\n    for i in reference_genome.annotations.keys():\n        self.annotations[i] = reference_genome.annotations[i]\n\n    self.genes: Dict = {}\n\n    # loop through the features listed in the GenBank File\n    if self.verbose:\n        print(\"Iterating through features in GenBank file...\")\n\n    for record in tqdm(\n        reference_genome.features, disable=(not self.show_progress_bar)\n    ):\n        # only parse coding sequences and rRNA features\n        if record.type not in [\"CDS\", \"rRNA\"]:\n            continue\n\n        gene_name = None\n        type_ = None\n        codes_protein = True\n\n        # try and use the gene name if available, otherwise use the locus\n        if \"gene\" in record.qualifiers.keys():\n            gene_name = record.qualifiers[\"gene\"][0]\n            type_ = \"GENE\"\n\n        elif \"locus_tag\" in record.qualifiers.keys():\n            gene_name = record.qualifiers[\"locus_tag\"][0]\n            type_ = \"LOCUS\"\n\n        if gene_name is None or (\n            self.gene_subset is not None and gene_name not in self.gene_subset\n        ):\n            continue\n\n        # if this is ribosomal RNA, then record as such\n        if record.type == \"rRNA\":\n            type_ = \"RNA\"\n            codes_protein = False\n\n        # determine if this is a reverse complement gene (only relevant to\n        #   dsDNA genomes)\n        rev_comp = True if record.strand == -1 else False\n\n        # sigh, you can't assume that a gene_name is unique in a GenBank file\n        # this only allows for duplicates though.\n        # duplicates of duplicates will be foo_2_2\n        gene_name += \"_2\" if gene_name in self.genes.keys() else \"\"\n\n        # check the gene_name will fit in the max gene name length\n        assert len(gene_name) &lt;= self.max_gene_name_length, (\n            \"Gene \"\n            + gene_name\n            + \" is too long at \"\n            + str(len(gene_name))\n            + \" chars; need to specify max_gene_name_length\"\n        )\n\n        # note that BioPython \"helpfully\" turns these from 1-based into 0-based\n        #   coordinates, hence the +1\n        # gene_end has also been incremented by 1 so that slicing naturally works\n        gene_start = int(record.location.start) + 1\n        gene_end = int(record.location.end) + 1\n\n        # Check for ribosomal shift\n        # This happens when a start position &lt; end position\n        positions = [\n            (int(loc.start), int(loc.end)) for loc in record.location.parts\n        ]\n        shifts = []\n        # Check for -1 PFS\n        if len(positions) &gt; 1 and positions[0][1] &gt; positions[1][0]:\n            shifts.append(positions[1][0] - gene_start + 1)\n\n        # record feature metadata in a dict\n        self.genes[gene_name] = {\n            \"reverse_complement\": rev_comp,\n            \"type\": type_,\n            \"codes_protein\": codes_protein,\n            \"start\": gene_start,\n            \"end\": gene_end,\n            \"ribosomal_shifts\": shifts,\n        }\n\n    # now we can check that all the genes in the gene_subset exist in the\n    #   GenBank file!\n    if self.gene_subset is not None:\n        for i in self.gene_subset:\n            assert self.contains_gene(i), (\n                \"Gene \" + i + \" not found in the Genbank file!\"\n            )\n</code></pre>"},{"location":"reference/genome/#genome.Genome.__repr__","title":"<code>__repr__()</code>","text":"<p>Overload the print function to write a summary of the genome.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String including attributes for the genome</p> Source code in <code>gumpy/genome.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Overload the print function to write a summary of the genome.\n\n    Returns:\n        str : String including attributes for the genome\n    \"\"\"\n\n    output = \"\"\n    if hasattr(self, \"name\"):\n        output += self.name + \"\\n\"\n    if hasattr(self, \"id\"):\n        output += self.id + \"\\n\"\n    if hasattr(self, \"description\"):\n        output += self.description + \"\\n\"\n    output += str(self.length) + \" bases\\n\"\n    output += \"\".join(i for i in self.nucleotide_sequence[0:6])\n    output += \"...\"\n    output += \"\".join(i for i in self.nucleotide_sequence[-6:]) + \"\\n\"\n    if self.gene_subset is None:\n        output += \"metadata for all genes/loci have been included\\n\"\n    elif len(self.gene_subset) &lt; 10:\n        output += (\n            \"the following \"\n            + str(len(self.gene_subset))\n            + \" genes have been included: \"\n        )\n        for i in self.gene_subset:\n            output += str(i) + \", \"\n    else:\n        output += str(len(self.gene_subset)) + \" gene/loci have been included.\"\n    return output\n</code></pre>"},{"location":"reference/genome/#genome.Genome.__setup_arrays","title":"<code>__setup_arrays()</code>","text":"<p>Private function to initalise all of the required arrays, fitting the gene     names into the correct places within stacked arrays</p> Source code in <code>gumpy/genome.py</code> <pre><code>def __setup_arrays(self):\n    \"\"\"\n    Private function to initalise all of the required arrays, fitting the gene\n        names into the correct places within stacked arrays\n    \"\"\"\n    self.__find_overlaps()\n\n    # do as many assignments outside the loop, i.e. in one go to improve performance\n    self.stacked_is_cds = self.stacked_gene_name != \"\"\n\n    self.n_rows = self.stacked_gene_name.shape[0]\n\n    self.stacked_nucleotide_index = numpy.tile(\n        self.nucleotide_index, (self.n_rows, 1)\n    )\n\n    self.stacked_nucleotide_sequence = numpy.tile(\n        self.nucleotide_sequence, (self.n_rows, 1)\n    )\n\n    # Use a list to track minority populations\n    self.minor_populations = []\n\n    # Track which nucleotides are deleted\n    self.is_deleted = numpy.array([False for i in self.nucleotide_index])\n\n    # Use a dict to track VCF evidence as req\n    self.vcf_evidence = dict()\n</code></pre>"},{"location":"reference/genome/#genome.Genome.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Generate a GenomeDifference object for a in-depth difference of the     two Genomes</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>gumpy.Genome) </code> <p>The other genome used in the subtraction</p> required <p>Returns:</p> Name Type Description <code>GenomeDifference</code> <code>GenomeDifference</code> <p>object containing numpy arrays of the differences (variants)</p> Source code in <code>gumpy/genome.py</code> <pre><code>def __sub__(self, other) -&gt; GenomeDifference:\n    \"\"\"Generate a GenomeDifference object for a in-depth difference of the\n        two Genomes\n\n    Args:\n        other (gumpy.Genome) : The other genome used in the subtraction\n\n    Returns:\n        GenomeDifference: object containing numpy arrays of the\n            differences (variants)\n    \"\"\"\n\n    assert isinstance(other, Genome), \"RHS must be a gumpy.Genome object\"\n\n    return GenomeDifference(self, other)\n</code></pre>"},{"location":"reference/genome/#genome.Genome.at_index","title":"<code>at_index(index)</code>","text":"<p>Returns the name of any genome features (genes, loci) at a specified genome     index (1-based).</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Genome index to check for genes at.</p> required <p>Returns:</p> Type Description <code>List[str] | None</code> <p>List[str] | None: list of gene_names or locus_tags at that index in the genome</p> Source code in <code>gumpy/genome.py</code> <pre><code>def at_index(self, index: int) -&gt; List[str] | None:\n    \"\"\"\n    Returns the name of any genome features (genes, loci) at a specified genome\n        index (1-based).\n\n    Args:\n        index (int): Genome index to check for genes at.\n\n    Returns:\n        List[str] | None: list of gene_names or locus_tags at that index\n            in the genome\n\n    \"\"\"\n    assert isinstance(index, int), \"index must be an integer!\"\n    assert index &gt; 0, \"index must be a positive integer!\"\n    assert index &lt;= self.length, \"index must be less than the length of the genome!\"\n\n    mask = self.stacked_nucleotide_index == index\n\n    foo = self.stacked_gene_name[mask]\n\n    putative_genes = list(foo[foo != \"\"])\n\n    if not putative_genes:\n        return None\n    else:\n        return putative_genes\n</code></pre>"},{"location":"reference/genome/#genome.Genome.build_gene","title":"<code>build_gene(gene)</code>","text":"<p>Public function to build the gumpy.Gene object</p> <p>Parameters:</p> Name Type Description Default <code>gene</code> <code>str) </code> <p>The name of the gene</p> required <p>Returns:</p> Type Description <code>Gene</code> <p>gumpy.Gene : The instanciated gene object.</p> Source code in <code>gumpy/genome.py</code> <pre><code>def build_gene(self, gene: str) -&gt; Gene:\n    \"\"\"\n    Public function to build the gumpy.Gene object\n\n    Args:\n        gene (str) : The name of the gene\n\n    Returns:\n        gumpy.Gene : The instanciated gene object.\n    \"\"\"\n\n    # The mask for all stacked arrays (N-dim)\n    stacked_mask = self.stacked_gene_name == gene\n\n    # The mask for singular arrays (1-dim) by collapsing stacked mask to 1-dim\n    mask = numpy.any(stacked_mask, axis=0)\n\n    # check that the genome does contain the gene name\n    assert numpy.count_nonzero(mask) &gt; 0, \"gene (\" + gene + \") not found in genome!\"\n\n    # Revert is_cds to all False if this gene is non-coding\n    # Easier to do it like this than to mess with masking\n    nucleotide_seq = self.nucleotide_sequence[mask]\n    if not self.genes[gene][\"codes_protein\"]:\n        is_cd = numpy.array([False for i in range(len(nucleotide_seq))])\n    else:\n        is_cd = self.stacked_is_cds[stacked_mask]\n\n    gene_nucleotides = self.nucleotide_index[mask]\n    gene_minor_populations = []\n    for population in self.minor_populations:\n        if population[0] in gene_nucleotides:\n            # This minor population is within the gene\n            gene_minor_populations.append(population)\n\n    vcf_evidence = {\n        idx: self.vcf_evidence[idx]\n        for idx in self.vcf_evidence.keys()\n        if idx in gene_nucleotides\n    }\n\n    # instantiate a Gene object\n    g = Gene(\n        gene,\n        nucleotide_seq,\n        gene_nucleotides,\n        self.stacked_nucleotide_number[stacked_mask],\n        is_cd,\n        self.stacked_is_promoter[stacked_mask],\n        self.is_indel[mask],\n        self.indel_length[mask],\n        self.indel_nucleotides[mask],\n        self.genes[gene][\"reverse_complement\"],\n        self.genes[gene][\"codes_protein\"],\n        self.genes[gene][\"type\"],\n        self.genes[gene][\"ribosomal_shifts\"],\n        gene_minor_populations,\n        self.is_deleted[mask],\n        vcf_evidence,\n    )\n\n    return g\n</code></pre>"},{"location":"reference/genome/#genome.Genome.build_genome_string","title":"<code>build_genome_string(fixed_length=False, nucleotide_index_range=None)</code>","text":"<p>Generate a string of the nucleotides in the genome (positive strand if DNA).</p> <p>Parameters:</p> Name Type Description Default <code>fixed_length</code> <code>bool</code> <p>if True, then do not add insertions and deletions. Default False.</p> <code>False</code> <code>nucleotide_index_range</code> <code>(tuple, ints)</code> <p>the 1-based positions of the sequence to return with start&lt;=index&lt;end.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>the genome as a string.</p> Source code in <code>gumpy/genome.py</code> <pre><code>def build_genome_string(\n    self,\n    fixed_length: bool = False,\n    nucleotide_index_range: Tuple[int, int] | None = None,\n) -&gt; str:\n    \"\"\"\n    Generate a string of the nucleotides in the genome (positive strand if DNA).\n\n    Args:\n        fixed_length (bool): if True, then do not add insertions and deletions.\n            Default False.\n        nucleotide_index_range (tuple, ints): the 1-based positions of the sequence\n            to return with start&lt;=index&lt;end.\n\n    Returns:\n        (str): the genome as a string.\n    \"\"\"\n    # create a string of the genome\n    if fixed_length:\n        if nucleotide_index_range is not None:\n            assert isinstance(nucleotide_index_range, tuple)\n            start, end = nucleotide_index_range\n            genome_string = \"\".join(self.nucleotide_sequence[start - 1 : end - 1])\n        else:\n            genome_string = \"\".join(self.nucleotide_sequence)\n    else:\n        if nucleotide_index_range is not None:\n            start, end = nucleotide_index_range\n            genome_string = self.__build_genome_variable_length_string(\n                self.nucleotide_index[start - 1 : end - 1]\n            )\n        else:\n            genome_string = self.__build_genome_variable_length_string(\n                self.nucleotide_index\n            )\n\n    return genome_string\n</code></pre>"},{"location":"reference/genome/#genome.Genome.contains_gene","title":"<code>contains_gene(gene_name)</code>","text":"<p>Simply checks to see if the specified gene exists in the Genome object.</p> <p>Parameters:</p> Name Type Description Default <code>gene_name</code> <code>str) </code> <p>Name of the gene e.g. katG</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Boolean showing if the genome contains a gene with that name</p> Source code in <code>gumpy/genome.py</code> <pre><code>def contains_gene(self, gene_name: str) -&gt; bool:\n    \"\"\"\n    Simply checks to see if the specified gene exists in the Genome object.\n\n    Args:\n        gene_name (str) : Name of the gene e.g. katG\n\n    Returns:\n        bool : Boolean showing if the genome contains a gene with that name\n    \"\"\"\n    assert isinstance(\n        gene_name, str\n    ), \"Gene name must be string. Gene name provided was of type: \" + str(\n        type(gene_name)\n    )\n    # Use of dict.get(obj) returns an object or None if obj does not exist in dict\n    # bool(None) = False, bool(obj) = True\n    return bool(self.genes.get(gene_name))\n</code></pre>"},{"location":"reference/genome/#genome.Genome.minority_populations_GARC","title":"<code>minority_populations_GARC(interpretation='reads', reference=None)</code>","text":"<p>Get the variants in GARC of the minority populations for this genome. Whether the variants are given in terms of reads or read percentage is     controlled by <code>interpretation</code></p> <p>Parameters:</p> Name Type Description Default <code>interpretation</code> <code>str</code> <p>Which interpretation to use. <code>reads</code> for number of reads for this population. <code>percentage</code> for the decimal percentage of total reads for this population. Defaults to 'reads'.</p> <code>'reads'</code> <code>reference</code> <code>Genome</code> <p>The reference to denote mutations from. Defaults to self</p> <code>None</code> <p>Returns:     List[str]: List of the variants in GARC</p> Source code in <code>gumpy/genome.py</code> <pre><code>def minority_populations_GARC(\n    self, interpretation: str = \"reads\", reference=None\n) -&gt; List[str]:\n    \"\"\"Get the variants in GARC of the minority populations for this genome.\n    Whether the variants are given in terms of reads or read percentage is\n        controlled by `interpretation`\n\n    Args:\n        interpretation (str, optional): Which interpretation to use. `reads` for\n            number of reads for this population. `percentage` for the decimal\n            percentage of total reads for this population. Defaults to 'reads'.\n        reference (gumpy.Genome, optional): The reference to denote mutations from.\n            Defaults to self\n    Returns:\n        List[str]: List of the variants in GARC\n    \"\"\"\n    # Use the interpretation type to pull out which index of the minor_populations\n    # Each item of minor_populations is (pos, type, bases, abs_coverage,\n    #   percent_coverage)\n    if interpretation == \"percentage\":\n        coverage = 4\n    else:\n        coverage = 3\n\n    if reference is None:\n        reference = self\n    else:\n        # Ensure that only one of the two Genomes has minor populations\n        assert len(reference.minor_populations) == 0, (\n            \"Minority populations can only be compared when 1 Genome \"\n            \"does not have them!\"\n        )\n\n    variants = []\n    for minor in self.minor_populations:\n        pos = minor[0]\n        type_ = minor[1]\n        bases = minor[2]\n        depth = minor[coverage]\n\n        if type_ in [\"ref\", \"snp\"]:\n            # These are functionally the same\n            for i, (r, alt) in enumerate(zip(*bases)):\n                ref = reference.nucleotide_sequence[\n                    reference.nucleotide_index == pos + i\n                ][0]\n                variants.append(f\"{pos+i}{ref}&gt;{alt}:{depth}\")\n        else:\n            # Indels are the same too\n            variants.append(f\"{pos}_{type_}_{bases}:{depth}\")\n\n    return sorted(variants)\n</code></pre>"},{"location":"reference/genome/#genome.Genome.save_fasta","title":"<code>save_fasta(filename, fixed_length=False, nucleotide_index_range=None, compression=False, compresslevel=2, chars_per_line=70, nucleotides_uppercase=True, description=None, overwrite_existing=True)</code>","text":"<p>Save the genome as a FASTA file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>path of the output file</p> required <code>fixed_length</code> <code>bool</code> <p>If True, ignore indels and only output a genome the same length as the reference but with SNPs. This is useful for phylogeny analyses and relatedness. If false, a genome including indels is produced. Default is false.</p> <code>False</code> <code>nucleotide_index_range</code> <code>tuple</code> <p>A tuple of (start,end) genome indices</p> <code>None</code> <code>compression</code> <code>bool</code> <p>If True, save compressed using gzip. (bzip2 is too slow)</p> <code>False</code> <code>compresslevel</code> <code>0 - 9</code> <p>the higher the number, the harder the algorithm tries to compress but it takes longer. Default is 2.</p> <code>2</code> <code>chars_per_line</code> <code>int</code> <p>the number of characters per line. Default=70. Must be either a positive integer or None (i.e. no CRs)</p> <code>70</code> <code>nucleotide_uppercase</code> <code>bool</code> <p>If True, provide the nucleotides in UPPER CASE. Default is True.</p> required <code>description</code> <code>str</code> <p>what to write on the header line of the FASTA file. If not provided, then a description will be automatically generated from the GenBank file metadata.</p> <code>None</code> <code>overwrite_existing</code> <code>bool</code> <p>If False, then the code will refuse to overwrite a FASTA file already on disc. Default is True.</p> <code>True</code> Source code in <code>gumpy/genome.py</code> <pre><code>def save_fasta(\n    self,\n    filename,\n    fixed_length: bool = False,\n    nucleotide_index_range: Tuple[int, int] | None = None,\n    compression: bool = False,\n    compresslevel: int = 2,\n    chars_per_line: int = 70,\n    nucleotides_uppercase: bool = True,\n    description: str | None = None,\n    overwrite_existing: bool = True,\n) -&gt; None:\n    \"\"\"\n    Save the genome as a FASTA file.\n\n    Args:\n        filename (str): path of the output file\n        fixed_length (bool): If True, ignore indels and only output a genome the\n            same length as the reference but with SNPs. This is useful for\n            phylogeny analyses and relatedness. If false, a genome including indels\n            is produced. Default is false.\n        nucleotide_index_range (tuple, optional): A tuple of (start,end)\n            genome indices\n        compression (bool): If True, save compressed using gzip. (bzip2 is too slow)\n        compresslevel (0-9): the higher the number, the harder the algorithm tries\n            to compress but it takes longer. Default is 2.\n        chars_per_line (int): the number of characters per line. Default=70. Must\n            be either a positive integer or None (i.e. no CRs)\n        nucleotide_uppercase (bool): If True, provide the nucleotides in\n            UPPER CASE. Default is True.\n        description (str, optional): what to write on the header line of the FASTA\n            file. If not provided, then a description will be automatically\n            generated from the GenBank file metadata.\n        overwrite_existing (bool): If False, then the code will refuse to overwrite\n            a FASTA file already on disc. Default is True.\n    \"\"\"\n\n    # check the arguments are well formed\n    if not overwrite_existing:\n        assert not pathlib.Path(filename).is_file(), (\n            \"filename already exists! \" + filename\n        )\n    assert isinstance(compression, bool)\n    assert isinstance(fixed_length, bool)\n    assert isinstance(nucleotides_uppercase, bool)\n    assert isinstance(chars_per_line, int)\n    if nucleotide_index_range is not None:\n        assert isinstance(nucleotide_index_range, tuple)\n        assert isinstance(nucleotide_index_range[0], int)\n        assert isinstance(nucleotide_index_range[1], int)\n        assert (\n            nucleotide_index_range[0] &gt;= 1\n        ), \"genomes are 1-based so the first base must be &gt;=1\"\n        assert nucleotide_index_range[1] &lt; self.length, \"longer than the genome!\"\n    assert compresslevel in range(1, 10), \"compresslevel must be in range 1-9!\"\n    assert (\n        chars_per_line &gt; 0\n    ), \"number of characters per line in the FASTA file must be a positive integer!\"\n    if description is not None:\n        assert isinstance(description, str)\n\n    # check the specified fileextension to see if the FASTA file needs compressing\n    if compression:\n        OUTPUT = gzip.open(filename + \".gz\", \"wb\", compresslevel=compresslevel)\n    else:\n        OUTPUT = open(filename, \"w\")\n\n    # create the header line for the FASTA file using \"|\" as delimiters\n    header = \"&gt;\"\n    if description is None:\n        if hasattr(self, \"name\"):\n            header += self.name + \"|\"\n        if hasattr(self, \"id\") and isinstance(self.id, str) and len(self.id) &gt; 0:\n            header += self.id + \"|\"\n        if (\n            hasattr(self, \"description\")\n            and isinstance(self.description, str)\n            and len(self.description) &gt; 0\n        ):\n            header += self.description + \"|\"\n        header = header[:-1]\n    else:\n        header += description\n    header += \"\\n\"\n\n    genome_string = self.build_genome_string(fixed_length, nucleotide_index_range)\n\n    # insert carriage returns so it looks pretty in the file...\n    output_string = self.__insert_newlines(genome_string, every=chars_per_line)\n    output_string += \"\\n\"\n\n    # set the case accordingly\n    if nucleotides_uppercase:\n        output_string = output_string.upper()\n    else:\n        output_string = output_string.lower()\n\n    # write out the FASTA files\n    if compression:\n        OUTPUT.write(str.encode(header))\n        OUTPUT.write(str.encode(output_string))\n    else:\n        OUTPUT.write(header)\n        OUTPUT.write(output_string)\n\n    OUTPUT.close()\n</code></pre>"},{"location":"reference/genome/#genome.Genome.save_sequence","title":"<code>save_sequence(filename=None)</code>","text":"<p>Save the genome as a compressed NPZ file (compressed internally using gzip).</p> <p>This is purely done because loading an NPZ file back into memory is FAST     (~200\u00b5s) so this could allow future analyses</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>path of the output file without the file extension</p> <code>None</code> Source code in <code>gumpy/genome.py</code> <pre><code>def save_sequence(self, filename=None) -&gt; None:\n    \"\"\"\n    Save the genome as a compressed NPZ file (compressed internally using gzip).\n\n    This is purely done because loading an NPZ file back into memory is FAST\n        (~200\u00b5s) so this could allow future analyses\n\n    Args:\n        filename (str): path of the output file without the file extension\n    \"\"\"\n    numpy.savez_compressed(filename, sequence=self.nucleotide_sequence)\n</code></pre>"},{"location":"reference/variantfile/","title":"variantfile","text":"<p>Classes used to parse and store VCF data</p>"},{"location":"reference/variantfile/#variantfile.VCFFile","title":"<code>VCFFile</code>","text":"<p>               Bases: <code>object</code></p> <ul> <li>Class to instanciate a variant file (VCF)</li> <li>Used to apply a VCF file to a genome</li> <li>Instance variables:<ul> <li><code>filename</code> (str): path to the VCF file</li> <li><code>vcf_version</code> (tuple(int)): Tuple of ints to show the VCF version of the     file. e.g 3.2 would be (3, 2).</li> <li><code>contig_lengths</code> (dict): Dictionary mapping contig_name-&gt;length for all     defined contigs.</li> <li><code>format_fields_description</code> (dict): Dictionary mapping     format_name-&gt;dict(description, id, type).</li> <li><code>records</code> (list(VCFRecord)): List of VCFRecord objects for each record within     the file.</li> <li><code>calls</code> (dict): Dict of definite calls made in the VCF file, after any     additional filtering has been applied</li> <li><code>ignore_filter</code> (bool): whether to ignore the FILTER in the VCF file</li> <li><code>format_fields_min_thresholds</code> (dict): dictionary specifying minimum     thresholds to be applied to fields in the FORMAT field e.g. {'GTCONF':5}</li> <li><code>variants</code> (numpy.array): Numpy array of the detected variants in the VCF file</li> <li><code>nucleotide_index</code> (numpy.array): Array of genome indices which are affected     by the VCF</li> <li><code>ref_nucleotides</code> (numpy.array): Array of REF bases</li> <li><code>alt_nucleotides</code> (numpy.array): Array of ALT bases</li> <li><code>indel_length</code> (numpy.array): Array of lengths of insertions (+ve) or     deletions (-ve) at each site</li> <li><code>is_snp</code> (numpy.array): Array to act as a mask for <code>nucleotide_index</code> to     show which are SNPs</li> <li><code>is_het</code> (numpy.array): Array to act as a mask for <code>nucleotide_index</code> to     show which are heterozygous calls</li> <li><code>is_null</code> (numpy.array): Array to act as a mask for <code>nucleotide_index</code> to     show which are null calls</li> <li><code>is_indel</code> (numpy.array): Array to act as a mask for <code>nucleotide_index</code> to     show which are indel calls</li> <li><code>snp_distance</code> (int): SNP distance caused by the VCF</li> </ul> </li> </ul> Source code in <code>gumpy/variantfile.py</code> <pre><code>class VCFFile(object):\n    \"\"\"\n    * Class to instanciate a variant file (VCF)\n    * Used to apply a VCF file to a genome\n    * Instance variables:\n        * `filename` (str): path to the VCF file\n        * `vcf_version` (tuple(int)): Tuple of ints to show the VCF version of the\n            file. e.g 3.2 would be (3, 2).\n        * `contig_lengths` (dict): Dictionary mapping contig_name-&gt;length for all\n            defined contigs.\n        * `format_fields_description` (dict): Dictionary mapping\n            format_name-&gt;dict(description, id, type).\n        * `records` (list(VCFRecord)): List of VCFRecord objects for each record within\n            the file.\n        * `calls` (dict): Dict of definite calls made in the VCF file, after any\n            additional filtering has been applied\n        * `ignore_filter` (bool): whether to ignore the FILTER in the VCF file\n        * `format_fields_min_thresholds` (dict): dictionary specifying minimum\n            thresholds to be applied to fields in the FORMAT field e.g. {'GTCONF':5}\n        * `variants` (numpy.array): Numpy array of the detected variants in the VCF file\n        * `nucleotide_index` (numpy.array): Array of genome indices which are affected\n            by the VCF\n        * `ref_nucleotides` (numpy.array): Array of REF bases\n        * `alt_nucleotides` (numpy.array): Array of ALT bases\n        * `indel_length` (numpy.array): Array of lengths of insertions (+ve) or\n            deletions (-ve) at each site\n        * `is_snp` (numpy.array): Array to act as a mask for `nucleotide_index` to\n            show which are SNPs\n        * `is_het` (numpy.array): Array to act as a mask for `nucleotide_index` to\n            show which are heterozygous calls\n        * `is_null` (numpy.array): Array to act as a mask for `nucleotide_index` to\n            show which are null calls\n        * `is_indel` (numpy.array): Array to act as a mask for `nucleotide_index` to\n            show which are indel calls\n        * `snp_distance` (int): SNP distance caused by the VCF\n    \"\"\"\n\n    def __init__(\n        self,\n        filename: str,\n        ignore_filter: bool = False,\n        bypass_reference_calls: bool = False,\n        format_fields_min_thresholds: Dict[str, int] | None = None,\n        minor_population_indices: Collection[int] = [],\n        min_dp: int | None = None,\n    ):\n        \"\"\"\n        Constructor for the VCFFile object.\n\n        Parses the VCF file using pysam.\n\n        Args:\n            filename (str) : The name of the VCF file\n            ignore_filter (bool, optional): If True, ignore the FILTER column in the\n                VCF file. Default is False.\n            bypass_reference_calls (bool, optional): If True, skip any row in the VCF\n                (and therefore do not record)  which calls reference (i.e. 0/0).\n                Default is False.\n            format_fields_min_thresholds (dict, optional): Dict of field name in the\n                FORMAT column and a minimum threshold to apply e.g. {'DP':5}\n            minor_population_indices (set, optional): set of genome indices names\n                within which to look for minor populations\n            min_dp (int, optional): Minimum depth to consider a call. Default is None\n        \"\"\"\n\n        self.ignore_filter = ignore_filter\n        assert isinstance(self.ignore_filter, bool)\n\n        self.bypass_reference_calls = bypass_reference_calls\n        assert isinstance(self.bypass_reference_calls, bool)\n\n        self.format_fields_min_thresholds = format_fields_min_thresholds\n        if self.format_fields_min_thresholds is not None:\n            assert isinstance(self.format_fields_min_thresholds, dict)\n\n        self.minor_population_indices = minor_population_indices\n        # As {}/[] is a dangerous default value, convert from None to {} as req\n        if self.minor_population_indices is None:\n            self.minor_population_indices = set()\n        else:\n            # Value given, so check if it's of the right format\n            # Functionally, we don't care if it's actually a set. We just care its an\n            #   interable of ints\n            try:\n                for i in self.minor_population_indices:\n                    assert isinstance(\n                        i, int\n                    ), \"Item in minor_population_indices is not an int: \" + str(i)\n            except TypeError:\n                # Not iterable\n                assert False, \"minor_population_indices given is not iterable! \" + str(\n                    self.minor_population_indices\n                )\n\n        assert isinstance(filename, str)\n        # Use expand user path to allow use of \"~\"\n        self.filename = str(pathlib.Path(filename).expanduser())\n        assert pathlib.Path(self.filename).is_file()\n\n        # Use pysam to parse the VCF\n        # Pylint doesn't think there is a VariantFile method but it works...\n        vcf = pysam.VariantFile(self.filename)\n\n        # Get some basic metadata\n        self.vcf_version = vcf.version\n\n        # Get the contig lengths from the header\n        self.contig_lengths = {}\n        for name in list(vcf.header.contigs):\n            self.contig_lengths[name] = vcf.header.contigs[name].length\n\n        # Get the formats\n        self.format_fields_metadata = {}\n        for format_ in vcf.header.formats.keys():\n            description = vcf.header.formats[format_].description\n            # mypy doesn't like this as apparently this doesn't have an 'id' attr\n            #   however, it works and evidently does\n            id_ = vcf.header.formats[format_].id  # type: ignore\n            f_type = vcf.header.formats[format_].type\n            self.format_fields_metadata[format_] = {\n                \"description\": description,\n                \"id\": id_,\n                \"type\": f_type,\n            }\n\n        if isinstance(self.format_fields_min_thresholds, dict):\n            assert set(self.format_fields_min_thresholds.keys()).issubset(\n                set(self.format_fields_metadata.keys())\n            ), \"field to threshold on not found in the FORMAT column of the vcf!\"\n\n        # Get the records\n        self.records = []\n        for record in list(vcf):\n            for sample in record.samples.keys():\n                self.records.append(VCFRecord(record, sample, min_dp))\n\n        # Find calls will ensure that no calls have same position\n        self.__find_calls()\n\n        self.__get_variants()\n\n        self.snp_distance = numpy.sum(self.is_snp)\n\n        if len(self.minor_population_indices) &gt; 0:\n            # We are asking to find some minor variants\n            # So we need to check if the COV/AD field exists as this shows\n            #   minor populations\n            assert (\n                \"COV\" in self.format_fields_metadata.keys()\n                or \"AD\" in self.format_fields_metadata.keys()\n            ), (\n                \"'COV' and 'AD' not in VCF format fields. \"\n                \"No minor populations can be found!\"\n            )\n            self._find_minor_populations()\n        else:\n            # Give a sensible default value otherwise\n            self.minor_populations: List = []\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Overload the print function to write a summary of the VCF file\n\n        Returns:\n            str: String summarising the VCF file\n        \"\"\"\n        output = (\n            \"VCF variant file, version \"\n            + \"\".join(str(i) + \".\" for i in self.vcf_version)[:-1]\n            + \"\\n\"\n        )\n        output += self.filename + \"\\n\"\n        output += str(len(self.records)) + \" records\" + \"\\n\"\n        output += (\n            \"FORMAT columns: \"\n            + \", \".join(i for i in sorted(list(self.format_fields_metadata.keys())))\n            + \"\\n\"\n            + \"\\n\"\n        )\n        if len(self.records) &gt; 3:\n            output += str(self.records[0])\n            output += str(self.records[1])\n            output += str(self.records[2])\n            output += \"...\\n\"\n            output += str(self.records[-1])\n        else:\n            for record in self.records:\n                output += str(record) + \"\\n\"\n        return output\n\n    def _find_minor_populations(self):\n        \"\"\"Find the minor populations for this VCF based on the minor population\n            positions given.\n        Deconstructs these into actual mutations of SNP/INDEL too as this logic already\n            exists here\n\n        * Minor populations are intentionally kept very separate from other variants.\n        * They are very infrequent compared to other variants so storing in similar\n            structures would be resource heavy.\n        * They are instead stored consistently in the form of calls:\n            * [position, type, bases, depth, frs]\n                * position: Genome position (or Gene position if within genes)\n                * type: String denoting type of variant. One of ['ref', 'snp',\n                    'ins', 'del']\n                * bases: Descripton of the bases.\n                    * If type in ['ref', 'snp'], of the format (ref base, alt base)\n                    * If type in ['ins', 'del'], string of the bases inserted or deleted\n                * depth: number of reads supporting this call\n                * frs: fractional read support (i.e depth/total coverage at this point)\n        \"\"\"\n        self.minor_populations = []\n        simple_calls = []\n        for idx, type_ in self.calls.keys():\n            for item in self.calls[(idx, type_)]:\n                # Get the simple format of this call for comparison\n                if isinstance(item[\"call\"], tuple):\n                    # Indels\n                    t = item[\"call\"][0]\n                    bases = item[\"call\"][1]\n                    pos = item[\"pos\"]\n                else:\n                    # Snps\n                    if item[\"call\"] == \"x\":\n                        # Null calls shouldn't have minor populations\n                        continue\n                    t = \"snp\"\n                    bases = (\n                        item[\"ref\"],\n                        item[\"call\"],\n                    )\n                    pos = item[\"pos\"]\n                simple_calls.append((idx, pos, t, bases))\n        seen = set()\n\n        for idx, type_ in tqdm(self.calls.keys()):\n            for item in self.calls[(idx, type_)]:\n                # Check if we've delt with this vcf already\n                if str(item[\"original_vcf_row\"]) in seen:\n                    continue\n                else:\n                    seen.add(str(item[\"original_vcf_row\"]))\n\n                # Pull out depth tag from the specific row's format fields\n                # as the file metadata isn't a guarantee of the actual\n                # fields of this row\n                allelic_depth_tag = (\n                    \"COV\" if item[\"original_vcf_row\"].get(\"COV\", None) else \"AD\"\n                )\n\n                # Checking for het calls\n                if item[\"call\"] == \"z\":\n                    if 0 not in item[\"original_vcf_row\"][\"GT\"]:\n                        # Het call without a wildtype call, so warn about\n                        # behaviour\n                        warnings.warn(\n                            f\"Minor population detected at position {idx}, which \"\n                            f\"doesn't include a wildtype call. Call: \"\n                            f\"{item['original_vcf_row']['GT']}. Note that there \"\n                            \"may be multiple mutations given at this index\",\n                            UserWarning,\n                        )\n\n                # Reference base(s)\n                ref = item[\"original_vcf_row\"][\"REF\"]\n\n                if item[\"original_vcf_row\"][\"ALTS\"] is None:\n                    # Case arrises from gvcf ref calls not giving any alts\n                    calls = [item[\"original_vcf_row\"][\"REF\"]]\n                else:\n                    # Get all of the calls\n                    calls = [item[\"original_vcf_row\"][\"REF\"]] + list(\n                        item[\"original_vcf_row\"][\"ALTS\"]\n                    )\n\n                # Break down the calls as appropriate\n                simple = [self._simplify_call(ref, alt) for alt in calls]\n\n                # Map each call to the corresponding read depth\n                dps = list(item[\"original_vcf_row\"][allelic_depth_tag])\n\n                # GVCF null calls get None for depth, so catch (and skip) this\n                if dps == [None]:\n                    continue\n                else:\n                    total_depth = sum(dps)\n\n                # idx here refers to the position of this call, NOT this vcf row,\n                # so adjust to avoid shifting when building minor calls\n                idx = idx - item[\"pos\"]\n                for calls, depth in zip(simple, dps):\n                    # As we can have &gt;1 call per simple, iter\n                    for call in calls:\n                        # Check that this call isn't one of the actual calls\n                        if (idx + int(call[0]), *call) in simple_calls:\n                            # Is an actual call so we skip\n                            continue\n                        # Check if there are &gt;=2 reads to support this call\n                        if depth &gt;= 2:\n                            # These are minor calls!!\n                            pos = idx + int(call[0])\n                            if pos not in self.minor_population_indices:\n                                # We don't actually care though\n                                # This has to be done here as simplifying calls can move\n                                #   the position\n                                continue\n                            if call[1] == \"snp\" and call[2][0] == call[2][1]:\n                                # Ref calls aren't interesting\n                                continue\n                            # Only tracking absolute number of reads\n                            self.minor_populations.append(\n                                (\n                                    pos,\n                                    call[1],\n                                    call[2],\n                                    int(depth),\n                                    round(depth / total_depth, 3),\n                                    item[\"original_vcf_row\"],\n                                )\n                            )\n\n    def __find_calls(self):\n        \"\"\"\n        Private method to find changes within the genome based on the variant file.\n\n        Creates calls dict used elsewhere.\n        \"\"\"\n\n        self.calls = defaultdict(list)\n\n        for record in self.records:\n            # VCF files are 1 indexed but keep for now\n            index = copy.deepcopy(record.pos)\n\n            # if we've asked, bypass (for speed) if this is a ref call\n            if self.bypass_reference_calls and record.is_reference:\n                continue\n\n            # bypass filter fails , unless we have asked to ignore filter calls\n            if (\n                index not in self.minor_population_indices\n                and not self.ignore_filter\n                and not record.is_filter_pass\n            ):\n                continue\n\n            # only proceed if a dictionary has been passed (otherwise defaults to None)\n            if isinstance(self.format_fields_min_thresholds, dict):\n                # ok to just do since we've already check in the constructor that these\n                #   fields exist in the VCF\n                proceed = all(\n                    record.values[i] &gt;= self.format_fields_min_thresholds[i]\n                    for i in self.format_fields_min_thresholds\n                )\n                if not proceed:\n                    continue\n\n            if (\n                len(self.minor_population_indices) &gt; 0\n                and\n                # We're looking for minor populations\n                not self.ignore_filter\n                and\n                # We don't want to ignore the filter though\n                # so to avoid picking up erroneous actual calls,\n                # set this to be a ref call if it is filter fail\n                not record.is_filter_pass\n            ):\n                # We only want to allow these through if the filter fail contains MIN_FRS\n                if record.filter is not None and \"MIN_FRS\" in record.filter:\n                    # Allow MIN_FRS\n                    variant = record.ref\n                    variant_type = \"ref\"\n                else:\n                    # Discard any other filter fails\n                    continue\n            elif record.is_heterozygous:\n                variant = \"z\" * len(record.ref)\n                variant_type = \"het\"\n            elif record.is_alt:\n                variant = record.alts[record.call1 - 1]\n                variant_type = \"snp\"\n            elif record.is_null:\n                variant = \"x\" * len(record.ref)\n                variant_type = \"null\"\n            elif record.is_reference:\n                variant = record.ref\n                variant_type = \"ref\"\n\n            # if the REF, ALT pair are the same length, check if we can decompose\n            #   into SNPs\n            if len(record.ref) == len(variant):\n                for counter, (before, after) in enumerate(zip(record.ref, variant)):\n                    metadata = {}\n                    metadata[\"call\"] = after\n                    metadata[\"ref\"] = before\n                    metadata[\"pos\"] = counter\n                    vcf_info = {}\n                    vcf_info = copy.deepcopy(record.values)\n                    vcf_info[\"REF\"] = record.ref\n                    vcf_info[\"ALTS\"] = record.alts\n                    metadata[\"original_vcf_row\"] = vcf_info\n                    if self.calls.get((index + counter, variant_type)) is not None:\n                        warnings.warn(\n                            UserWarning(\n                                f\"Multiple calls at position {index}\"\n                                + f\" with type {variant_type} in VCF file\"\n                            )\n                        )\n                    self.calls[(index + counter, variant_type)].append(metadata)\n\n            # otherwise the REF, ALT pair are different lengths\n            else:\n                # try and simplify into a single indel and multiple SNPs\n                mutations = self._simplify_call(record.ref, variant)\n\n                for p, type_, bases in mutations:\n                    # p = max(p - 1, 0)\n                    if type_ in [\"ins\", \"del\"]:\n                        metadata = {}\n                        metadata[\"call\"] = (type_, bases)\n                        metadata[\"ref\"] = record.ref[0]\n                        metadata[\"pos\"] = p\n                        vcf_info = {}\n                        vcf_info = copy.deepcopy(record.values)\n                        vcf_info[\"REF\"] = record.ref\n                        vcf_info[\"ALTS\"] = record.alts\n                        metadata[\"original_vcf_row\"] = vcf_info\n                        if self.calls.get((index + p, \"indel\")) is not None:\n                            warnings.warn(\n                                UserWarning(\n                                    f\"Multiple calls at position {index}\"\n                                    + \" with type indel in VCF file\"\n                                )\n                            )\n                        self.calls[(index + p, \"indel\")].append(metadata)\n\n                    else:\n                        metadata = {}\n                        metadata[\"call\"] = bases[1]\n                        metadata[\"ref\"] = bases[0]\n                        metadata[\"pos\"] = p\n                        vcf_info = {}\n                        vcf_info = copy.deepcopy(record.values)\n                        vcf_info[\"REF\"] = record.ref\n                        vcf_info[\"ALTS\"] = record.alts\n                        metadata[\"original_vcf_row\"] = vcf_info\n                        if self.calls.get((index + p, variant_type)) is not None:\n                            warnings.warn(\n                                UserWarning(\n                                    f\"Multiple calls at position {index}\"\n                                    + f\" with type {variant_type} in VCF file\"\n                                )\n                            )\n                        self.calls[(index + p, variant_type)].append(metadata)\n\n    def _simplify_call(self, ref: str, alt: str) -&gt; List[Tuple[int, str, str]]:\n        \"\"\"Private method to simplify a complex call into one indel and multiple SNPs.\n\n        Based on finding the indel position at which there is the least SNPs\n\n        Args:\n            ref (str): Reference bases. Should match reference bases at this point\n            alt (str): Alt bases.\n\n        Returns:\n            [(int, str, str)]: Returns a list of tuples of (pos, one of ['ins','del',\n                'snp'], indel_bases or (ref, alt) for SNPs)\n        \"\"\"\n\n        def snp_number(ref: Iterable | None, alt: Iterable | None) -&gt; int | float:\n            \"\"\"Count the number of SNPs between 2 sequences\n\n            Args:\n                ref (str): Reference bases\n                alt (str): Alt bases\n\n            Returns:\n                int: Number of SNPs between ref and alt\n            \"\"\"\n            if ref is None or alt is None:\n                return float(\"inf\")\n            snps = 0\n            for a, b in zip(ref, alt):\n                if a is not None and b is not None and a != b:\n                    snps += 1\n            return snps\n\n        \"\"\"The process for finding the positions for indels are almost identical\n        as the process for finding a del can be interpreted as finding an ins with ref \n            and alt reversed.\n        The approach here is to use a sliding window to find the position of the indel \n            where the number of SNPs is lowest.\n        Assumes that there is only a single indel between the ref and the alt - there \n            may be cases where this does not work these will just produce large amounts \n            of SNPs... Could be adapted to check for multi-indel but this will scale\n            exponentially the number of versions checked.\n        \"\"\"\n        if len(ref) &gt; len(alt):\n            # Del\n            length = len(ref) - len(alt)\n            x = ref\n            y = alt\n            indel = \"del\"\n        elif len(ref) &lt; len(alt):\n            # Ins\n            length = len(alt) - len(ref)\n            x = alt\n            y = ref\n            indel = \"ins\"\n        else:\n            # Just SNPs\n            # Should only be used in minor populations\n            mutations_: List = []\n            for i, (r, a) in enumerate(zip(ref, alt)):\n                mutations_.append([i, \"snp\", (r, a)])\n            return mutations_\n        start = 0\n        current: List[str | None] = []\n        current_snps = float(\"inf\")\n        mutations: List = []\n        for i in range(len(y) + 1):\n            y1 = (\n                [y[a] for a in range(i)]\n                + [None for a in range(length)]\n                + [y[a] for a in range(i, len(y))]\n            )\n            if snp_number(y1, x) &lt;= current_snps:\n                current = y1\n                current_snps = snp_number(y1, x)\n                start = i\n        seq = [x[i] for i in range(len(current)) if current[i] is None]\n        # Add the indel\n        if indel == \"ins\":\n            # Ins after index, del at index so adjust ins\n            start -= 1\n        mutations.append((start, indel, \"\".join(seq)))\n        # Check for SNPs and add those\n        for i, (a, b) in enumerate(zip(x, current)):\n            if a is not None and b is not None and a != b:\n                if indel == \"ins\":\n                    # PWF was (i-1) but corrected, prob\n                    mutations.append((i, \"snp\", (b, a)))\n                else:\n                    mutations.append((i, \"snp\", (a, b)))\n        return mutations\n\n    def to_df(self) -&gt; pandas.DataFrame:\n        \"\"\"Convert the VCFFile to a pandas DataFrame.\n\n        Metadata is stored in the `attrs` attribute of the DataFrame which may break\n            with some operations\n        (but pandas does not currently have a robust method for metadata storage...)\n\n        Returns:\n            pandas.DataFrame: DataFrame containing all of the information from the\n                VCF file\n        \"\"\"\n        meta_data: Dict = {\n            \"vcf_version\": self.vcf_version,\n            \"contig_lengths\": self.contig_lengths,\n            \"formats\": self.format_fields_metadata,\n        }\n\n        chroms = []\n        pos = []\n        refs = []\n        alts = []\n        qual = []\n        infos = []\n        filter_ = []\n        values: Dict = {}\n        for record in self.records:\n            chroms.append(record.chrom)\n            pos.append(record.pos)\n            refs.append(record.ref)\n            alts.append(record.alts)\n            qual.append(record.qual)\n            infos.append(record.info)\n            filter_.append(record.filter)\n            for key in record.values:\n                if values.get(key) is None:\n                    values[key] = [record.values[key]]\n                else:\n                    values[key].append(record.values[key])\n        df = pandas.DataFrame(\n            {\n                \"CHROM\": chroms,\n                \"POS\": pos,\n                \"REF\": refs,\n                \"ALTS\": alts,\n                \"QUAL\": qual,\n                \"INFO\": infos,\n                \"FILTER\": filter_,\n                **values,\n            }\n        )\n        df.attrs = meta_data\n        return df\n\n    def __get_variants(self):\n        \"\"\"\n        Private method to pull the variants out of the VCFFile object.\n\n        Builds arrays of the variant calls, and their respective genome indices, as\n            well as\n        masks to show whether there is a snp, het, null or indel call at the\n            corresponding genome index:\n        i.e is_snp[genome.nucleotide_number == indices[i]] gives a bool to determine\n            if a genome has a SNP call at this position\n        \"\"\"\n\n        alts = []\n        variants = []\n        indices = []\n        refs = []\n        positions = []\n        is_snp = []\n        is_het = []\n        is_null = []\n        is_indel = []\n        indel_length = []\n        metadata = defaultdict(list)\n        to_drop = []\n\n        for index, type_ in sorted(list(self.calls.keys())):\n            for idx, item in enumerate(self.calls[(index, type_)]):\n                call = item[\"call\"]\n                alt = call\n                ref = item[\"ref\"]\n                if ref == alt and self.bypass_reference_calls:\n                    # If we have a call at a position which the alt is a reference call\n                    # we should only care if we haven't tried to bypass ref calls\n                    # Have to check here too i.e CCC-&gt;ATC will have a ref call at pos 3\n                    to_drop.append((idx, (index, type_)))\n                    continue\n                indices.append(index)\n                refs.append(ref)\n                pos = item[\"pos\"]\n                positions.append(pos)\n                # Update the masks with the appropriate types\n                if type_ == \"indel\":\n                    # Convert to ins_x or del_x rather than tuple\n                    variant = str(index) + \"_\" + call[0] + \"_\" + str(call[1])\n                    alt = call[1]\n                    is_indel.append(True)\n                    if call[0] == \"ins\":\n                        indel_length.append(len(call[1]))\n                    else:\n                        indel_length.append(-1 * len(call[1]))\n                    is_snp.append(False)\n                    is_het.append(False)\n                    is_null.append(False)\n                elif type_ == \"snp\":\n                    variant = str(index) + ref + \"&gt;\" + call\n                    is_indel.append(False)\n                    indel_length.append(0)\n                    is_snp.append(True)\n                    is_het.append(False)\n                    is_null.append(False)\n                elif type_ == \"het\":\n                    variant = str(index) + ref + \"&gt;\" + call\n                    is_indel.append(False)\n                    indel_length.append(0)\n                    is_snp.append(False)\n                    is_het.append(True)\n                    is_null.append(False)\n                elif type_ == \"null\":\n                    variant = str(index) + ref + \"&gt;\" + call\n                    is_indel.append(False)\n                    indel_length.append(0)\n                    is_snp.append(False)\n                    is_het.append(False)\n                    is_null.append(True)\n                elif type_ == \"ref\":\n                    variant = str(index) + ref + \"&gt;\" + ref\n                    is_indel.append(False)\n                    indel_length.append(0)\n                    is_snp.append(False)\n                    is_het.append(False)\n                    is_null.append(False)\n                alts.append(alt)\n                variants.append(variant)\n                for key in item[\"original_vcf_row\"]:\n                    metadata[key].append(item[\"original_vcf_row\"][key])\n\n        # Remove ref calls as required\n        for idx, key in to_drop:\n            del self.calls[key][idx]\n            if len(self.calls[key]) == 0:\n                del self.calls[key]\n\n        # Convert to numpy arrays for neat indexing\n        self.alt_nucleotides = numpy.array(alts)\n        self.variants = numpy.array(variants)\n        self.nucleotide_index = numpy.array(indices)\n        self.is_indel = numpy.array(is_indel)\n        self.indel_length = numpy.array(indel_length)\n        self.is_snp = numpy.array(is_snp)\n        self.is_het = numpy.array(is_het)\n        self.is_null = numpy.array(is_null)\n        self.ref_nucleotides = numpy.array(refs)\n        self.pos = numpy.array(positions)\n        self.metadata = dict()\n        for key in metadata:\n            self.metadata[key] = numpy.array(metadata[key], dtype=object)\n</code></pre>"},{"location":"reference/variantfile/#variantfile.VCFFile.__find_calls","title":"<code>__find_calls()</code>","text":"<p>Private method to find changes within the genome based on the variant file.</p> <p>Creates calls dict used elsewhere.</p> Source code in <code>gumpy/variantfile.py</code> <pre><code>def __find_calls(self):\n    \"\"\"\n    Private method to find changes within the genome based on the variant file.\n\n    Creates calls dict used elsewhere.\n    \"\"\"\n\n    self.calls = defaultdict(list)\n\n    for record in self.records:\n        # VCF files are 1 indexed but keep for now\n        index = copy.deepcopy(record.pos)\n\n        # if we've asked, bypass (for speed) if this is a ref call\n        if self.bypass_reference_calls and record.is_reference:\n            continue\n\n        # bypass filter fails , unless we have asked to ignore filter calls\n        if (\n            index not in self.minor_population_indices\n            and not self.ignore_filter\n            and not record.is_filter_pass\n        ):\n            continue\n\n        # only proceed if a dictionary has been passed (otherwise defaults to None)\n        if isinstance(self.format_fields_min_thresholds, dict):\n            # ok to just do since we've already check in the constructor that these\n            #   fields exist in the VCF\n            proceed = all(\n                record.values[i] &gt;= self.format_fields_min_thresholds[i]\n                for i in self.format_fields_min_thresholds\n            )\n            if not proceed:\n                continue\n\n        if (\n            len(self.minor_population_indices) &gt; 0\n            and\n            # We're looking for minor populations\n            not self.ignore_filter\n            and\n            # We don't want to ignore the filter though\n            # so to avoid picking up erroneous actual calls,\n            # set this to be a ref call if it is filter fail\n            not record.is_filter_pass\n        ):\n            # We only want to allow these through if the filter fail contains MIN_FRS\n            if record.filter is not None and \"MIN_FRS\" in record.filter:\n                # Allow MIN_FRS\n                variant = record.ref\n                variant_type = \"ref\"\n            else:\n                # Discard any other filter fails\n                continue\n        elif record.is_heterozygous:\n            variant = \"z\" * len(record.ref)\n            variant_type = \"het\"\n        elif record.is_alt:\n            variant = record.alts[record.call1 - 1]\n            variant_type = \"snp\"\n        elif record.is_null:\n            variant = \"x\" * len(record.ref)\n            variant_type = \"null\"\n        elif record.is_reference:\n            variant = record.ref\n            variant_type = \"ref\"\n\n        # if the REF, ALT pair are the same length, check if we can decompose\n        #   into SNPs\n        if len(record.ref) == len(variant):\n            for counter, (before, after) in enumerate(zip(record.ref, variant)):\n                metadata = {}\n                metadata[\"call\"] = after\n                metadata[\"ref\"] = before\n                metadata[\"pos\"] = counter\n                vcf_info = {}\n                vcf_info = copy.deepcopy(record.values)\n                vcf_info[\"REF\"] = record.ref\n                vcf_info[\"ALTS\"] = record.alts\n                metadata[\"original_vcf_row\"] = vcf_info\n                if self.calls.get((index + counter, variant_type)) is not None:\n                    warnings.warn(\n                        UserWarning(\n                            f\"Multiple calls at position {index}\"\n                            + f\" with type {variant_type} in VCF file\"\n                        )\n                    )\n                self.calls[(index + counter, variant_type)].append(metadata)\n\n        # otherwise the REF, ALT pair are different lengths\n        else:\n            # try and simplify into a single indel and multiple SNPs\n            mutations = self._simplify_call(record.ref, variant)\n\n            for p, type_, bases in mutations:\n                # p = max(p - 1, 0)\n                if type_ in [\"ins\", \"del\"]:\n                    metadata = {}\n                    metadata[\"call\"] = (type_, bases)\n                    metadata[\"ref\"] = record.ref[0]\n                    metadata[\"pos\"] = p\n                    vcf_info = {}\n                    vcf_info = copy.deepcopy(record.values)\n                    vcf_info[\"REF\"] = record.ref\n                    vcf_info[\"ALTS\"] = record.alts\n                    metadata[\"original_vcf_row\"] = vcf_info\n                    if self.calls.get((index + p, \"indel\")) is not None:\n                        warnings.warn(\n                            UserWarning(\n                                f\"Multiple calls at position {index}\"\n                                + \" with type indel in VCF file\"\n                            )\n                        )\n                    self.calls[(index + p, \"indel\")].append(metadata)\n\n                else:\n                    metadata = {}\n                    metadata[\"call\"] = bases[1]\n                    metadata[\"ref\"] = bases[0]\n                    metadata[\"pos\"] = p\n                    vcf_info = {}\n                    vcf_info = copy.deepcopy(record.values)\n                    vcf_info[\"REF\"] = record.ref\n                    vcf_info[\"ALTS\"] = record.alts\n                    metadata[\"original_vcf_row\"] = vcf_info\n                    if self.calls.get((index + p, variant_type)) is not None:\n                        warnings.warn(\n                            UserWarning(\n                                f\"Multiple calls at position {index}\"\n                                + f\" with type {variant_type} in VCF file\"\n                            )\n                        )\n                    self.calls[(index + p, variant_type)].append(metadata)\n</code></pre>"},{"location":"reference/variantfile/#variantfile.VCFFile.__get_variants","title":"<code>__get_variants()</code>","text":"<p>Private method to pull the variants out of the VCFFile object.</p> <p>Builds arrays of the variant calls, and their respective genome indices, as     well as masks to show whether there is a snp, het, null or indel call at the     corresponding genome index: i.e is_snp[genome.nucleotide_number == indices[i]] gives a bool to determine     if a genome has a SNP call at this position</p> Source code in <code>gumpy/variantfile.py</code> <pre><code>def __get_variants(self):\n    \"\"\"\n    Private method to pull the variants out of the VCFFile object.\n\n    Builds arrays of the variant calls, and their respective genome indices, as\n        well as\n    masks to show whether there is a snp, het, null or indel call at the\n        corresponding genome index:\n    i.e is_snp[genome.nucleotide_number == indices[i]] gives a bool to determine\n        if a genome has a SNP call at this position\n    \"\"\"\n\n    alts = []\n    variants = []\n    indices = []\n    refs = []\n    positions = []\n    is_snp = []\n    is_het = []\n    is_null = []\n    is_indel = []\n    indel_length = []\n    metadata = defaultdict(list)\n    to_drop = []\n\n    for index, type_ in sorted(list(self.calls.keys())):\n        for idx, item in enumerate(self.calls[(index, type_)]):\n            call = item[\"call\"]\n            alt = call\n            ref = item[\"ref\"]\n            if ref == alt and self.bypass_reference_calls:\n                # If we have a call at a position which the alt is a reference call\n                # we should only care if we haven't tried to bypass ref calls\n                # Have to check here too i.e CCC-&gt;ATC will have a ref call at pos 3\n                to_drop.append((idx, (index, type_)))\n                continue\n            indices.append(index)\n            refs.append(ref)\n            pos = item[\"pos\"]\n            positions.append(pos)\n            # Update the masks with the appropriate types\n            if type_ == \"indel\":\n                # Convert to ins_x or del_x rather than tuple\n                variant = str(index) + \"_\" + call[0] + \"_\" + str(call[1])\n                alt = call[1]\n                is_indel.append(True)\n                if call[0] == \"ins\":\n                    indel_length.append(len(call[1]))\n                else:\n                    indel_length.append(-1 * len(call[1]))\n                is_snp.append(False)\n                is_het.append(False)\n                is_null.append(False)\n            elif type_ == \"snp\":\n                variant = str(index) + ref + \"&gt;\" + call\n                is_indel.append(False)\n                indel_length.append(0)\n                is_snp.append(True)\n                is_het.append(False)\n                is_null.append(False)\n            elif type_ == \"het\":\n                variant = str(index) + ref + \"&gt;\" + call\n                is_indel.append(False)\n                indel_length.append(0)\n                is_snp.append(False)\n                is_het.append(True)\n                is_null.append(False)\n            elif type_ == \"null\":\n                variant = str(index) + ref + \"&gt;\" + call\n                is_indel.append(False)\n                indel_length.append(0)\n                is_snp.append(False)\n                is_het.append(False)\n                is_null.append(True)\n            elif type_ == \"ref\":\n                variant = str(index) + ref + \"&gt;\" + ref\n                is_indel.append(False)\n                indel_length.append(0)\n                is_snp.append(False)\n                is_het.append(False)\n                is_null.append(False)\n            alts.append(alt)\n            variants.append(variant)\n            for key in item[\"original_vcf_row\"]:\n                metadata[key].append(item[\"original_vcf_row\"][key])\n\n    # Remove ref calls as required\n    for idx, key in to_drop:\n        del self.calls[key][idx]\n        if len(self.calls[key]) == 0:\n            del self.calls[key]\n\n    # Convert to numpy arrays for neat indexing\n    self.alt_nucleotides = numpy.array(alts)\n    self.variants = numpy.array(variants)\n    self.nucleotide_index = numpy.array(indices)\n    self.is_indel = numpy.array(is_indel)\n    self.indel_length = numpy.array(indel_length)\n    self.is_snp = numpy.array(is_snp)\n    self.is_het = numpy.array(is_het)\n    self.is_null = numpy.array(is_null)\n    self.ref_nucleotides = numpy.array(refs)\n    self.pos = numpy.array(positions)\n    self.metadata = dict()\n    for key in metadata:\n        self.metadata[key] = numpy.array(metadata[key], dtype=object)\n</code></pre>"},{"location":"reference/variantfile/#variantfile.VCFFile.__init__","title":"<code>__init__(filename, ignore_filter=False, bypass_reference_calls=False, format_fields_min_thresholds=None, minor_population_indices=[], min_dp=None)</code>","text":"<p>Constructor for the VCFFile object.</p> <p>Parses the VCF file using pysam.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str) </code> <p>The name of the VCF file</p> required <code>ignore_filter</code> <code>bool</code> <p>If True, ignore the FILTER column in the VCF file. Default is False.</p> <code>False</code> <code>bypass_reference_calls</code> <code>bool</code> <p>If True, skip any row in the VCF (and therefore do not record)  which calls reference (i.e. 0/0). Default is False.</p> <code>False</code> <code>format_fields_min_thresholds</code> <code>dict</code> <p>Dict of field name in the FORMAT column and a minimum threshold to apply e.g. {'DP':5}</p> <code>None</code> <code>minor_population_indices</code> <code>set</code> <p>set of genome indices names within which to look for minor populations</p> <code>[]</code> <code>min_dp</code> <code>int</code> <p>Minimum depth to consider a call. Default is None</p> <code>None</code> Source code in <code>gumpy/variantfile.py</code> <pre><code>def __init__(\n    self,\n    filename: str,\n    ignore_filter: bool = False,\n    bypass_reference_calls: bool = False,\n    format_fields_min_thresholds: Dict[str, int] | None = None,\n    minor_population_indices: Collection[int] = [],\n    min_dp: int | None = None,\n):\n    \"\"\"\n    Constructor for the VCFFile object.\n\n    Parses the VCF file using pysam.\n\n    Args:\n        filename (str) : The name of the VCF file\n        ignore_filter (bool, optional): If True, ignore the FILTER column in the\n            VCF file. Default is False.\n        bypass_reference_calls (bool, optional): If True, skip any row in the VCF\n            (and therefore do not record)  which calls reference (i.e. 0/0).\n            Default is False.\n        format_fields_min_thresholds (dict, optional): Dict of field name in the\n            FORMAT column and a minimum threshold to apply e.g. {'DP':5}\n        minor_population_indices (set, optional): set of genome indices names\n            within which to look for minor populations\n        min_dp (int, optional): Minimum depth to consider a call. Default is None\n    \"\"\"\n\n    self.ignore_filter = ignore_filter\n    assert isinstance(self.ignore_filter, bool)\n\n    self.bypass_reference_calls = bypass_reference_calls\n    assert isinstance(self.bypass_reference_calls, bool)\n\n    self.format_fields_min_thresholds = format_fields_min_thresholds\n    if self.format_fields_min_thresholds is not None:\n        assert isinstance(self.format_fields_min_thresholds, dict)\n\n    self.minor_population_indices = minor_population_indices\n    # As {}/[] is a dangerous default value, convert from None to {} as req\n    if self.minor_population_indices is None:\n        self.minor_population_indices = set()\n    else:\n        # Value given, so check if it's of the right format\n        # Functionally, we don't care if it's actually a set. We just care its an\n        #   interable of ints\n        try:\n            for i in self.minor_population_indices:\n                assert isinstance(\n                    i, int\n                ), \"Item in minor_population_indices is not an int: \" + str(i)\n        except TypeError:\n            # Not iterable\n            assert False, \"minor_population_indices given is not iterable! \" + str(\n                self.minor_population_indices\n            )\n\n    assert isinstance(filename, str)\n    # Use expand user path to allow use of \"~\"\n    self.filename = str(pathlib.Path(filename).expanduser())\n    assert pathlib.Path(self.filename).is_file()\n\n    # Use pysam to parse the VCF\n    # Pylint doesn't think there is a VariantFile method but it works...\n    vcf = pysam.VariantFile(self.filename)\n\n    # Get some basic metadata\n    self.vcf_version = vcf.version\n\n    # Get the contig lengths from the header\n    self.contig_lengths = {}\n    for name in list(vcf.header.contigs):\n        self.contig_lengths[name] = vcf.header.contigs[name].length\n\n    # Get the formats\n    self.format_fields_metadata = {}\n    for format_ in vcf.header.formats.keys():\n        description = vcf.header.formats[format_].description\n        # mypy doesn't like this as apparently this doesn't have an 'id' attr\n        #   however, it works and evidently does\n        id_ = vcf.header.formats[format_].id  # type: ignore\n        f_type = vcf.header.formats[format_].type\n        self.format_fields_metadata[format_] = {\n            \"description\": description,\n            \"id\": id_,\n            \"type\": f_type,\n        }\n\n    if isinstance(self.format_fields_min_thresholds, dict):\n        assert set(self.format_fields_min_thresholds.keys()).issubset(\n            set(self.format_fields_metadata.keys())\n        ), \"field to threshold on not found in the FORMAT column of the vcf!\"\n\n    # Get the records\n    self.records = []\n    for record in list(vcf):\n        for sample in record.samples.keys():\n            self.records.append(VCFRecord(record, sample, min_dp))\n\n    # Find calls will ensure that no calls have same position\n    self.__find_calls()\n\n    self.__get_variants()\n\n    self.snp_distance = numpy.sum(self.is_snp)\n\n    if len(self.minor_population_indices) &gt; 0:\n        # We are asking to find some minor variants\n        # So we need to check if the COV/AD field exists as this shows\n        #   minor populations\n        assert (\n            \"COV\" in self.format_fields_metadata.keys()\n            or \"AD\" in self.format_fields_metadata.keys()\n        ), (\n            \"'COV' and 'AD' not in VCF format fields. \"\n            \"No minor populations can be found!\"\n        )\n        self._find_minor_populations()\n    else:\n        # Give a sensible default value otherwise\n        self.minor_populations: List = []\n</code></pre>"},{"location":"reference/variantfile/#variantfile.VCFFile.__repr__","title":"<code>__repr__()</code>","text":"<p>Overload the print function to write a summary of the VCF file</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String summarising the VCF file</p> Source code in <code>gumpy/variantfile.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Overload the print function to write a summary of the VCF file\n\n    Returns:\n        str: String summarising the VCF file\n    \"\"\"\n    output = (\n        \"VCF variant file, version \"\n        + \"\".join(str(i) + \".\" for i in self.vcf_version)[:-1]\n        + \"\\n\"\n    )\n    output += self.filename + \"\\n\"\n    output += str(len(self.records)) + \" records\" + \"\\n\"\n    output += (\n        \"FORMAT columns: \"\n        + \", \".join(i for i in sorted(list(self.format_fields_metadata.keys())))\n        + \"\\n\"\n        + \"\\n\"\n    )\n    if len(self.records) &gt; 3:\n        output += str(self.records[0])\n        output += str(self.records[1])\n        output += str(self.records[2])\n        output += \"...\\n\"\n        output += str(self.records[-1])\n    else:\n        for record in self.records:\n            output += str(record) + \"\\n\"\n    return output\n</code></pre>"},{"location":"reference/variantfile/#variantfile.VCFFile.to_df","title":"<code>to_df()</code>","text":"<p>Convert the VCFFile to a pandas DataFrame.</p> <p>Metadata is stored in the <code>attrs</code> attribute of the DataFrame which may break     with some operations (but pandas does not currently have a robust method for metadata storage...)</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pandas.DataFrame: DataFrame containing all of the information from the VCF file</p> Source code in <code>gumpy/variantfile.py</code> <pre><code>def to_df(self) -&gt; pandas.DataFrame:\n    \"\"\"Convert the VCFFile to a pandas DataFrame.\n\n    Metadata is stored in the `attrs` attribute of the DataFrame which may break\n        with some operations\n    (but pandas does not currently have a robust method for metadata storage...)\n\n    Returns:\n        pandas.DataFrame: DataFrame containing all of the information from the\n            VCF file\n    \"\"\"\n    meta_data: Dict = {\n        \"vcf_version\": self.vcf_version,\n        \"contig_lengths\": self.contig_lengths,\n        \"formats\": self.format_fields_metadata,\n    }\n\n    chroms = []\n    pos = []\n    refs = []\n    alts = []\n    qual = []\n    infos = []\n    filter_ = []\n    values: Dict = {}\n    for record in self.records:\n        chroms.append(record.chrom)\n        pos.append(record.pos)\n        refs.append(record.ref)\n        alts.append(record.alts)\n        qual.append(record.qual)\n        infos.append(record.info)\n        filter_.append(record.filter)\n        for key in record.values:\n            if values.get(key) is None:\n                values[key] = [record.values[key]]\n            else:\n                values[key].append(record.values[key])\n    df = pandas.DataFrame(\n        {\n            \"CHROM\": chroms,\n            \"POS\": pos,\n            \"REF\": refs,\n            \"ALTS\": alts,\n            \"QUAL\": qual,\n            \"INFO\": infos,\n            \"FILTER\": filter_,\n            **values,\n        }\n    )\n    df.attrs = meta_data\n    return df\n</code></pre>"},{"location":"reference/variantfile/#variantfile.VCFRecord","title":"<code>VCFRecord</code>","text":"<p>               Bases: <code>object</code></p> <ul> <li>Class for VCF records</li> <li>Instance variables:<ul> <li><code>chrom</code> (str): Name of the sample.</li> <li><code>pos</code> (int): Genome index for the change.</li> <li><code>ref</code> (str): Reference value for the nucleotide.</li> <li><code>alts</code> (tuple(str) | None): Alternative calls. Tuple can contain single values     and indels.</li> <li><code>qual</code> (None): Values for quality (values other than None have yet to be     found in testing files...).</li> <li><code>filter</code> (str): Whether this record has pass the filter.</li> <li><code>info</code> (dict): Dictionary of key-&gt;value for the info fields.</li> <li><code>values</code> (dict): Dictionary of key-&gt;value for the values. Usually this is the     FORMAT field names with their corresponding values.</li> <li><code>is_filter_pass</code> (bool): does the filter column contain PASS?</li> <li><code>call1</code> (int): the index of the first call</li> <li><code>call2</code> (int): the index of the second call</li> <li><code>is_reference</code> (bool): is the call for the reference?</li> <li><code>is_null</code> (bool): is the call a null call?</li> <li><code>is_heterozygous</code> (bool): is it a is_heterozygous call i.e. call1!=call2?</li> <li><code>is_alt</code> (bool): or, is the call for a single specified alt</li> </ul> </li> </ul> Source code in <code>gumpy/variantfile.py</code> <pre><code>class VCFRecord(object):\n    \"\"\"\n    * Class for VCF records\n    * Instance variables:\n        * `chrom` (str): Name of the sample.\n        * `pos` (int): Genome index for the change.\n        * `ref` (str): Reference value for the nucleotide.\n        * `alts` (tuple(str) | None): Alternative calls. Tuple can contain single values\n            and indels.\n        * `qual` (None): Values for quality (values other than None have yet to be\n            found in testing files...).\n        * `filter` (str): Whether this record has pass the filter.\n        * `info` (dict): Dictionary of key-&gt;value for the info fields.\n        * `values` (dict): Dictionary of key-&gt;value for the values. Usually this is the\n            FORMAT field names with their corresponding values.\n        * `is_filter_pass` (bool): does the filter column contain PASS?\n        * `call1` (int): the index of the first call\n        * `call2` (int): the index of the second call\n        * `is_reference` (bool): is the call for the reference?\n        * `is_null` (bool): is the call a null call?\n        * `is_heterozygous` (bool): is it a is_heterozygous call i.e. call1!=call2?\n        * `is_alt` (bool): or, is the call for a single specified alt\n    \"\"\"\n\n    def __init__(\n        self, record: pysam.libcbcf.VariantRecord, sample: str | int, min_dp: int | None\n    ):\n        \"\"\"Constructor for the VCFRecord object.\n\n        Parses the supplied pysam object and presents in a more Pythonic format\n\n        Args:\n            record (pysam.libcbcf.VariantRecord): The record object\n            sample (str | int) : Name of the sample to consider. Used for possible cases\n                                where there is more than 1 sample per record\n            min_dp (int | None): Minimum depth to consider a call.\n        \"\"\"\n\n        assert (\n            len(record.samples.keys()) == 1\n        ), \"only supporting single samples per row at present!\"\n\n        assert (\n            \"GT\" in record.samples[sample].keys()\n        ), \"require GT in FORMAT column to parse genotype\"\n\n        # Save some of the easier to get to attributes\n        self.chrom = record.chrom\n        self.contig = record.contig\n        self.pos = record.pos\n\n        if record.ref is not None:\n            self.ref = record.ref.lower()\n        else:\n            self.ref = \"\"\n\n        self.alts: tuple | None\n        if record.alts is not None:\n            self.alts = tuple([i.lower() for i in record.alts])\n        else:\n            self.alts = None\n\n        self.qual = record.qual\n\n        # Get the filter attribute value\n        assert len(record.filter.items()) &gt;= 0, \"A record has more than 1 filter set!\"\n        self.filter: list[str] | None\n        if len(record.filter.items()) == 0:\n            self.filter = None\n            self.is_filter_pass = False\n        else:\n            self.filter = [str(x) for x in record.filter.keys()]\n            self.is_filter_pass = (\n                True if len(self.filter) == 1 and self.filter == [\"PASS\"] else False\n            )\n\n        # Get the info field\n        self.info = {}\n        for key, value in record.info.items():\n            self.info[key] = value\n\n        # Get the values\n        self.values = {}\n        for key, item in record.samples[sample].items():\n            # incorporate the logic from the old Genotype class here\n            if key == \"GT\":\n                if len(item) == 2:\n                    # Ploidy 2 is expected here\n                    call1, call2 = item\n                    self.call1 = call1 if call1 is not None else -1\n                    self.call2 = self.call1 if call2 is None else call2\n                else:\n                    # GVCF edge case with ploidy 1\n                    call1 = item[0]\n                    self.call1 = call1 if call1 is not None else -1\n                    self.call2 = self.call1\n                self.is_reference = (\n                    True\n                    if self.call1 == 0\n                    and (self.call1 == self.call2 or self.call2 == -1)\n                    else False\n                )\n                self.is_heterozygous = True if self.call1 != self.call2 else False\n                self.is_null = True if set([self.call1, self.call2]) == {-1} else False\n                self.is_alt = (\n                    True\n                    if not self.is_reference\n                    and not self.is_heterozygous\n                    and not self.is_null\n                    else False\n                )\n\n            # Due to how pysam reads floats, there are some erroneously long dps,\n            #   so round\n            elif isinstance(item, float):\n                item = round(item, 3)\n            self.values[key] = item\n        self.values[\"POS\"] = self.pos\n\n        if min_dp is not None:\n            allelic_depth_tag = \"COV\" if \"COV\" in self.values.keys() else \"AD\"\n            # Ensure we have a COV tag for downstream analysis\n            self.values[\"COV\"] = self.values[allelic_depth_tag]\n            if self.values[allelic_depth_tag] != (None,):\n                # If the depth given is below the threshold,\n                #   this row is a null call's row from the GVCF\n                # So treat it as such.\n                if len(self.values[allelic_depth_tag]) == 1:\n                    if self.values[allelic_depth_tag][0] &lt; min_dp:\n                        # Odd case where GVCF only gives the depth of the alt\n                        self.is_null = True\n                        self.is_heterozygous = False\n                        self.is_alt = False\n                        self.is_reference = False\n                elif (\n                    self.values[allelic_depth_tag][self.call1] &lt; min_dp\n                    or self.values[allelic_depth_tag][self.call2] &lt; min_dp\n                ):\n                    self.is_null = True\n                    self.is_heterozygous = False\n                    self.is_alt = False\n                    self.is_reference = False\n\n        if self.is_null and self.filter is not None:\n            # Override specifc filters for nulls to ensure they are detected\n            allowed_filters = [\"MIN_FRS\", \"MIN_DP\", \"MIN_GCP\", \"NO_DATA\"]\n            for f in self.filter:\n                if f not in allowed_filters:\n                    self.is_filter_pass = False\n                    break\n            self.is_filter_pass = True\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Pretty print the record\n\n        Returns:\n            str: String representation of the record\n        \"\"\"\n        s = self.chrom + \"\\t\"\n        s += str(self.pos) + \"\\t\"\n        s += self.ref + \"\\t\"\n        s += str(self.alts) + \"\\t\"\n        if self.qual is None:\n            s += \".\\t\"\n        else:\n            s += str(self.qual) + \"\\t\"\n        if self.filter is None:\n            s += \".\\t\"\n        else:\n            s += \",\".join(self.filter) + \"\\t\"\n        for val in self.values.keys():\n            if val == \"POS\":\n                continue\n            s += str(val) + \":\"\n        s = s[:-1] + \"\\t\"\n        for key in self.values.keys():\n            val = self.values[key]\n            if key == \"POS\":\n                continue\n            s += str(val) + \":\"\n        s = s[:-1]\n        s += \"\\n\"\n        return s\n</code></pre>"},{"location":"reference/variantfile/#variantfile.VCFRecord.__init__","title":"<code>__init__(record, sample, min_dp)</code>","text":"<p>Constructor for the VCFRecord object.</p> <p>Parses the supplied pysam object and presents in a more Pythonic format</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>VariantRecord</code> <p>The record object</p> required <code>sample</code> <code>str | int) </code> <p>Name of the sample to consider. Used for possible cases                 where there is more than 1 sample per record</p> required <code>min_dp</code> <code>int | None</code> <p>Minimum depth to consider a call.</p> required Source code in <code>gumpy/variantfile.py</code> <pre><code>def __init__(\n    self, record: pysam.libcbcf.VariantRecord, sample: str | int, min_dp: int | None\n):\n    \"\"\"Constructor for the VCFRecord object.\n\n    Parses the supplied pysam object and presents in a more Pythonic format\n\n    Args:\n        record (pysam.libcbcf.VariantRecord): The record object\n        sample (str | int) : Name of the sample to consider. Used for possible cases\n                            where there is more than 1 sample per record\n        min_dp (int | None): Minimum depth to consider a call.\n    \"\"\"\n\n    assert (\n        len(record.samples.keys()) == 1\n    ), \"only supporting single samples per row at present!\"\n\n    assert (\n        \"GT\" in record.samples[sample].keys()\n    ), \"require GT in FORMAT column to parse genotype\"\n\n    # Save some of the easier to get to attributes\n    self.chrom = record.chrom\n    self.contig = record.contig\n    self.pos = record.pos\n\n    if record.ref is not None:\n        self.ref = record.ref.lower()\n    else:\n        self.ref = \"\"\n\n    self.alts: tuple | None\n    if record.alts is not None:\n        self.alts = tuple([i.lower() for i in record.alts])\n    else:\n        self.alts = None\n\n    self.qual = record.qual\n\n    # Get the filter attribute value\n    assert len(record.filter.items()) &gt;= 0, \"A record has more than 1 filter set!\"\n    self.filter: list[str] | None\n    if len(record.filter.items()) == 0:\n        self.filter = None\n        self.is_filter_pass = False\n    else:\n        self.filter = [str(x) for x in record.filter.keys()]\n        self.is_filter_pass = (\n            True if len(self.filter) == 1 and self.filter == [\"PASS\"] else False\n        )\n\n    # Get the info field\n    self.info = {}\n    for key, value in record.info.items():\n        self.info[key] = value\n\n    # Get the values\n    self.values = {}\n    for key, item in record.samples[sample].items():\n        # incorporate the logic from the old Genotype class here\n        if key == \"GT\":\n            if len(item) == 2:\n                # Ploidy 2 is expected here\n                call1, call2 = item\n                self.call1 = call1 if call1 is not None else -1\n                self.call2 = self.call1 if call2 is None else call2\n            else:\n                # GVCF edge case with ploidy 1\n                call1 = item[0]\n                self.call1 = call1 if call1 is not None else -1\n                self.call2 = self.call1\n            self.is_reference = (\n                True\n                if self.call1 == 0\n                and (self.call1 == self.call2 or self.call2 == -1)\n                else False\n            )\n            self.is_heterozygous = True if self.call1 != self.call2 else False\n            self.is_null = True if set([self.call1, self.call2]) == {-1} else False\n            self.is_alt = (\n                True\n                if not self.is_reference\n                and not self.is_heterozygous\n                and not self.is_null\n                else False\n            )\n\n        # Due to how pysam reads floats, there are some erroneously long dps,\n        #   so round\n        elif isinstance(item, float):\n            item = round(item, 3)\n        self.values[key] = item\n    self.values[\"POS\"] = self.pos\n\n    if min_dp is not None:\n        allelic_depth_tag = \"COV\" if \"COV\" in self.values.keys() else \"AD\"\n        # Ensure we have a COV tag for downstream analysis\n        self.values[\"COV\"] = self.values[allelic_depth_tag]\n        if self.values[allelic_depth_tag] != (None,):\n            # If the depth given is below the threshold,\n            #   this row is a null call's row from the GVCF\n            # So treat it as such.\n            if len(self.values[allelic_depth_tag]) == 1:\n                if self.values[allelic_depth_tag][0] &lt; min_dp:\n                    # Odd case where GVCF only gives the depth of the alt\n                    self.is_null = True\n                    self.is_heterozygous = False\n                    self.is_alt = False\n                    self.is_reference = False\n            elif (\n                self.values[allelic_depth_tag][self.call1] &lt; min_dp\n                or self.values[allelic_depth_tag][self.call2] &lt; min_dp\n            ):\n                self.is_null = True\n                self.is_heterozygous = False\n                self.is_alt = False\n                self.is_reference = False\n\n    if self.is_null and self.filter is not None:\n        # Override specifc filters for nulls to ensure they are detected\n        allowed_filters = [\"MIN_FRS\", \"MIN_DP\", \"MIN_GCP\", \"NO_DATA\"]\n        for f in self.filter:\n            if f not in allowed_filters:\n                self.is_filter_pass = False\n                break\n        self.is_filter_pass = True\n</code></pre>"},{"location":"reference/variantfile/#variantfile.VCFRecord.__repr__","title":"<code>__repr__()</code>","text":"<p>Pretty print the record</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of the record</p> Source code in <code>gumpy/variantfile.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Pretty print the record\n\n    Returns:\n        str: String representation of the record\n    \"\"\"\n    s = self.chrom + \"\\t\"\n    s += str(self.pos) + \"\\t\"\n    s += self.ref + \"\\t\"\n    s += str(self.alts) + \"\\t\"\n    if self.qual is None:\n        s += \".\\t\"\n    else:\n        s += str(self.qual) + \"\\t\"\n    if self.filter is None:\n        s += \".\\t\"\n    else:\n        s += \",\".join(self.filter) + \"\\t\"\n    for val in self.values.keys():\n        if val == \"POS\":\n            continue\n        s += str(val) + \":\"\n    s = s[:-1] + \"\\t\"\n    for key in self.values.keys():\n        val = self.values[key]\n        if key == \"POS\":\n            continue\n        s += str(val) + \":\"\n    s = s[:-1]\n    s += \"\\n\"\n    return s\n</code></pre>"}]}